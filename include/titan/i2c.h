/**
 * This file is part of the Titan Flight Computer Project
 * Copyright (c) 2024 UW SARP
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 * 
 * @file common/platform/i2c.h
 * @authors Joshua Beard
 * @brief Driver for the I2C
 */

 #pragma once
 #include <stdint.h>
 #include <stdbool.h>
 #include <stddef.h>
 #include <string.h>
 
 #include "titan/gpio.h"
 #include "STM32H745/resource/mmio.h"
 
 #if defined(__cplusplus)
   extern "C" {
 #endif
 
 
 void tal_enable_I2C();
 
 void tal_transmit_I2C(uint8_t addr, void* data, uint32_t size);
 
 void* tal_read_I2C(uint8_t addr, uint32_t size);
 
 
 
 void tal_enable_I2C()
 { 
 
     tal_set_mode(133, 2); // alternate function mode
     tal_set_mode(134, 2);
 
     tal_set_drain(133, 1); // set open drain
     tal_set_drain(134, 1);
 
     tal_set_speed(133, 2); // set high speed, maybe needs to be 3 for very high speed
     tal_set_speed(134, 2);
 
     tal_pull_pin(133, 1); // set pull up
     tal_pull_pin(134, 1);
 
     tal_alternate_mode(133, 4); // set alternate mode to I2C
     tal_alternate_mode(134, 4);
 
     WRITE_FIELD(I2Cx_CR1[1], I2Cx_CR1_PE, 0);
     
     // for now disable digital and analog noise filters, we can chose to have these later
     WRITE_FIELD(I2Cx_CR1[1], I2Cx_CR1_DNF, 0);
     WRITE_FIELD(I2Cx_CR1[1], I2Cx_CR1_ANFOFF, 0);
 
     uint32_t timing = 0x00707CBB; // generated by STMCube, subject to change
     *I2Cx_TIMINGR[1] = timing;
 
     WRITE_FIELD(I2Cx_CR1[1], I2Cx_CR1_PE, 1);
 }
  
 static void tal_transmit_r(uint8_t addr, void* d, uint32_t size, bool first_call)
 {
     if(size <= 0){ // no data left to send
         return;
     }
 
     uint8_t* data = (uint8_t*)d;
 
     int data_size; // size of data to be sent on this call, either size or 255
 
     if(size <= 255){
         WRITE_FIELD(I2Cx_CR2[1], I2Cx_CR2_NBYTES, size);
         data_size = size;
     }else{
         WRITE_FIELD(I2Cx_CR2[1], I2Cx_CR2_NBYTES, 255);
         WRITE_FIELD(I2Cx_CR2[1], I2Cx_CR2_RELOAD, 1);
         data_size = 255;
     }
 
     if(first_call){
         // set addr mode, default 7 bit, so do nothing
         WRITE_FIELD(I2Cx_CR2[1], I2Cx_CR2_SADD_7BIT, addr);
         WRITE_FIELD(I2Cx_CR2[1], I2Cx_CR2_RD_WRN, 0);
         WRITE_FIELD(I2Cx_CR2[1], I2Cx_CR2_AUTOEND, 1);
         WRITE_FIELD(I2Cx_CR2[1], I2Cx_CR2_START, 1);
     }
 
     uint32_t timeout = 100000; // TODO tune parameter to "work" in testing
 
     while(data_size > 0){
         uint32_t count = 0;
         
         while(READ_FIELD(I2Cx_ISR[1], I2Cx_ISR_TXE) != 1 && 
         count++ < timeout); // wait until TXIS is set
         
         WRITE_FIELD(I2Cx_TXDR[1], I2Cx_TXDR_TXDATA, *data);
         
         data++;
         data_size--; // sent one byte
         size--; // keep track of size
     }
 
     
     tal_transmit_r(addr, data, size, false); // call again, with updated (less) data to send
 }

 void tal_transmit_I2C(uint8_t addr, void* d, uint32_t size)
 {
     tal_transmit_r(addr, d, size, true);
 }
 
 static void* tal_read_r(uint8_t addr, uint32_t size, bool first_call, uint8_t* data, uint32_t i)
 {
     if(size <= 0){ // no data left to read
         return data;
     }
 
     int data_size; // size of data to be read on this call, either size or 255
 
     if(size <= 255){
         WRITE_FIELD(I2Cx_CR2[1], I2Cx_CR2_NBYTES, size);
         data_size = size;
     }else{
         WRITE_FIELD(I2Cx_CR2[1], I2Cx_CR2_NBYTES, 255);
         WRITE_FIELD(I2Cx_CR2[1], I2Cx_CR2_RELOAD, 1);
         data_size = 255;
     }
 
     if(first_call){
         // set addr mode, default 7 bit, so do nothing
         WRITE_FIELD(I2Cx_CR2[1], I2Cx_CR2_SADD_7BIT, addr);
 
         WRITE_FIELD(I2Cx_CR2[1], I2Cx_CR2_RD_WRN, 1); // 1 for read 
         WRITE_FIELD(I2Cx_CR2[1], I2Cx_CR2_AUTOEND, 1);
         WRITE_FIELD(I2Cx_CR2[1], I2Cx_CR2_START, 1);
     }
 
     uint32_t timeout = 100000; // TODO: tune parameter to "work" in testing
 
     while(data_size > 0){
         uint32_t count = 0;
         while(READ_FIELD(I2Cx_ISR[1], I2Cx_ISR_RXNE) != 1 && 
         count++ < timeout); // wait until RXNE is set
         
         uint8_t d = READ_FIELD(I2Cx_RXDR[1], I2Cx_RXDR_RXDATA);
         data[i] = d;
 
         i++;
         data_size--; // recieved one byte
         size--; // keep track of size
     }
 
     
     return tal_read_r(addr, size, false, data, i); // call again, with updated (less) data to send
 }

 void* tal_read_I2C(uint8_t addr, uint32_t size)
 {
     uint8_t data_array[size]; // TODO: check
     return tal_read_r(addr, size, true, data_array, 0);
 }
 
 
 
 #if defined(__cplusplus)
   }
 #endif