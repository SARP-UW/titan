/**
 * This file is part of the Titan HAL
 * Copyright (c) 2025 UW SARP
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 * 
 * @internal
 * @file src/STM32H745_CM7/mmio.h
 * @authors Aaron McBride
 * @brief Memory-mapped I/O definitions and utilities.
 */

#pragma once
#include <stdint.h>
#include <stdbool.h>

#ifdef __cplusplus
  extern "C" {
#endif

  /************************************************************************************************
   * MMIO Type Definitions
   ************************************************************************************************/

  /** @brief Type of read-write register pointers. */
  typedef volatile uint64_t* rw_reg64_t;
  typedef volatile uint32_t* rw_reg32_t;
  typedef volatile uint16_t* rw_reg16_t;
  typedef volatile uint8_t*  rw_reg8_t;

  /** @brief Type of read-only register pointers. */
  typedef const volatile uint64_t* ro_reg64_t;
  typedef const volatile uint32_t* ro_reg32_t;
  typedef const volatile uint16_t* ro_reg16_t;
  typedef const volatile uint8_t*  ro_reg8_t;

  /** @brief Type of field definitions. */
  typedef struct { uint64_t msk; int32_t pos; } field64_t;
  typedef struct { uint32_t msk; int32_t pos; } field32_t;
  typedef struct { uint16_t msk; int32_t pos; } field16_t;
  typedef struct { uint8_t  msk; int32_t pos; } field8_t;

  /************************************************************************************************
   * MMIO Utilities
   ************************************************************************************************/

  /**
   * @brief Constructs a field struct from a position and width.
   * @param ftype (token) The type of the field to construct.
   * @param _pos (integral value) The position of the field.
   * @param width (integral value) The width of the field.
   * @returns (field_t) A field type which defines a field at the specified location.
   * @note - Arguments to this macro are expanded multiple times.
   */
  #define MAKE_FIELD(ftype, _pos, width) \
  ( \
    (ftype) { \
      .msk = ((UINT64_C(1) << (width)) - 1U) << (_pos), \
      .pos = (_pos) \
    } \
  )

  /**
   * @brief Determines if a value fits in the range of a field.
   * @param field (field_t) The target field.
   * @param value (integral value) The target value.
   * @returns (bool) True if @p [value] can be represented in @p [field], 
   *          or false otherwise.
   * @note - Arguments to this macro are expanded multiple times.
   */
  #define IN_RANGE_FIELD(field, value) \
  ( \
    ((uint64_t)(value) & ~((field).msk >> (field).pos)) == 0U \
  )

  /**
   * @brief Writes a value to a field.
   * @param dst (integral pointer) The location to write to.
   * @param field (field_t) The target field.
   * @param value (integral value) The value to write to the field.
   * @returns (unsigned integer) The value assigned to @p [dst].
   * @note - Arguments to this macro are expanded multiple times.
   */
  #define WRITE_FIELD(dst, field, value) \
  ( \
    *(dst) = (*(dst) & ~(field).msk) | \
    (((value) << (field).pos) & (field).msk) \
  )

  /**
   * @brief Writes a value to a write-only field.
   * @param dst (integral pointer) The location to write to.
   * @param field (field_t) The target field.
   * @param value (integral value) The value to write to the field.
   * @returns (unsigned integer) The value assigned to @p [dst].
   * @note - Arguments to this macro are expanded multiple times.
   */
  #define WRITE_WOFIELD(dst, field, value) \
  ( \
    *(dst) = (((value) << (field).pos) & (field).msk) \
  )

  /**
   * @brief Reads the value of a field
   * @param src (integral pointer) The location to read from.
   * @param field (field_t) The target field.
   * @returns (unsigned integer) The value of @p [field] in @p [src].
   * @note - Arguments to this macro are expanded multiple times.
   */
  #define READ_FIELD(src, field) \
  ( \
    (*(src) & (field).msk) >> (field).pos \
  )

  /************************************************************************************************
   * COMP1 Definitions
   ************************************************************************************************/

  /**** COMP1 Register Definitions ****/

  static const ro_reg32_t COMP1_SR   = (ro_reg32_t)0x58003800U;   /** @brief Comparator status register. */
  static const rw_reg32_t COMP1_ICFR = (rw_reg32_t)0x58003804U;   /** @brief Comparator interrupt clear flag register. */
  static const rw_reg32_t COMP1_OR   = (rw_reg32_t)0x58003808U;   /** @brief Comparator option register. */

  /**** Enumerated COMP1 Register Definitions ****/

  static const rw_reg32_t COMP1_CFGRx[3] = {
    [1] = (rw_reg32_t)0x5800380CU,   /** @brief Comparator configuration register 1. */
    [2] = (rw_reg32_t)0x58003810U,   /** @brief Comparator configuration register 2. */
  };

  /**** COMP1 Register Field Definitions ****/

  static const field32_t COMP1_OR_AFOP        = {.msk = 0x000007FFU, .pos = 0};    /** @brief Selection of source for alternate function of output ports. */
  static const field32_t COMP1_OR_OR          = {.msk = 0xFFFFF800U, .pos = 11};   /** @brief Option register. */
  static const field32_t COMP1_CFGRx_EN       = {.msk = 0x00000001U, .pos = 0};    /** @brief COMP channel 1 enable bit. */
  static const field32_t COMP1_CFGRx_BRGEN    = {.msk = 0x00000002U, .pos = 1};    /** @brief Scaler bridge enable. */
  static const field32_t COMP1_CFGRx_SCALEN   = {.msk = 0x00000004U, .pos = 2};    /** @brief Voltage scaler enable bit. */
  static const field32_t COMP1_CFGRx_POLARITY = {.msk = 0x00000008U, .pos = 3};    /** @brief COMP channel 1 polarity selection bit. */
  static const field32_t COMP1_CFGRx_ITEN     = {.msk = 0x00000040U, .pos = 6};    /** @brief COMP channel 1 interrupt enable. */
  static const field32_t COMP1_CFGRx_HYST     = {.msk = 0x00000300U, .pos = 8};    /** @brief COMP channel 1 hysteresis selection bits. */
  static const field32_t COMP1_CFGRx_PWRMODE  = {.msk = 0x00003000U, .pos = 12};   /** @brief Power mode of the COMP channel 1. */
  static const field32_t COMP1_CFGRx_INMSEL   = {.msk = 0x00070000U, .pos = 16};   /** @brief COMP channel 1 inverting input selection field. */
  static const field32_t COMP1_CFGRx_INPSEL   = {.msk = 0x00100000U, .pos = 20};   /** @brief COMP channel 1 non-inverting input selection bit. */
  static const field32_t COMP1_CFGRx_BLANKING = {.msk = 0x0F000000U, .pos = 24};   /** @brief COMP channel 1 blanking source selection bits. */
  static const field32_t COMP1_CFGRx_LOCK     = {.msk = 0x80000000U, .pos = 31};   /** @brief Lock bit. */

  /**** Enumerated COMP1 Register Field Definitions ****/

  static field32_t const COMP1_SR_CxVAL[3] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief COMP channel 1 output status bit. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief COMP channel 2 output status bit. */
  };

  static field32_t const COMP1_SR_CxIF[3] = {
    [1] = {.msk = 0x00010000U, .pos = 16},   /** @brief COMP channel 1 interrupt flag. */
    [2] = {.msk = 0x00020000U, .pos = 17},   /** @brief COMP channel 2 interrupt flag. */
  };

  static field32_t const COMP1_ICFR_CCxIF[3] = {
    [1] = {.msk = 0x00010000U, .pos = 16},   /** @brief Clear COMP channel 1 interrupt flag. */
    [2] = {.msk = 0x00020000U, .pos = 17},   /** @brief Clear COMP channel 2 interrupt flag. */
  };

  /************************************************************************************************
   * CRS Definitions
   ************************************************************************************************/

  /**** CRS Register Definitions ****/

  static const rw_reg32_t CRS_CR   = (rw_reg32_t)0x40008400U;   /** @brief CRS control register. */
  static const rw_reg32_t CRS_CFGR = (rw_reg32_t)0x40008404U;   /** @brief This register can be written only when the frequency error counter is disabled (CEN bit is cleared in CRS_CR). When the counter is enabled, this register is write-protected. */
  static const ro_reg32_t CRS_ISR  = (ro_reg32_t)0x40008408U;   /** @brief CRS interrupt and status register. */
  static const rw_reg32_t CRS_ICR  = (rw_reg32_t)0x4000840CU;   /** @brief CRS interrupt flag clear register. */

  /**** CRS Register Field Definitions ****/

  static const field32_t CRS_CR_SYNCOKIE   = {.msk = 0x00000001U, .pos = 0};    /** @brief SYNC event OK interrupt enable. */
  static const field32_t CRS_CR_SYNCWARNIE = {.msk = 0x00000002U, .pos = 1};    /** @brief SYNC warning interrupt enable. */
  static const field32_t CRS_CR_ERRIE      = {.msk = 0x00000004U, .pos = 2};    /** @brief Synchronization or trimming error interrupt enable. */
  static const field32_t CRS_CR_ESYNCIE    = {.msk = 0x00000008U, .pos = 3};    /** @brief Expected SYNC interrupt enable. */
  static const field32_t CRS_CR_CEN        = {.msk = 0x00000020U, .pos = 5};    /** @brief Frequency error counter enable this bit enables the oscillator clock for the frequency error counter. When this bit is set, the CRS_CFGR register is write-protected and cannot be modified. */
  static const field32_t CRS_CR_AUTOTRIMEN = {.msk = 0x00000040U, .pos = 6};    /** @brief Automatic trimming enable this bit enables the automatic hardware adjustment of TRIM bits according to the measured frequency error between two SYNC events. If this bit is set, the TRIM bits are read-only. The TRIM value can be adjusted by hardware by one or two steps at a time, depending on the measured frequency error value. Refer to section7.3.4: frequency error evaluation and automatic trimming for more details. */
  static const field32_t CRS_CR_SWSYNC     = {.msk = 0x00000080U, .pos = 7};    /** @brief Generate software SYNC event this bit is set by software in order to generate a software SYNC event. It is automatically cleared by hardware. */
  static const field32_t CRS_CR_TRIM       = {.msk = 0x00003F00U, .pos = 8};    /** @brief HSI48 oscillator smooth trimming these bits provide a user-programmable trimming value to the HSI48 oscillator. They can be programmed to adjust to variations in voltage and temperature that influence the frequency of the HSI48. The default value is 32, which corresponds to the middle of the trimming interval. The trimming step is around 67 khz between two consecutive TRIM steps. A higher TRIM value corresponds to a higher output frequency. When the AUTOTRIMEN bit is set, this field is controlled by hardware and is read-only. */
  static const field32_t CRS_CFGR_RELOAD   = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Counter reload value RELOAD is the value to be loaded in the frequency error counter with each SYNC event. Refer to section7.3.3: frequency error measurement for more details about counter behavior. */
  static const field32_t CRS_CFGR_FELIM    = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Frequency error limit FELIM contains the value to be used to evaluate the captured frequency error value latched in the FECAP[15:0] bits of the CRS_ISR register. Refer to section7.3.4: frequency error evaluation and automatic trimming for more details about FECAP evaluation. */
  static const field32_t CRS_CFGR_SYNCDIV  = {.msk = 0x07000000U, .pos = 24};   /** @brief SYNC divider these bits are set and cleared by software to control the division factor of the SYNC signal. */
  static const field32_t CRS_CFGR_SYNCSRC  = {.msk = 0x30000000U, .pos = 28};   /** @brief SYNC signal source selection these bits are set and cleared by software to select the SYNC signal source. Note: when using USB LPM (link power management) and the device is in sleep mode, the periodic USB SOF will not be generated by the host. No SYNC signal will therefore be provided to the CRS to calibrate the HSI48 on the run. To guarantee the required clock precision after waking up from sleep mode, the LSE or reference clock on the gpios should be used as SYNC signal. */
  static const field32_t CRS_CFGR_SYNCPOL  = {.msk = 0x80000000U, .pos = 31};   /** @brief SYNC polarity selection this bit is set and cleared by software to select the input polarity for the SYNC signal source. */
  static const field32_t CRS_ISR_SYNCOKF   = {.msk = 0x00000001U, .pos = 0};    /** @brief SYNC event OK flag this flag is set by hardware when the measured frequency error is smaller than FELIM * 3. This means that either no adjustment of the TRIM value is needed or that an adjustment by one trimming step is enough to compensate the frequency error. An interrupt is generated if the SYNCOKIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCOKC bit in the CRS_ICR register. */
  static const field32_t CRS_ISR_SYNCWARNF = {.msk = 0x00000002U, .pos = 1};    /** @brief SYNC warning flag this flag is set by hardware when the measured frequency error is greater than or equal to FELIM * 3, but smaller than FELIM * 128. This means that to compensate the frequency error, the TRIM value must be adjusted by two steps or more. An interrupt is generated if the SYNCWARNIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCWARNC bit in the CRS_ICR register. */
  static const field32_t CRS_ISR_ERRF      = {.msk = 0x00000004U, .pos = 2};    /** @brief Error flag this flag is set by hardware in case of any synchronization or trimming error. It is the logical OR of the TRIMOVF, SYNCMISS and SYNCERR bits. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software in reaction to setting the ERRC bit in the CRS_ICR register, which clears the TRIMOVF, SYNCMISS and SYNCERR bits. */
  static const field32_t CRS_ISR_ESYNCF    = {.msk = 0x00000008U, .pos = 3};    /** @brief Expected SYNC flag this flag is set by hardware when the frequency error counter reached a zero value. An interrupt is generated if the ESYNCIE bit is set in the CRS_CR register. It is cleared by software by setting the ESYNCC bit in the CRS_ICR register. */
  static const field32_t CRS_ISR_SYNCERR   = {.msk = 0x00000100U, .pos = 8};    /** @brief SYNC error this flag is set by hardware when the SYNC pulse arrives before the ESYNC event and the measured frequency error is greater than or equal to FELIM * 128. This means that the frequency error is too big (internal frequency too low) to be compensated by adjusting the TRIM value, and that some other action should be taken. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register. */
  static const field32_t CRS_ISR_SYNCMISS  = {.msk = 0x00000200U, .pos = 9};    /** @brief SYNC missed this flag is set by hardware when the frequency error counter reached value FELIM * 128 and no SYNC was detected, meaning either that a SYNC pulse was missed or that the frequency error is too big (internal frequency too high) to be compensated by adjusting the TRIM value, and that some other action should be taken. At this point, the frequency error counter is stopped (waiting for a next SYNC) and an interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register. */
  static const field32_t CRS_ISR_TRIMOVF   = {.msk = 0x00000400U, .pos = 10};   /** @brief Trimming overflow or underflow this flag is set by hardware when the automatic trimming tries to over- or under-flow the TRIM value. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register. */
  static const field32_t CRS_ISR_FEDIR     = {.msk = 0x00008000U, .pos = 15};   /** @brief Frequency error direction FEDIR is the counting direction of the frequency error counter latched in the time of the last SYNC event. It shows whether the actual frequency is below or above the target. */
  static const field32_t CRS_ISR_FECAP     = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief Frequency error capture FECAP is the frequency error counter value latched in the time of the last SYNC event. Refer to section7.3.4: frequency error evaluation and automatic trimming for more details about FECAP usage. */
  static const field32_t CRS_ICR_SYNCOKC   = {.msk = 0x00000001U, .pos = 0};    /** @brief SYNC event OK clear flag writing 1 to this bit clears the SYNCOKF flag in the CRS_ISR register. */
  static const field32_t CRS_ICR_SYNCWARNC = {.msk = 0x00000002U, .pos = 1};    /** @brief SYNC warning clear flag writing 1 to this bit clears the SYNCWARNF flag in the CRS_ISR register. */
  static const field32_t CRS_ICR_ERRC      = {.msk = 0x00000004U, .pos = 2};    /** @brief Error clear flag writing 1 to this bit clears TRIMOVF, SYNCMISS and SYNCERR bits and consequently also the ERRF flag in the CRS_ISR register. */
  static const field32_t CRS_ICR_ESYNCC    = {.msk = 0x00000008U, .pos = 3};    /** @brief Expected SYNC clear flag writing 1 to this bit clears the ESYNCF flag in the CRS_ISR register. */

  /************************************************************************************************
   * DAC Definitions
   ************************************************************************************************/

  /**** DAC Register Definitions ****/

  static const rw_reg32_t DAC_CR      = (rw_reg32_t)0x40007400U;   /** @brief DAC control register. */
  static const rw_reg32_t DAC_SWTRGR  = (rw_reg32_t)0x40007404U;   /** @brief DAC software trigger register. */
  static const rw_reg32_t DAC_DHR8R2  = (rw_reg32_t)0x4000741CU;   /** @brief DAC channel2 8-bit right-aligned data holding register. */
  static const rw_reg32_t DAC_DHR12LD = (rw_reg32_t)0x40007424U;   /** @brief DUAL DAC 12-bit left aligned data holding register. */
  static const rw_reg32_t DAC_SR      = (rw_reg32_t)0x40007434U;   /** @brief DAC status register. */
  static const rw_reg32_t DAC_CCR     = (rw_reg32_t)0x40007438U;   /** @brief DAC calibration control register. */
  static const rw_reg32_t DAC_MCR     = (rw_reg32_t)0x4000743CU;   /** @brief DAC mode control register. */
  static const rw_reg32_t DAC_SHHR    = (rw_reg32_t)0x40007448U;   /** @brief DAC sample and hold hold time register. */
  static const rw_reg32_t DAC_SHRR    = (rw_reg32_t)0x4000744CU;   /** @brief DAC sample and hold refresh time register. */

  /**** Enumerated DAC Register Definitions ****/

  static const rw_reg32_t DAC_DHR12Rx[3] = {
    [1] = (rw_reg32_t)0x40007408U,   /** @brief DAC channel1 12-bit right-aligned data holding register. */
    [2] = (rw_reg32_t)0x40007414U,   /** @brief DAC channel2 12-bit right aligned data holding register. */
  };

  static const rw_reg32_t DAC_DHR12Lx[3] = {
    [1] = (rw_reg32_t)0x4000740CU,   /** @brief DAC channel1 12-bit left aligned data holding register. */
    [2] = (rw_reg32_t)0x40007418U,   /** @brief DAC channel2 12-bit left aligned data holding register. */
  };

  static const rw_reg32_t DAC_DHRxR1[13] = {
    [8]  = (rw_reg32_t)0x40007410U,   /** @brief DAC channel1 8-bit right aligned data holding register. */
  };

  static const rw_reg32_t DAC_DHRxRD[13] = {
    [8]  = (rw_reg32_t)0x40007428U,   /** @brief DUAL DAC 8-bit right aligned data holding register. */
    [12] = (rw_reg32_t)0x40007420U,   /** @brief Dual DAC 12-bit right-aligned data holding register. */
  };

  static const ro_reg32_t DAC_DORx[3] = {
    [1] = (ro_reg32_t)0x4000742CU,   /** @brief DAC channel1 data output register. */
    [2] = (ro_reg32_t)0x40007430U,   /** @brief DAC channel2 data output register. */
  };

  static const rw_reg32_t DAC_SHSRx[3] = {
    [1] = (rw_reg32_t)0x40007440U,   /** @brief DAC sample and hold sample time register 1. */
    [2] = (rw_reg32_t)0x40007444U,   /** @brief DAC sample and hold sample time register 2. */
  };

  /**** DAC Register Field Definitions ****/

  static const field32_t DAC_DHR12Rx_DACC1DHR = {.msk = 0x00000FFFU, .pos = 0};   /** @brief DAC channel1 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
  static const field32_t DAC_DHR12Lx_DACC1DHR = {.msk = 0x0000FFF0U, .pos = 4};   /** @brief DAC channel1 12-bit left-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
  static const field32_t DAC_DHRxR1_DACC1DHR  = {.msk = 0x000000FFU, .pos = 0};   /** @brief DAC channel1 8-bit right-aligned data these bits are written by software which specifies 8-bit data for DAC channel1. */
  static const field32_t DAC_DHR8R2_DACC2DHR  = {.msk = 0x000000FFU, .pos = 0};   /** @brief DAC channel2 8-bit right-aligned data these bits are written by software which specifies 8-bit data for DAC channel2. */
  static const field32_t DAC_DORx_DACC1DOR    = {.msk = 0x00000FFFU, .pos = 0};   /** @brief DAC channel1 data output these bits are read-only, they contain data output for DAC channel1. */
  static const field32_t DAC_SHSRx_TSAMPLE1   = {.msk = 0x000003FFU, .pos = 0};   /** @brief DAC channel 1 sample time (only valid in sample &amp; hold mode) these bits can be written when the DAC channel1 is disabled or also during normal operation. In the latter case, the write can be done only when bwstx of DAC_SR register is low, if bwstx=1, the write operation is ignored. */

  /**** Enumerated DAC Register Field Definitions ****/

  static field32_t const DAC_CR_ENx[3] = {
    [1] = {.msk = 0x00000001U, .pos = 0},    /** @brief DAC channel1 enable this bit is set and cleared by software to enable/disable DAC channel1. */
    [2] = {.msk = 0x00010000U, .pos = 16},   /** @brief DAC channel2 enable this bit is set and cleared by software to enable/disable DAC channel2. */
  };

  static field32_t const DAC_CR_TENx[3] = {
    [1] = {.msk = 0x00000002U, .pos = 1},    /** @brief DAC channel1 trigger enable. */
    [2] = {.msk = 0x00020000U, .pos = 17},   /** @brief DAC channel2 trigger enable. */
  };

  static field32_t const DAC_CR_TSELx[3] = {
    [1] = {.msk = 0x0000001CU, .pos = 2},    /** @brief DAC channel1 trigger selection these bits select the external event used to trigger DAC channel1. Note: only used if bit TEN1 = 1 (DAC channel1 trigger enabled). */
    [2] = {.msk = 0x001C0000U, .pos = 18},   /** @brief DAC channel2 trigger selection these bits select the external event used to trigger DAC channel2 note: only used if bit TEN2 = 1 (DAC channel2 trigger enabled). */
  };

  static field32_t const DAC_CR_WAVEx[3] = {
    [1] = {.msk = 0x000000C0U, .pos = 6},    /** @brief DAC channel1 noise/triangle wave generation enable these bits are set and cleared by software. Note: only used if bit TEN1 = 1 (DAC channel1 trigger enabled). */
    [2] = {.msk = 0x00C00000U, .pos = 22},   /** @brief DAC channel2 noise/triangle wave generation enable these bits are set/reset by software. 1x: triangle wave generation enabled note: only used if bit TEN2 = 1 (DAC channel2 trigger enabled). */
  };

  static field32_t const DAC_CR_MAMPx[3] = {
    [1] = {.msk = 0x00000F00U, .pos = 8},    /** @brief DAC channel1 mask/amplitude selector these bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095. */
    [2] = {.msk = 0x0F000000U, .pos = 24},   /** @brief DAC channel2 mask/amplitude selector these bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095. */
  };

  static field32_t const DAC_CR_DMAENx[3] = {
    [1] = {.msk = 0x00001000U, .pos = 12},   /** @brief DAC channel1 DMA enable this bit is set and cleared by software. */
    [2] = {.msk = 0x10000000U, .pos = 28},   /** @brief DAC channel2 DMA enable this bit is set and cleared by software. */
  };

  static field32_t const DAC_CR_DMAUDRIEx[3] = {
    [1] = {.msk = 0x00002000U, .pos = 13},   /** @brief DAC channel1 DMA underrun interrupt enable this bit is set and cleared by software. */
    [2] = {.msk = 0x20000000U, .pos = 29},   /** @brief DAC channel2 DMA underrun interrupt enable this bit is set and cleared by software. */
  };

  static field32_t const DAC_CR_CENx[3] = {
    [1] = {.msk = 0x00004000U, .pos = 14},   /** @brief DAC channel 1 calibration enable this bit is set and cleared by software to enable/disable DAC channel 1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) otherwise, the write operation is ignored. */
    [2] = {.msk = 0x40000000U, .pos = 30},   /** @brief DAC channel 2 calibration enable this bit is set and cleared by software to enable/disable DAC channel 2 calibration, it can be written only if bit EN2=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) otherwise, the write operation is ignored. */
  };

  static field32_t const DAC_SWTRGR_SWTRIGx[3] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief DAC channel1 software trigger this bit is set by software to trigger the DAC in software trigger mode. Note: this bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief DAC channel2 software trigger this bit is set by software to trigger the DAC in software trigger mode. Note: this bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register. */
  };

  static field32_t const DAC_DHRxRD_DACCxDHR[3] = {
    [1] = {.msk = 0x00000FFFU, .pos = 0},    /** @brief DAC channel1 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
    [2] = {.msk = 0x0FFF0000U, .pos = 16},   /** @brief DAC channel2 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel2. */
  };

  static field32_t const DAC_SR_DMAUDRx[3] = {
    [1] = {.msk = 0x00002000U, .pos = 13},   /** @brief DAC channel1 DMA underrun flag this bit is set by hardware and cleared by software (by writing it to 1). */
    [2] = {.msk = 0x20000000U, .pos = 29},   /** @brief DAC channel2 DMA underrun flag this bit is set by hardware and cleared by software (by writing it to 1). */
  };

  static field32_t const DAC_SR_CAL_FLAGx[3] = {
    [1] = {.msk = 0x00004000U, .pos = 14},   /** @brief DAC channel 1 calibration offset status this bit is set and cleared by hardware. */
    [2] = {.msk = 0x40000000U, .pos = 30},   /** @brief DAC channel 2 calibration offset status this bit is set and cleared by hardware. */
  };

  static field32_t const DAC_SR_BWSTx[3] = {
    [1] = {.msk = 0x00008000U, .pos = 15},   /** @brief DAC channel 1 busy writing sample time flag this bit is systematically set just after sample & hold mode enable and is set each time the software writes the register DAC_SHSR1, it is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3LSI periods of synchronization). */
    [2] = {.msk = 0x80000000U, .pos = 31},   /** @brief DAC channel 2 busy writing sample time flag this bit is systematically set just after sample & hold mode enable and is set each time the software writes the register DAC_SHSR2, it is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization). */
  };

  static field32_t const DAC_CCR_OTRIMx[3] = {
    [1] = {.msk = 0x0000001FU, .pos = 0},    /** @brief DAC channel 1 offset trimming value. */
    [2] = {.msk = 0x001F0000U, .pos = 16},   /** @brief DAC channel 2 offset trimming value. */
  };

  static field32_t const DAC_MCR_MODEx[3] = {
    [1] = {.msk = 0x00000007U, .pos = 0},    /** @brief DAC channel 1 mode these bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored. They can be set and cleared by software to select the DAC channel 1 mode: DAC channel 1 in normal mode DAC channel 1 in sample &amp; hold mode. */
    [2] = {.msk = 0x00070000U, .pos = 16},   /** @brief DAC channel 2 mode these bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored. They can be set and cleared by software to select the DAC channel 2 mode: DAC channel 2 in normal mode DAC channel 2 in sample &amp; hold mode. */
  };

  static field32_t const DAC_SHHR_THOLDx[3] = {
    [1] = {.msk = 0x000003FFU, .pos = 0},    /** @brief DAC channel 1 hold time (only valid in sample &amp; hold mode) hold time= (THOLD[9:0]) x T LSI. */
    [2] = {.msk = 0x03FF0000U, .pos = 16},   /** @brief DAC channel 2 hold time (only valid in sample &amp; hold mode). Hold time= (THOLD[9:0]) x T LSI. */
  };

  static field32_t const DAC_SHRR_TREFRESHx[3] = {
    [1] = {.msk = 0x000000FFU, .pos = 0},    /** @brief DAC channel 1 refresh time (only valid in sample &amp; hold mode) refresh time= (TREFRESH[7:0]) x T LSI. */
    [2] = {.msk = 0x00FF0000U, .pos = 16},   /** @brief DAC channel 2 refresh time (only valid in sample &amp; hold mode) refresh time= (TREFRESH[7:0]) x T LSI. */
  };

  /************************************************************************************************
   * BDMA Definitions
   ************************************************************************************************/

  /**** BDMA Register Definitions ****/

  static const ro_reg32_t BDMA_ISR  = (ro_reg32_t)0x58025400U;   /** @brief DMA interrupt status register. */
  static const rw_reg32_t BDMA_IFCR = (rw_reg32_t)0x58025404U;   /** @brief DMA interrupt flag clear register. */

  /**** Enumerated BDMA Register Definitions ****/

  static const rw_reg32_t BDMA_CCRx[9] = {
    [1] = (rw_reg32_t)0x58025408U,   /** @brief DMA channel x configuration register. */
    [2] = (rw_reg32_t)0x5802541CU,   /** @brief DMA channel x configuration register. */
    [3] = (rw_reg32_t)0x58025430U,   /** @brief DMA channel x configuration register. */
    [4] = (rw_reg32_t)0x58025444U,   /** @brief DMA channel x configuration register. */
    [5] = (rw_reg32_t)0x58025458U,   /** @brief DMA channel x configuration register. */
    [6] = (rw_reg32_t)0x5802546CU,   /** @brief DMA channel x configuration register. */
    [7] = (rw_reg32_t)0x58025480U,   /** @brief DMA channel x configuration register. */
    [8] = (rw_reg32_t)0x58025494U,   /** @brief DMA channel x configuration register. */
  };

  static const rw_reg32_t BDMA_CNDTRx[9] = {
    [1] = (rw_reg32_t)0x5802540CU,   /** @brief DMA channel x number of data register. */
    [2] = (rw_reg32_t)0x58025420U,   /** @brief DMA channel x number of data register. */
    [3] = (rw_reg32_t)0x58025434U,   /** @brief DMA channel x number of data register. */
    [4] = (rw_reg32_t)0x58025448U,   /** @brief DMA channel x number of data register. */
    [5] = (rw_reg32_t)0x5802545CU,   /** @brief DMA channel x number of data register. */
    [6] = (rw_reg32_t)0x58025470U,   /** @brief DMA channel x number of data register. */
    [7] = (rw_reg32_t)0x58025484U,   /** @brief DMA channel x number of data register. */
    [8] = (rw_reg32_t)0x58025498U,   /** @brief DMA channel x number of data register. */
  };

  static const rw_reg32_t BDMA_CPARx[9] = {
    [1] = (rw_reg32_t)0x58025410U,   /** @brief This register must not be written when the channel is enabled. */
    [2] = (rw_reg32_t)0x58025424U,   /** @brief This register must not be written when the channel is enabled. */
    [3] = (rw_reg32_t)0x58025438U,   /** @brief This register must not be written when the channel is enabled. */
    [4] = (rw_reg32_t)0x5802544CU,   /** @brief This register must not be written when the channel is enabled. */
    [5] = (rw_reg32_t)0x58025460U,   /** @brief This register must not be written when the channel is enabled. */
    [6] = (rw_reg32_t)0x58025474U,   /** @brief This register must not be written when the channel is enabled. */
    [7] = (rw_reg32_t)0x58025488U,   /** @brief This register must not be written when the channel is enabled. */
    [8] = (rw_reg32_t)0x5802549CU,   /** @brief This register must not be written when the channel is enabled. */
  };

  static const rw_reg32_t BDMA_CMARx[9] = {
    [1] = (rw_reg32_t)0x58025414U,   /** @brief This register must not be written when the channel is enabled. */
    [2] = (rw_reg32_t)0x58025428U,   /** @brief This register must not be written when the channel is enabled. */
    [3] = (rw_reg32_t)0x5802543CU,   /** @brief This register must not be written when the channel is enabled. */
    [4] = (rw_reg32_t)0x58025450U,   /** @brief This register must not be written when the channel is enabled. */
    [5] = (rw_reg32_t)0x58025464U,   /** @brief This register must not be written when the channel is enabled. */
    [6] = (rw_reg32_t)0x58025478U,   /** @brief This register must not be written when the channel is enabled. */
    [7] = (rw_reg32_t)0x5802548CU,   /** @brief This register must not be written when the channel is enabled. */
    [8] = (rw_reg32_t)0x580254A0U,   /** @brief This register must not be written when the channel is enabled. */
  };

  /**** BDMA Register Field Definitions ****/

  static const field32_t BDMA_CCRx_EN      = {.msk = 0x00000001U, .pos = 0};    /** @brief Channel enable this bit is set and cleared by software. */
  static const field32_t BDMA_CCRx_TCIE    = {.msk = 0x00000002U, .pos = 1};    /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
  static const field32_t BDMA_CCRx_HTIE    = {.msk = 0x00000004U, .pos = 2};    /** @brief Half transfer interrupt enable this bit is set and cleared by software. */
  static const field32_t BDMA_CCRx_TEIE    = {.msk = 0x00000008U, .pos = 3};    /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
  static const field32_t BDMA_CCRx_DIR     = {.msk = 0x00000010U, .pos = 4};    /** @brief Data transfer direction this bit is set and cleared by software. */
  static const field32_t BDMA_CCRx_CIRC    = {.msk = 0x00000020U, .pos = 5};    /** @brief Circular mode this bit is set and cleared by software. */
  static const field32_t BDMA_CCRx_PINC    = {.msk = 0x00000040U, .pos = 6};    /** @brief Peripheral increment mode this bit is set and cleared by software. */
  static const field32_t BDMA_CCRx_MINC    = {.msk = 0x00000080U, .pos = 7};    /** @brief Memory increment mode this bit is set and cleared by software. */
  static const field32_t BDMA_CCRx_PSIZE   = {.msk = 0x00000300U, .pos = 8};    /** @brief Peripheral size these bits are set and cleared by software. */
  static const field32_t BDMA_CCRx_MSIZE   = {.msk = 0x00000C00U, .pos = 10};   /** @brief Memory size these bits are set and cleared by software. */
  static const field32_t BDMA_CCRx_PL      = {.msk = 0x00003000U, .pos = 12};   /** @brief Channel priority level these bits are set and cleared by software. */
  static const field32_t BDMA_CCRx_MEM2MEM = {.msk = 0x00004000U, .pos = 14};   /** @brief Memory to memory mode this bit is set and cleared by software. */
  static const field32_t BDMA_CNDTRx_NDT   = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */

  /**** Enumerated BDMA Register Field Definitions ****/

  static field32_t const BDMA_ISR_GIFx[9] = {
    [1] = {.msk = 0x00000001U, .pos = 0},    /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [2] = {.msk = 0x00000010U, .pos = 4},    /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [3] = {.msk = 0x00000100U, .pos = 8},    /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [4] = {.msk = 0x00001000U, .pos = 12},   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [5] = {.msk = 0x00010000U, .pos = 16},   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [6] = {.msk = 0x00100000U, .pos = 20},   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [7] = {.msk = 0x01000000U, .pos = 24},   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [8] = {.msk = 0x10000000U, .pos = 28},   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
  };

  static field32_t const BDMA_ISR_TCIFx[9] = {
    [1] = {.msk = 0x00000002U, .pos = 1},    /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [2] = {.msk = 0x00000020U, .pos = 5},    /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [3] = {.msk = 0x00000200U, .pos = 9},    /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [4] = {.msk = 0x00002000U, .pos = 13},   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [5] = {.msk = 0x00020000U, .pos = 17},   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [6] = {.msk = 0x00200000U, .pos = 21},   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [7] = {.msk = 0x02000000U, .pos = 25},   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [8] = {.msk = 0x20000000U, .pos = 29},   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
  };

  static field32_t const BDMA_ISR_HTIFx[9] = {
    [1] = {.msk = 0x00000004U, .pos = 2},    /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [2] = {.msk = 0x00000040U, .pos = 6},    /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [3] = {.msk = 0x00000400U, .pos = 10},   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [4] = {.msk = 0x00004000U, .pos = 14},   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [5] = {.msk = 0x00040000U, .pos = 18},   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [6] = {.msk = 0x00400000U, .pos = 22},   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [7] = {.msk = 0x04000000U, .pos = 26},   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [8] = {.msk = 0x40000000U, .pos = 30},   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
  };

  static field32_t const BDMA_ISR_TEIFx[9] = {
    [1] = {.msk = 0x00000008U, .pos = 3},    /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [2] = {.msk = 0x00000080U, .pos = 7},    /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [3] = {.msk = 0x00000800U, .pos = 11},   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [4] = {.msk = 0x00008000U, .pos = 15},   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [5] = {.msk = 0x00080000U, .pos = 19},   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [6] = {.msk = 0x00800000U, .pos = 23},   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [7] = {.msk = 0x08000000U, .pos = 27},   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [8] = {.msk = 0x80000000U, .pos = 31},   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
  };

  static field32_t const BDMA_IFCR_CGIFx[9] = {
    [1] = {.msk = 0x00000001U, .pos = 0},    /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
    [2] = {.msk = 0x00000010U, .pos = 4},    /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
    [3] = {.msk = 0x00000100U, .pos = 8},    /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
    [4] = {.msk = 0x00001000U, .pos = 12},   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
    [5] = {.msk = 0x00010000U, .pos = 16},   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
    [6] = {.msk = 0x00100000U, .pos = 20},   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
    [7] = {.msk = 0x01000000U, .pos = 24},   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
    [8] = {.msk = 0x10000000U, .pos = 28},   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
  };

  static field32_t const BDMA_IFCR_CTCIFx[9] = {
    [1] = {.msk = 0x00000002U, .pos = 1},    /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
    [2] = {.msk = 0x00000020U, .pos = 5},    /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
    [3] = {.msk = 0x00000200U, .pos = 9},    /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
    [4] = {.msk = 0x00002000U, .pos = 13},   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
    [5] = {.msk = 0x00020000U, .pos = 17},   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
    [6] = {.msk = 0x00200000U, .pos = 21},   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
    [7] = {.msk = 0x02000000U, .pos = 25},   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
    [8] = {.msk = 0x20000000U, .pos = 29},   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
  };

  static field32_t const BDMA_IFCR_CHTIFx[9] = {
    [1] = {.msk = 0x00000004U, .pos = 2},    /** @brief Channel x half transfer clear this bit is set and cleared by software. */
    [2] = {.msk = 0x00000040U, .pos = 6},    /** @brief Channel x half transfer clear this bit is set and cleared by software. */
    [3] = {.msk = 0x00000400U, .pos = 10},   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
    [4] = {.msk = 0x00004000U, .pos = 14},   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
    [5] = {.msk = 0x00040000U, .pos = 18},   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
    [6] = {.msk = 0x00400000U, .pos = 22},   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
    [7] = {.msk = 0x04000000U, .pos = 26},   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
    [8] = {.msk = 0x40000000U, .pos = 30},   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
  };

  static field32_t const BDMA_IFCR_CTEIFx[9] = {
    [1] = {.msk = 0x00000008U, .pos = 3},    /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    [2] = {.msk = 0x00000080U, .pos = 7},    /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    [3] = {.msk = 0x00000800U, .pos = 11},   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    [4] = {.msk = 0x00008000U, .pos = 15},   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    [5] = {.msk = 0x00080000U, .pos = 19},   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    [6] = {.msk = 0x00800000U, .pos = 23},   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    [7] = {.msk = 0x08000000U, .pos = 27},   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    [8] = {.msk = 0x80000000U, .pos = 31},   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
  };

  /************************************************************************************************
   * DMA2D Definitions
   ************************************************************************************************/

  /**** DMA2D Register Definitions ****/

  static const rw_reg32_t DMA2D_CR      = (rw_reg32_t)0x52001000U;   /** @brief DMA2D control register. */
  static const ro_reg32_t DMA2D_ISR     = (ro_reg32_t)0x52001004U;   /** @brief DMA2D interrupt status register. */
  static const rw_reg32_t DMA2D_IFCR    = (rw_reg32_t)0x52001008U;   /** @brief DMA2D interrupt flag clear register. */
  static const rw_reg32_t DMA2D_FGMAR   = (rw_reg32_t)0x5200100CU;   /** @brief DMA2D foreground memory address register. */
  static const rw_reg32_t DMA2D_FGOR    = (rw_reg32_t)0x52001010U;   /** @brief DMA2D foreground offset register. */
  static const rw_reg32_t DMA2D_BGMAR   = (rw_reg32_t)0x52001014U;   /** @brief DMA2D background memory address register. */
  static const rw_reg32_t DMA2D_BGOR    = (rw_reg32_t)0x52001018U;   /** @brief DMA2D background offset register. */
  static const rw_reg32_t DMA2D_FGPFCCR = (rw_reg32_t)0x5200101CU;   /** @brief DMA2D foreground PFC control register. */
  static const rw_reg32_t DMA2D_FGCOLR  = (rw_reg32_t)0x52001020U;   /** @brief DMA2D foreground color register. */
  static const rw_reg32_t DMA2D_BGPFCCR = (rw_reg32_t)0x52001024U;   /** @brief DMA2D background PFC control register. */
  static const rw_reg32_t DMA2D_BGCOLR  = (rw_reg32_t)0x52001028U;   /** @brief DMA2D background color register. */
  static const rw_reg32_t DMA2D_FGCMAR  = (rw_reg32_t)0x5200102CU;   /** @brief DMA2D foreground CLUT memory address register. */
  static const rw_reg32_t DMA2D_BGCMAR  = (rw_reg32_t)0x52001030U;   /** @brief DMA2D background CLUT memory address register. */
  static const rw_reg32_t DMA2D_OPFCCR  = (rw_reg32_t)0x52001034U;   /** @brief DMA2D output PFC control register. */
  static const rw_reg32_t DMA2D_OCOLR   = (rw_reg32_t)0x52001038U;   /** @brief DMA2D output color register. */
  static const rw_reg32_t DMA2D_OMAR    = (rw_reg32_t)0x5200103CU;   /** @brief DMA2D output memory address register. */
  static const rw_reg32_t DMA2D_OOR     = (rw_reg32_t)0x52001040U;   /** @brief DMA2D output offset register. */
  static const rw_reg32_t DMA2D_NLR     = (rw_reg32_t)0x52001044U;   /** @brief DMA2D number of line register. */
  static const rw_reg32_t DMA2D_LWR     = (rw_reg32_t)0x52001048U;   /** @brief DMA2D line watermark register. */
  static const rw_reg32_t DMA2D_AMTCR   = (rw_reg32_t)0x5200104CU;   /** @brief DMA2D AXI master timer configuration register. */

  /**** DMA2D Register Field Definitions ****/

  static const field32_t DMA2D_CR_START      = {.msk = 0x00000001U, .pos = 0};    /** @brief Start this bit can be used to launch the DMA2D according to the parameters loaded in the various configuration registers. */
  static const field32_t DMA2D_CR_SUSP       = {.msk = 0x00000002U, .pos = 1};    /** @brief Suspend this bit can be used to suspend the current transfer. This bit is set and reset by software. It is automatically reset by hardware when the START bit is reset. */
  static const field32_t DMA2D_CR_ABORT      = {.msk = 0x00000004U, .pos = 2};    /** @brief Abort this bit can be used to abort the current transfer. This bit is set by software and is automatically reset by hardware when the START bit is reset. */
  static const field32_t DMA2D_CR_TEIE       = {.msk = 0x00000100U, .pos = 8};    /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
  static const field32_t DMA2D_CR_TCIE       = {.msk = 0x00000200U, .pos = 9};    /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
  static const field32_t DMA2D_CR_TWIE       = {.msk = 0x00000400U, .pos = 10};   /** @brief Transfer watermark interrupt enable this bit is set and cleared by software. */
  static const field32_t DMA2D_CR_CAEIE      = {.msk = 0x00000800U, .pos = 11};   /** @brief CLUT access error interrupt enable this bit is set and cleared by software. */
  static const field32_t DMA2D_CR_CTCIE      = {.msk = 0x00001000U, .pos = 12};   /** @brief CLUT transfer complete interrupt enable this bit is set and cleared by software. */
  static const field32_t DMA2D_CR_CEIE       = {.msk = 0x00002000U, .pos = 13};   /** @brief Configuration error interrupt enable this bit is set and cleared by software. */
  static const field32_t DMA2D_CR_MODE       = {.msk = 0x00030000U, .pos = 16};   /** @brief DMA2D mode this bit is set and cleared by software. It cannot be modified while a transfer is ongoing. */
  static const field32_t DMA2D_ISR_TEIF      = {.msk = 0x00000001U, .pos = 0};    /** @brief Transfer error interrupt flag this bit is set when an error occurs during a DMA transfer (data transfer or automatic CLUT loading). */
  static const field32_t DMA2D_ISR_TCIF      = {.msk = 0x00000002U, .pos = 1};    /** @brief Transfer complete interrupt flag this bit is set when a DMA2D transfer operation is complete (data transfer only). */
  static const field32_t DMA2D_ISR_TWIF      = {.msk = 0x00000004U, .pos = 2};    /** @brief Transfer watermark interrupt flag this bit is set when the last pixel of the watermarked line has been transferred. */
  static const field32_t DMA2D_ISR_CAEIF     = {.msk = 0x00000008U, .pos = 3};    /** @brief CLUT access error interrupt flag this bit is set when the CPU accesses the CLUT while the CLUT is being automatically copied from a system memory to the internal DMA2D. */
  static const field32_t DMA2D_ISR_CTCIF     = {.msk = 0x00000010U, .pos = 4};    /** @brief CLUT transfer complete interrupt flag this bit is set when the CLUT copy from a system memory area to the internal DMA2D memory is complete. */
  static const field32_t DMA2D_ISR_CEIF      = {.msk = 0x00000020U, .pos = 5};    /** @brief Configuration error interrupt flag this bit is set when the START bit of DMA2D_CR, DMA2DFGPFCCR or DMA2D_BGPFCCR is set and a wrong configuration has been programmed. */
  static const field32_t DMA2D_IFCR_CTEIF    = {.msk = 0x00000001U, .pos = 0};    /** @brief Clear transfer error interrupt flag programming this bit to 1 clears the TEIF flag in the DMA2D_ISR register. */
  static const field32_t DMA2D_IFCR_CTCIF    = {.msk = 0x00000002U, .pos = 1};    /** @brief Clear transfer complete interrupt flag programming this bit to 1 clears the TCIF flag in the DMA2D_ISR register. */
  static const field32_t DMA2D_IFCR_CTWIF    = {.msk = 0x00000004U, .pos = 2};    /** @brief Clear transfer watermark interrupt flag programming this bit to 1 clears the TWIF flag in the DMA2D_ISR register. */
  static const field32_t DMA2D_IFCR_CAECIF   = {.msk = 0x00000008U, .pos = 3};    /** @brief Clear CLUT access error interrupt flag programming this bit to 1 clears the CAEIF flag in the DMA2D_ISR register. */
  static const field32_t DMA2D_IFCR_CCTCIF   = {.msk = 0x00000010U, .pos = 4};    /** @brief Clear CLUT transfer complete interrupt flag programming this bit to 1 clears the CTCIF flag in the DMA2D_ISR register. */
  static const field32_t DMA2D_IFCR_CCEIF    = {.msk = 0x00000020U, .pos = 5};    /** @brief Clear configuration error interrupt flag programming this bit to 1 clears the CEIF flag in the DMA2D_ISR register. */
  static const field32_t DMA2D_FGOR_LO       = {.msk = 0x00003FFFU, .pos = 0};    /** @brief Line offset line offset used for the foreground expressed in pixel. This value is used to generate the address. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once a data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even. */
  static const field32_t DMA2D_BGOR_LO       = {.msk = 0x00003FFFU, .pos = 0};    /** @brief Line offset line offset used for the background image (expressed in pixel). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even. */
  static const field32_t DMA2D_FGPFCCR_CM    = {.msk = 0x0000000FU, .pos = 0};    /** @brief Color mode these bits defines the color format of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless. */
  static const field32_t DMA2D_FGPFCCR_CCM   = {.msk = 0x00000010U, .pos = 4};    /** @brief CLUT color mode this bit defines the color format of the CLUT. It can only be written when the transfer is disabled. Once the CLUT transfer has started, this bit is read-only. */
  static const field32_t DMA2D_FGPFCCR_START = {.msk = 0x00000020U, .pos = 5};    /** @brief Start this bit can be set to start the automatic loading of the CLUT. It is automatically reset: ** at the end of the transfer ** when the transfer is aborted by the user application by setting the ABORT bit in DMA2D_CR ** when a transfer error occurs ** when the transfer has not started due to a configuration error or another transfer operation already ongoing (data transfer or automatic background CLUT transfer). */
  static const field32_t DMA2D_FGPFCCR_CS    = {.msk = 0x0000FF00U, .pos = 8};    /** @brief CLUT size these bits define the size of the CLUT used for the foreground image. Once the CLUT transfer has started, this field is read-only. The number of CLUT entries is equal to CS[7:0] + 1. */
  static const field32_t DMA2D_FGPFCCR_AM    = {.msk = 0x00030000U, .pos = 16};   /** @brief Alpha mode these bits select the alpha channel value to be used for the foreground image. They can only be written data the transfer are disabled. Once the transfer has started, they become read-only. Other configurations are meaningless. */
  static const field32_t DMA2D_FGPFCCR_CSS   = {.msk = 0x000C0000U, .pos = 18};   /** @brief Chroma sub-sampling these bits define the chroma sub-sampling mode for ycbcr color mode. Once the transfer has started, these bits are read-only. Others: meaningless. */
  static const field32_t DMA2D_FGPFCCR_AI    = {.msk = 0x00100000U, .pos = 20};   /** @brief Alpha inverted this bit inverts the alpha value. Once the transfer has started, this bit is read-only. */
  static const field32_t DMA2D_FGPFCCR_RBS   = {.msk = 0x00200000U, .pos = 21};   /** @brief Red blue swap this bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only. */
  static const field32_t DMA2D_FGPFCCR_ALPHA = {.msk = 0xFF000000U, .pos = 24};   /** @brief Alpha value these bits define a fixed alpha channel value which can replace the original alpha value or be multiplied by the original alpha value according to the alpha mode selected through the AM[1:0] bits. These bits can only be written when data transfers are disabled. Once a transfer has started, they become read-only. */
  static const field32_t DMA2D_FGCOLR_BLUE   = {.msk = 0x000000FFU, .pos = 0};    /** @brief Blue value these bits defines the blue value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const field32_t DMA2D_FGCOLR_GREEN  = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Green value these bits defines the green value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const field32_t DMA2D_FGCOLR_RED    = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Red value these bits defines the red value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const field32_t DMA2D_BGPFCCR_CM    = {.msk = 0x0000000FU, .pos = 0};    /** @brief Color mode these bits define the color format of the foreground image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless. */
  static const field32_t DMA2D_BGPFCCR_CCM   = {.msk = 0x00000010U, .pos = 4};    /** @brief CLUT color mode these bits define the color format of the CLUT. This register can only be written when the transfer is disabled. Once the CLUT transfer has started, this bit is read-only. */
  static const field32_t DMA2D_BGPFCCR_START = {.msk = 0x00000020U, .pos = 5};    /** @brief Start this bit is set to start the automatic loading of the CLUT. This bit is automatically reset: ** at the end of the transfer ** when the transfer is aborted by the user application by setting the ABORT bit in the DMA2D_CR ** when a transfer error occurs ** when the transfer has not started due to a configuration error or another transfer operation already on going (data transfer or automatic background CLUT transfer). */
  static const field32_t DMA2D_BGPFCCR_CS    = {.msk = 0x0000FF00U, .pos = 8};    /** @brief CLUT size these bits define the size of the CLUT used for the BG. Once the CLUT transfer has started, this field is read-only. The number of CLUT entries is equal to CS[7:0] + 1. */
  static const field32_t DMA2D_BGPFCCR_AM    = {.msk = 0x00030000U, .pos = 16};   /** @brief Alpha mode these bits define which alpha channel value to be used for the background image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless. */
  static const field32_t DMA2D_BGPFCCR_AI    = {.msk = 0x00100000U, .pos = 20};   /** @brief Alpha inverted this bit inverts the alpha value. Once the transfer has started, this bit is read-only. */
  static const field32_t DMA2D_BGPFCCR_RBS   = {.msk = 0x00200000U, .pos = 21};   /** @brief Red blue swap this bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only. */
  static const field32_t DMA2D_BGPFCCR_ALPHA = {.msk = 0xFF000000U, .pos = 24};   /** @brief Alpha value these bits define a fixed alpha channel value which can replace the original alpha value or be multiplied with the original alpha value according to the alpha mode selected with bits AM[1: 0]. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const field32_t DMA2D_BGCOLR_BLUE   = {.msk = 0x000000FFU, .pos = 0};    /** @brief Blue value these bits define the blue value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const field32_t DMA2D_BGCOLR_GREEN  = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Green value these bits define the green value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const field32_t DMA2D_BGCOLR_RED    = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Red value these bits define the red value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const field32_t DMA2D_OPFCCR_CM     = {.msk = 0x00000007U, .pos = 0};    /** @brief Color mode these bits define the color format of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless. */
  static const field32_t DMA2D_OPFCCR_AI     = {.msk = 0x00100000U, .pos = 20};   /** @brief Alpha inverted this bit inverts the alpha value. Once the transfer has started, this bit is read-only. */
  static const field32_t DMA2D_OPFCCR_RBS    = {.msk = 0x00200000U, .pos = 21};   /** @brief Red blue swap this bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only. */
  static const field32_t DMA2D_OCOLR_BLUE    = {.msk = 0x000000FFU, .pos = 0};    /** @brief Blue value these bits define the blue value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const field32_t DMA2D_OCOLR_GREEN   = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Green value these bits define the green value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const field32_t DMA2D_OCOLR_RED     = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Red value these bits define the red value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const field32_t DMA2D_OCOLR_ALPHA   = {.msk = 0xFF000000U, .pos = 24};   /** @brief Alpha channel value these bits define the alpha channel of the output color. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const field32_t DMA2D_OOR_LO        = {.msk = 0x00003FFFU, .pos = 0};    /** @brief Line offset line offset used for the output (expressed in pixels). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const field32_t DMA2D_NLR_NL        = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Number of lines number of lines of the area to be transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const field32_t DMA2D_NLR_PL        = {.msk = 0x3FFF0000U, .pos = 16};   /** @brief Pixel per lines number of pixels per lines of the area to be transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. If any of the input image format is 4-bit per pixel, pixel per lines must be even. */
  static const field32_t DMA2D_LWR_LW        = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Line watermark these bits allow to configure the line watermark for interrupt generation. An interrupt is raised when the last pixel of the watermarked line has been transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const field32_t DMA2D_AMTCR_EN      = {.msk = 0x00000001U, .pos = 0};    /** @brief Enable enables the dead time functionality. */
  static const field32_t DMA2D_AMTCR_DT      = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Dead time dead time value in the AXI clock cycle inserted between two consecutive accesses on the AXI master port. These bits represent the minimum guaranteed number of cycles between two consecutive AXI accesses. */

  /************************************************************************************************
   * DMAMUXx Definitions
   ************************************************************************************************/

  /**** Enumerated DMAMUXx Register Definitions ****/

  static const rw_reg32_t DMAMUXx_CxCR[3][8] = {
    [1] = {
      [0] = (rw_reg32_t)0x40020800U,   /** @brief DMAMux - DMA request line multiplexer channel x control register. */
      [1] = (rw_reg32_t)0x40020804U,   /** @brief DMAMux - DMA request line multiplexer channel x control register. */
      [2] = (rw_reg32_t)0x40020808U,   /** @brief DMAMux - DMA request line multiplexer channel x control register. */
      [3] = (rw_reg32_t)0x4002080CU,   /** @brief DMAMux - DMA request line multiplexer channel x control register. */
      [4] = (rw_reg32_t)0x40020810U,   /** @brief DMAMux - DMA request line multiplexer channel x control register. */
      [5] = (rw_reg32_t)0x40020814U,   /** @brief DMAMux - DMA request line multiplexer channel x control register. */
      [6] = (rw_reg32_t)0x40020818U,   /** @brief DMAMux - DMA request line multiplexer channel x control register. */
      [7] = (rw_reg32_t)0x4002081CU,   /** @brief DMAMux - DMA request line multiplexer channel x control register. */
    },
    [2] = {
      [0] = (rw_reg32_t)0x58025800U,   /** @brief DMAMux - DMA request line multiplexer channel x control register. */
      [1] = (rw_reg32_t)0x58025804U,   /** @brief DMAMux - DMA request line multiplexer channel x control register. */
      [2] = (rw_reg32_t)0x58025808U,   /** @brief DMAMux - DMA request line multiplexer channel x control register. */
      [3] = (rw_reg32_t)0x5802580CU,   /** @brief DMAMux - DMA request line multiplexer channel x control register. */
      [4] = (rw_reg32_t)0x58025810U,   /** @brief DMAMux - DMA request line multiplexer channel x control register. */
      [5] = (rw_reg32_t)0x58025814U,   /** @brief DMAMux - DMA request line multiplexer channel x control register. */
      [6] = (rw_reg32_t)0x58025818U,   /** @brief DMAMux - DMA request line multiplexer channel x control register. */
      [7] = (rw_reg32_t)0x5802581CU,   /** @brief DMAMux - DMA request line multiplexer channel x control register. */
    },
  };

  static const rw_reg32_t DMAMUXx_RGxCR[3][8] = {
    [1] = {
      [0] = (rw_reg32_t)0x40020900U,   /** @brief DMAMux - DMA request generator channel x control register. */
      [1] = (rw_reg32_t)0x40020904U,   /** @brief DMAMux - DMA request generator channel x control register. */
      [2] = (rw_reg32_t)0x40020908U,   /** @brief DMAMux - DMA request generator channel x control register. */
      [3] = (rw_reg32_t)0x4002090CU,   /** @brief DMAMux - DMA request generator channel x control register. */
      [4] = (rw_reg32_t)0x40020910U,   /** @brief DMAMux - DMA request generator channel x control register. */
      [5] = (rw_reg32_t)0x40020914U,   /** @brief DMAMux - DMA request generator channel x control register. */
      [6] = (rw_reg32_t)0x40020918U,   /** @brief DMAMux - DMA request generator channel x control register. */
      [7] = (rw_reg32_t)0x4002091CU,   /** @brief DMAMux - DMA request generator channel x control register. */
    },
    [2] = {
      [0] = (rw_reg32_t)0x58025900U,   /** @brief DMAMux - DMA request generator channel x control register. */
      [1] = (rw_reg32_t)0x58025904U,   /** @brief DMAMux - DMA request generator channel x control register. */
      [2] = (rw_reg32_t)0x58025908U,   /** @brief DMAMux - DMA request generator channel x control register. */
      [3] = (rw_reg32_t)0x5802590CU,   /** @brief DMAMux - DMA request generator channel x control register. */
      [4] = (rw_reg32_t)0x58025910U,   /** @brief DMAMux - DMA request generator channel x control register. */
      [5] = (rw_reg32_t)0x58025914U,   /** @brief DMAMux - DMA request generator channel x control register. */
      [6] = (rw_reg32_t)0x58025918U,   /** @brief DMAMux - DMA request generator channel x control register. */
      [7] = (rw_reg32_t)0x5802591CU,   /** @brief DMAMux - DMA request generator channel x control register. */
    },
  };

  static const ro_reg32_t DMAMUXx_RGSR[3] = {
    [1] = (ro_reg32_t)0x40020940U,   /** @brief DMAMux - DMA request generator status register. */
    [2] = (ro_reg32_t)0x58025940U,   /** @brief DMAMux - DMA request generator status register. */
  };

  static const rw_reg32_t DMAMUXx_RGCFR[3] = {
    [1] = (rw_reg32_t)0x40020944U,   /** @brief DMAMux - DMA request generator clear flag register. */
    [2] = (rw_reg32_t)0x58025944U,   /** @brief DMAMux - DMA request generator clear flag register. */
  };

  static const ro_reg32_t DMAMUXx_CSR[3] = {
    [1] = (ro_reg32_t)0x40020880U,   /** @brief DMAMUX request line multiplexer interrupt channel status register. */
    [2] = (ro_reg32_t)0x58025880U,   /** @brief DMAMUX request line multiplexer interrupt channel status register. */
  };

  static const rw_reg32_t DMAMUXx_CFR[3] = {
    [1] = (rw_reg32_t)0x40020884U,   /** @brief DMAMUX request line multiplexer interrupt clear flag register. */
    [2] = (rw_reg32_t)0x58025884U,   /** @brief DMAMUX request line multiplexer interrupt clear flag register. */
  };

  /**** DMAMUXx Register Field Definitions ****/

  static const field32_t DMAMUXx_CxCR_DMAREQ_ID = {.msk = 0x000000FFU, .pos = 0};    /** @brief Input DMA request line selected. */
  static const field32_t DMAMUXx_CxCR_SOIE      = {.msk = 0x00000100U, .pos = 8};    /** @brief Interrupt enable at synchronization event overrun. */
  static const field32_t DMAMUXx_CxCR_EGE       = {.msk = 0x00000200U, .pos = 9};    /** @brief Event generation enable/disable. */
  static const field32_t DMAMUXx_CxCR_SE        = {.msk = 0x00010000U, .pos = 16};   /** @brief Synchronous operating mode enable/disable. */
  static const field32_t DMAMUXx_CxCR_SPOL      = {.msk = 0x00060000U, .pos = 17};   /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input:. */
  static const field32_t DMAMUXx_CxCR_NBREQ     = {.msk = 0x00F80000U, .pos = 19};   /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
  static const field32_t DMAMUXx_CxCR_SYNC_ID   = {.msk = 0x1F000000U, .pos = 24};   /** @brief Synchronization input selected. */
  static const field32_t DMAMUXx_RGxCR_SIG_ID   = {.msk = 0x0000001FU, .pos = 0};    /** @brief DMA request trigger input selected. */
  static const field32_t DMAMUXx_RGxCR_OIE      = {.msk = 0x00000100U, .pos = 8};    /** @brief Interrupt enable at trigger event overrun. */
  static const field32_t DMAMUXx_RGxCR_GE       = {.msk = 0x00010000U, .pos = 16};   /** @brief DMA request generator channel enable/disable. */
  static const field32_t DMAMUXx_RGxCR_GPOL     = {.msk = 0x00060000U, .pos = 17};   /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input. */
  static const field32_t DMAMUXx_RGxCR_GNBREQ   = {.msk = 0x00F80000U, .pos = 19};   /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
  static const field32_t DMAMUXx_RGSR_OF        = {.msk = 0x000000FFU, .pos = 0};    /** @brief Trigger event overrun flag the flag is set when a trigger event occurs on DMA request generator channel x, while the DMA request generator counter value is lower than GNBREQ. The flag is cleared by writing 1 to the corresponding cofx bit in DMAMUX_RGCFR register. */
  static const field32_t DMAMUXx_RGCFR_COF      = {.msk = 0x000000FFU, .pos = 0};    /** @brief Clear trigger event overrun flag upon setting, this bit clears the corresponding overrun flag ofx in the DMAMUX_RGCSR register. */
  static const field32_t DMAMUXx_CSR_SOF        = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Synchronization overrun event flag. */
  static const field32_t DMAMUXx_CFR_CSOF       = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Clear synchronization overrun event flag. */

  /************************************************************************************************
   * FMC Definitions
   ************************************************************************************************/

  /**** FMC Register Definitions ****/

  static const rw_reg32_t FMC_PCR   = (rw_reg32_t)0x52004080U;   /** @brief NAND flash control registers. */
  static const rw_reg32_t FMC_SR    = (rw_reg32_t)0x52004084U;   /** @brief This register contains information about the FIFO status and interrupt. The FMC features a FIFO that is used when writing to memories to transfer up to 16 words of data.this is used to quickly write to the FIFO and free the AXI bus for transactions to peripherals other than the FMC, while the FMC is draining its FIFO into the memory. One of these register bits indicates the status of the FIFO, for ECC purposes.the ECC is calculated while the data are written to the memory. To read the correct ECC, the software must consequently wait until the FIFO is empty. */
  static const rw_reg32_t FMC_PMEM  = (rw_reg32_t)0x52004088U;   /** @brief The FMC_PMEM read/write register contains the timing information for NAND flash memory bank. This information is used to access either the common memory space of the NAND flash for command, address write access and data read/write access. */
  static const rw_reg32_t FMC_PATT  = (rw_reg32_t)0x5200408CU;   /** @brief The FMC_PATT read/write register contains the timing information for NAND flash memory bank. It is used for 8-bit accesses to the attribute memory space of the NAND flash for the last address write access if the timing must differ from that of previous accesses (for ready/busy management, refer to section20.8.5: NAND flash prewait feature). */
  static const ro_reg32_t FMC_ECCR  = (ro_reg32_t)0x52004094U;   /** @brief This register contain the current error correction code value computed by the ECC computation modules of the FMC NAND controller. When the CPU reads/writes the data from a NAND flash memory page at the correct address (refer to section20.8.6: computation of the error correction code (ECC) in NAND flash memory), the data read/written from/to the NAND flash memory are processed automatically by the ECC computation module. When X bytes have been read (according to the ECCPS field in the FMC_PCR registers), the CPU must read the computed ECC value from the FMC_ECC registers. It then verifies if these computed parity data are the same as the parity value recorded in the spare area, to determine whether a page is valid, and, to correct it otherwise. The FMC_ECCR register should be cleared after being read by setting the ECCEN bit to 0. To compute a new data block, the ECCEN bit must be set to 1. */
  static const rw_reg32_t FMC_SDCMR = (rw_reg32_t)0x52004150U;   /** @brief This register contains the command issued when the SDRAM device is accessed. This register is used to initialize the SDRAM device, and to activate the self-refresh and the power-down modes. As soon as the MODE field is written, the command will be issued only to one or to both SDRAM banks according to CTB1 and CTB2 command bits. This register is the same for both SDRAM banks. */
  static const rw_reg32_t FMC_SDRTR = (rw_reg32_t)0x52004154U;   /** @brief This register sets the refresh rate in number of SDCLK clock cycles between the refresh cycles by configuring the refresh timer count value.examplewhere 64 ms is the SDRAM refresh period.the refresh rate must be increased by 20 SDRAM clock cycles (as in the above example) to obtain a safe margin if an internal refresh request occurs when a read request has been accepted. It corresponds to a COUNT value of 0000111000000 (448). This 13-bit field is loaded into a timer which is decremented using the SDRAM clock. This timer generates a refresh pulse when zero is reached. The COUNT value must be set at least to 41 SDRAM clock cycles.as soon as the FMC_SDRTR register is programmed, the timer starts counting. If the value programmed in the register is 0, no refresh is carried out. This register must not be reprogrammed after the initialization procedure to avoid modifying the refresh rate.each time a refresh pulse is generated, this 13-bit COUNT field is reloaded into the counter.if a memory access is in progress, the auto-refresh request is delayed. However, if the memory access and auto-refresh requests are generated simultaneously, the auto-refresh takes precedence. If the memory access occurs during a refresh operation, the request is buffered to be processed when the refresh is complete.this register is common to SDRAM bank 1 and bank 2. */
  static const ro_reg32_t FMC_SDSR  = (ro_reg32_t)0x52004158U;   /** @brief SDRAM status register. */

  /**** Enumerated FMC Register Definitions ****/

  static const rw_reg32_t FMC_BCRx[5] = {
    [1] = (rw_reg32_t)0x52004000U,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories. */
    [2] = (rw_reg32_t)0x52004008U,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories. */
    [3] = (rw_reg32_t)0x52004010U,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories. */
    [4] = (rw_reg32_t)0x52004018U,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories. */
  };

  static const rw_reg32_t FMC_BTRx[5] = {
    [1] = (rw_reg32_t)0x52004004U,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories.if the EXTMOD bit is set in the fmc_bcrx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (fmc_bwtrx registers). */
    [2] = (rw_reg32_t)0x5200400CU,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories.if the EXTMOD bit is set in the fmc_bcrx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (fmc_bwtrx registers). */
    [3] = (rw_reg32_t)0x52004014U,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories.if the EXTMOD bit is set in the fmc_bcrx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (fmc_bwtrx registers). */
    [4] = (rw_reg32_t)0x5200401CU,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories.if the EXTMOD bit is set in the fmc_bcrx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (fmc_bwtrx registers). */
  };

  static const rw_reg32_t FMC_BWTRx[5] = {
    [1] = (rw_reg32_t)0x52004104U,   /** @brief This register contains the control information of each memory bank. It is used for srams, psrams and NOR flash memories. When the EXTMOD bit is set in the fmc_bcrx register, then this register is active for write access. */
    [2] = (rw_reg32_t)0x5200410CU,   /** @brief This register contains the control information of each memory bank. It is used for srams, psrams and NOR flash memories. When the EXTMOD bit is set in the fmc_bcrx register, then this register is active for write access. */
    [3] = (rw_reg32_t)0x52004114U,   /** @brief This register contains the control information of each memory bank. It is used for srams, psrams and NOR flash memories. When the EXTMOD bit is set in the fmc_bcrx register, then this register is active for write access. */
    [4] = (rw_reg32_t)0x5200411CU,   /** @brief This register contains the control information of each memory bank. It is used for srams, psrams and NOR flash memories. When the EXTMOD bit is set in the fmc_bcrx register, then this register is active for write access. */
  };

  static const rw_reg32_t FMC_SDCRx[3] = {
    [1] = (rw_reg32_t)0x52004140U,   /** @brief This register contains the control parameters for each SDRAM memory bank. */
    [2] = (rw_reg32_t)0x52004144U,   /** @brief This register contains the control parameters for each SDRAM memory bank. */
  };

  static const rw_reg32_t FMC_SDTRx[3] = {
    [1] = (rw_reg32_t)0x52004148U,   /** @brief This register contains the timing parameters of each SDRAM bank. */
    [2] = (rw_reg32_t)0x5200414CU,   /** @brief This register contains the timing parameters of each SDRAM bank. */
  };

  /**** FMC Register Field Definitions ****/

  static const field32_t FMC_BCRx_MBKEN     = {.msk = 0x00000001U, .pos = 0};    /** @brief Memory bank enable bit this bit enables the memory bank. After reset bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus. */
  static const field32_t FMC_BCRx_MUXEN     = {.msk = 0x00000002U, .pos = 1};    /** @brief Address/data multiplexing enable bit when this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:. */
  static const field32_t FMC_BCRx_MTYP      = {.msk = 0x0000000CU, .pos = 2};    /** @brief Memory type these bits define the type of external memory attached to the corresponding memory bank:. */
  static const field32_t FMC_BCRx_MWID      = {.msk = 0x00000030U, .pos = 4};    /** @brief Memory data bus width defines the external memory device width, valid for all type of memories. */
  static const field32_t FMC_BCRx_FACCEN    = {.msk = 0x00000040U, .pos = 6};    /** @brief Flash access enable this bit enables NOR flash memory access operations. */
  static const field32_t FMC_BCRx_BURSTEN   = {.msk = 0x00000100U, .pos = 8};    /** @brief Burst enable bit this bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in burst mode:. */
  static const field32_t FMC_BCRx_WAITPOL   = {.msk = 0x00000200U, .pos = 9};    /** @brief Wait signal polarity bit this bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:. */
  static const field32_t FMC_BCRx_WAITCFG   = {.msk = 0x00000800U, .pos = 11};   /** @brief Wait timing configuration the NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:. */
  static const field32_t FMC_BCRx_WREN      = {.msk = 0x00001000U, .pos = 12};   /** @brief Write enable bit this bit indicates whether write operations are enabled/disabled in the bank by the FMC:. */
  static const field32_t FMC_BCRx_WAITEN    = {.msk = 0x00002000U, .pos = 13};   /** @brief Wait enable bit this bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode. */
  static const field32_t FMC_BCRx_EXTMOD    = {.msk = 0x00004000U, .pos = 14};   /** @brief Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: when the extended mode is disabled, the FMC can operate in mode1 or mode2 as follows: ** mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10). */
  static const field32_t FMC_BCRx_ASYNCWAIT = {.msk = 0x00008000U, .pos = 15};   /** @brief Wait signal during asynchronous transfers this bit enables/disables the FMC to use the wait signal even during an asynchronous protocol. */
  static const field32_t FMC_BCRx_CPSIZE    = {.msk = 0x00070000U, .pos = 16};   /** @brief CRAM page size these are used for cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved. */
  static const field32_t FMC_BCRx_CBURSTRW  = {.msk = 0x00080000U, .pos = 19};   /** @brief Write burst enable for PSRAM (CRAM) operating in burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the fmc_bcrx register. */
  static const field32_t FMC_BCRx_CCLKEN    = {.msk = 0x00100000U, .pos = 20};   /** @brief Continuous clock enable this bit enables the FMC_CLK clock output to external memory devices. Note: the CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.). */
  static const field32_t FMC_BCRx_WFDIS     = {.msk = 0x00200000U, .pos = 21};   /** @brief Write FIFO disable this bit disables the write FIFO used by the FMC controller. Note: the WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
  static const field32_t FMC_BCRx_BMAP      = {.msk = 0x03000000U, .pos = 24};   /** @brief FMC bank mapping these bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.refer to table 10 for note: the BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register. */
  static const field32_t FMC_BCRx_FMCEN     = {.msk = 0x80000000U, .pos = 31};   /** @brief FMC controller enable this bit enables/disables the FMC controller. Note: the FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
  static const field32_t FMC_BTRx_ADDSET    = {.msk = 0x0000000FU, .pos = 0};    /** @brief Address setup phase duration these bits are written by software to define the duration of the address setup phase (refer to figure81 to figure93), used in srams, roms and asynchronous NOR flash: for each access mode address setup phase duration, please refer to the respective figure (refer to figure81 to figure93). Note: in synchronous accesses, this value is dont care. In muxed mode or mode D, the minimum value for ADDSET is 1. */
  static const field32_t FMC_BTRx_ADDHLD    = {.msk = 0x000000F0U, .pos = 4};    /** @brief Address-hold phase duration these bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in mode D or multiplexed accesses: for each access mode address-hold phase duration, please refer to the respective figure (figure81 to figure93). Note: in synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration. */
  static const field32_t FMC_BTRx_DATAST    = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Data-phase duration these bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous accesses: for each memory type and access mode data-phase duration, please refer to the respective figure (figure81 to figure93). Example: mode1, write access, DATAST=1: data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: in synchronous accesses, this value is dont care. */
  static const field32_t FMC_BTRx_BUSTURN   = {.msk = 0x000F0000U, .pos = 16};   /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in burst or single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write access (in burst or single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tehel from nex high to nex low) and the maximum time required by the memory to free the data bus after a read access (tehqz): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin and (BUSTRUN + 2)KCK_FMC period &#8805; tehqzmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tehelmin, tehqzmax) if EXTMOD = 126. ... */
  static const field32_t FMC_BTRx_CLKDIV    = {.msk = 0x00F00000U, .pos = 20};   /** @brief Clock divide ratio (for FMC_CLK signal) these bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: in asynchronous NOR flash, SRAM or PSRAM accesses, this value is dont care. Note: refer to section20.6.5: synchronous transactions for FMC_CLK divider ratio formula). */
  static const field32_t FMC_BTRx_DATLAT    = {.msk = 0x0F000000U, .pos = 24};   /** @brief Data latency for synchronous memory for synchronous access with read write burst mode enabled these bits define the number of memory clock cycles. */
  static const field32_t FMC_BTRx_ACCMOD    = {.msk = 0x30000000U, .pos = 28};   /** @brief Access mode these bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
  static const field32_t FMC_PCR_PWAITEN    = {.msk = 0x00000002U, .pos = 1};    /** @brief Wait feature enable bit. This bit enables the wait feature for the NAND flash memory bank:. */
  static const field32_t FMC_PCR_PBKEN      = {.msk = 0x00000004U, .pos = 2};    /** @brief NAND flash memory bank enable bit. This bit enables the memory bank. Accessing a disabled memory bank causes an ERROR on AXI bus. */
  static const field32_t FMC_PCR_PWID       = {.msk = 0x00000030U, .pos = 4};    /** @brief Data bus width. These bits define the external memory device width. */
  static const field32_t FMC_PCR_ECCEN      = {.msk = 0x00000040U, .pos = 6};    /** @brief ECC computation logic enable bit. */
  static const field32_t FMC_PCR_TCLR       = {.msk = 0x00001E00U, .pos = 9};    /** @brief CLE to RE delay. These bits set time from CLE low to RE low in number of KCK_FMC clock cycles. The time is give by the following formula: t_clr = (TCLR + SET + 2) TKCK_FMC where TKCK_FMC is the KCK_FMC clock period note: set is MEMSET or ATTSET according to the addressed space. */
  static const field32_t FMC_PCR_TAR        = {.msk = 0x0001E000U, .pos = 13};   /** @brief ALE to RE delay. These bits set time from ALE low to RE low in number of KCK_FMC clock cycles. Time is: t_ar = (TAR + SET + 2) TKCK_FMC where TKCK_FMC is the FMC clock period note: set is MEMSET or ATTSET according to the addressed space. */
  static const field32_t FMC_PCR_ECCPS      = {.msk = 0x000E0000U, .pos = 17};   /** @brief ECC page size. These bits define the page size for the extended ECC:. */
  static const field32_t FMC_SR_IRS         = {.msk = 0x00000001U, .pos = 0};    /** @brief Interrupt rising edge status the flag is set by hardware and reset by software. Note: if this bit is written by software to 1 it will be set. */
  static const field32_t FMC_SR_ILS         = {.msk = 0x00000002U, .pos = 1};    /** @brief Interrupt high-level status the flag is set by hardware and reset by software. */
  static const field32_t FMC_SR_IFS         = {.msk = 0x00000004U, .pos = 2};    /** @brief Interrupt falling edge status the flag is set by hardware and reset by software. Note: if this bit is written by software to 1 it will be set. */
  static const field32_t FMC_SR_IREN        = {.msk = 0x00000008U, .pos = 3};    /** @brief Interrupt rising edge detection enable bit. */
  static const field32_t FMC_SR_ILEN        = {.msk = 0x00000010U, .pos = 4};    /** @brief Interrupt high-level detection enable bit. */
  static const field32_t FMC_SR_IFEN        = {.msk = 0x00000020U, .pos = 5};    /** @brief Interrupt falling edge detection enable bit. */
  static const field32_t FMC_SR_FEMPT       = {.msk = 0x00000040U, .pos = 6};    /** @brief FIFO empty. Read-only bit that provides the status of the FIFO. */
  static const field32_t FMC_PMEM_MEMSET    = {.msk = 0x000000FFU, .pos = 0};    /** @brief Common memory x setup time these bits define the number of KCK_FMC (+1) clock cycles to set up the address before the command assertion (NWE, NOE), for NAND flash read or write access to common memory space:. */
  static const field32_t FMC_PMEM_MEMWAIT   = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Common memory wait time these bits define the minimum number of KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND flash read or write access to common memory space. The duration of command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC:. */
  static const field32_t FMC_PMEM_MEMHOLD   = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Common memory hold time these bits define the number of KCK_FMC clock cycles for write accesses and KCK_FMC+1 clock cycles for read accesses during which the address is held (and data for write accesses) after the command is de-asserted (NWE, NOE), for NAND flash read or write access to common memory space:. */
  static const field32_t FMC_PMEM_MEMHIZ    = {.msk = 0xFF000000U, .pos = 24};   /** @brief Common memory x data bus hi-z time these bits define the number of KCK_FMC clock cycles during which the data bus is kept hi-z after the start of a NAND flash write access to common memory space. This is only valid for write transactions:. */
  static const field32_t FMC_PATT_ATTSET    = {.msk = 0x000000FFU, .pos = 0};    /** @brief Attribute memory setup time these bits define the number of KCK_FMC (+1) clock cycles to set up address before the command assertion (NWE, NOE), for NAND flash read or write access to attribute memory space:. */
  static const field32_t FMC_PATT_ATTWAIT   = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Attribute memory wait time these bits define the minimum number of x KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND flash read or write access to attribute memory space. The duration for command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC:. */
  static const field32_t FMC_PATT_ATTHOLD   = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Attribute memory hold time these bits define the number of KCK_FMC clock cycles during which the address is held (and data for write access) after the command de-assertion (NWE, NOE), for NAND flash read or write access to attribute memory space:. */
  static const field32_t FMC_PATT_ATTHIZ    = {.msk = 0xFF000000U, .pos = 24};   /** @brief Attribute memory data bus hi-z time these bits define the number of KCK_FMC clock cycles during which the data bus is kept in hi-z after the start of a NAND flash write access to attribute memory space on socket. Only valid for writ transaction:. */
  static const field32_t FMC_BWTRx_ADDSET   = {.msk = 0x0000000FU, .pos = 0};    /** @brief Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to figure81 to figure93), used in asynchronous accesses: ... Note: in synchronous accesses, this value is not used, the address setup phase is always 1 flash clock period duration. In muxed mode, the minimum ADDSET value is 1. */
  static const field32_t FMC_BWTRx_ADDHLD   = {.msk = 0x000000F0U, .pos = 4};    /** @brief Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in asynchronous multiplexed accesses: ... Note: in synchronous NOR flash accesses, this value is not used, the address hold phase is always 1 flash clock period duration. */
  static const field32_t FMC_BWTRx_DATAST   = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Data-phase duration. These bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous SRAM, PSRAM and NOR flash memory accesses:. */
  static const field32_t FMC_BWTRx_BUSTURN  = {.msk = 0x000F0000U, .pos = 16};   /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tehel from enx high to enx low): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank A synchronous write transfer ((in burst or single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write transfer (in burst or single mode) and a synchronous read from the same or a different bank. ... */
  static const field32_t FMC_BWTRx_ACCMOD   = {.msk = 0x30000000U, .pos = 28};   /** @brief Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.these bits are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
  static const field32_t FMC_SDCRx_NC       = {.msk = 0x00000003U, .pos = 0};    /** @brief Number of column address bits these bits define the number of bits of a column address. */
  static const field32_t FMC_SDCRx_NR       = {.msk = 0x0000000CU, .pos = 2};    /** @brief Number of row address bits these bits define the number of bits of a row address. */
  static const field32_t FMC_SDCRx_MWID     = {.msk = 0x00000030U, .pos = 4};    /** @brief Memory data bus width. These bits define the memory device width. */
  static const field32_t FMC_SDCRx_NB       = {.msk = 0x00000040U, .pos = 6};    /** @brief Number of internal banks this bit sets the number of internal banks. */
  static const field32_t FMC_SDCRx_CAS      = {.msk = 0x00000180U, .pos = 7};    /** @brief CAS latency this bits sets the SDRAM CAS latency in number of memory clock cycles. */
  static const field32_t FMC_SDCRx_WP       = {.msk = 0x00000200U, .pos = 9};    /** @brief Write protection this bit enables write mode access to the SDRAM bank. */
  static const field32_t FMC_SDCRx_SDCLK    = {.msk = 0x00000C00U, .pos = 10};   /** @brief SDRAM clock configuration these bits define the SDRAM clock period for both SDRAM banks and allow disabling the clock before changing the frequency. In this case the SDRAM must be re-initialized. Note: the corresponding bits in the FMC_SDCR2 register is read only. */
  static const field32_t FMC_SDCRx_RBURST   = {.msk = 0x00001000U, .pos = 12};   /** @brief Burst read this bit enables burst read mode. The SDRAM controller anticipates the next read commands during the CAS latency and stores data in the read FIFO. Note: the corresponding bit in the FMC_SDCR2 register is read only. */
  static const field32_t FMC_SDCRx_RPIPE    = {.msk = 0x00006000U, .pos = 13};   /** @brief Read pipe these bits define the delay, in KCK_FMC clock cycles, for reading data after CAS latency. Note: the corresponding bits in the FMC_SDCR2 register is read only. */
  static const field32_t FMC_SDTRx_TMRD     = {.msk = 0x0000000FU, .pos = 0};    /** @brief Load mode register to active these bits define the delay between a load mode register command and an active or refresh command in number of memory clock cycles. .... */
  static const field32_t FMC_SDTRx_TXSR     = {.msk = 0x000000F0U, .pos = 4};    /** @brief Exit self-refresh delay these bits define the delay from releasing the self-refresh command to issuing the activate command in number of memory clock cycles. .... Note: if two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TXSR timing corresponding to the slowest SDRAM device. */
  static const field32_t FMC_SDTRx_TRAS     = {.msk = 0x00000F00U, .pos = 8};    /** @brief Self refresh time these bits define the minimum self-refresh period in number of memory clock cycles. .... */
  static const field32_t FMC_SDTRx_TRC      = {.msk = 0x0000F000U, .pos = 12};   /** @brief Row cycle delay these bits define the delay between the refresh command and the activate command, as well as the delay between two consecutive refresh commands. It is expressed in number of memory clock cycles. The TRC timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRC must be programmed with the timings of the slowest device. .... Note: TRC must match the TRC and TRFC (auto refresh period) timings defined in the SDRAM device datasheet. Note: the corresponding bits in the FMC_SDTR2 register are dont care. */
  static const field32_t FMC_SDTRx_TWR      = {.msk = 0x000F0000U, .pos = 16};   /** @brief Recovery delay these bits define the delay between a write and a precharge command in number of memory clock cycles. .... Note: TWR must be programmed to match the write recovery time (twr) defined in the SDRAM datasheet, and to guarantee that: TWR &#8805; TRAS - TRCD and TWR &#8805;TRC - TRCD - TRP example: TRAS= 4 cycles, TRCD= 2 cycles. So, TWR &gt;= 2 cycles. TWR must be programmed to 0x1. If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TWR timing corresponding to the slowest SDRAM device. */
  static const field32_t FMC_SDTRx_TRP      = {.msk = 0x00F00000U, .pos = 20};   /** @brief Row precharge delay these bits define the delay between a precharge command and another command in number of memory clock cycles. The TRP timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRP must be programmed with the timing of the slowest device. .... Note: the corresponding bits in the FMC_SDTR2 register are dont care. */
  static const field32_t FMC_SDTRx_TRCD     = {.msk = 0x0F000000U, .pos = 24};   /** @brief Row to column delay these bits define the delay between the activate command and a read/write command in number of memory clock cycles. .... */
  static const field32_t FMC_SDCMR_MODE     = {.msk = 0x00000007U, .pos = 0};    /** @brief Command mode these bits define the command issued to the SDRAM device. Note: when a command is issued, at least one command target bank bit ( CTB1 or CTB2) must be set otherwise the command will be ignored. Note: if two SDRAM banks are used, the auto-refresh and PALL command must be issued simultaneously to the two devices with CTB1 and CTB2 bits set otherwise the command will be ignored. Note: if only one SDRAM bank is used and a command is issued with its associated CTB bit set, the other CTB bit of the unused bank must be kept to 0. */
  static const field32_t FMC_SDCMR_NRFS     = {.msk = 0x000001E0U, .pos = 5};    /** @brief Number of auto-refresh these bits define the number of consecutive auto-refresh commands issued when MODE = 011. .... */
  static const field32_t FMC_SDCMR_MRD      = {.msk = 0x007FFE00U, .pos = 9};    /** @brief Mode register definition this 14-bit field defines the SDRAM mode register content. The mode register is programmed using the load mode register command. The MRD[13:0] bits are also used to program the extended mode register for mobile SDRAM. */
  static const field32_t FMC_SDRTR_CRE      = {.msk = 0x00000001U, .pos = 0};    /** @brief Clear refresh error flag this bit is used to clear the refresh error flag (RE) in the status register. */
  static const field32_t FMC_SDRTR_COUNT    = {.msk = 0x00003FFEU, .pos = 1};    /** @brief Refresh timer count this 13-bit field defines the refresh rate of the SDRAM device. It is expressed in number of memory clock cycles. It must be set at least to 41 SDRAM clock cycles (0x29). Refresh rate = (COUNT + 1) x SDRAM frequency clock COUNT = (SDRAM refresh period / number of rows) - 20. */
  static const field32_t FMC_SDRTR_REIE     = {.msk = 0x00004000U, .pos = 14};   /** @brief RES interrupt enable. */
  static const field32_t FMC_SDSR_RE        = {.msk = 0x00000001U, .pos = 0};    /** @brief Refresh error flag an interrupt is generated if REIE = 1 and RE = 1. */

  /**** Enumerated FMC Register Field Definitions ****/

  static field32_t const FMC_SDCMR_CTBx[3] = {
    [1] = {.msk = 0x00000010U, .pos = 4},   /** @brief Command target bank 1 this bit indicates whether the command will be issued to SDRAM bank 1 or not. */
    [2] = {.msk = 0x00000008U, .pos = 3},   /** @brief Command target bank 2 this bit indicates whether the command will be issued to SDRAM bank 2 or not. */
  };

  static field32_t const FMC_SDSR_MODESx[3] = {
    [1] = {.msk = 0x00000006U, .pos = 1},   /** @brief Status mode for bank 1 these bits define the status mode of SDRAM bank 1. */
    [2] = {.msk = 0x00000018U, .pos = 3},   /** @brief Status mode for bank 2 these bits define the status mode of SDRAM bank 2. */
  };

  /************************************************************************************************
   * CEC Definitions
   ************************************************************************************************/

  /**** CEC Register Definitions ****/

  static const rw_reg32_t CEC_CR   = (rw_reg32_t)0x40006C00U;   /** @brief CEC control register. */
  static const rw_reg32_t CEC_CFGR = (rw_reg32_t)0x40006C04U;   /** @brief This register is used to configure the HDMI-CEC controller. It is mandatory to write CEC_CFGR only when CECEN=0. */
  static const rw_reg32_t CEC_TXDR = (rw_reg32_t)0x40006C08U;   /** @brief CEC tx data register. */
  static const ro_reg32_t CEC_RXDR = (ro_reg32_t)0x40006C0CU;   /** @brief CEC rx data register. */
  static const rw_reg32_t CEC_ISR  = (rw_reg32_t)0x40006C10U;   /** @brief CEC interrupt and status register. */
  static const rw_reg32_t CEC_IER  = (rw_reg32_t)0x40006C14U;   /** @brief CEC interrupt enable register. */

  /**** CEC Register Field Definitions ****/

  static const field32_t CEC_CR_CECEN      = {.msk = 0x00000001U, .pos = 0};    /** @brief CEC enable the CECEN bit is set and cleared by software. CECEN=1 starts message reception and enables the TXSOM control. CECEN=0 disables the CEC peripheral, clears all bits of CEC_CR register and aborts any on-going reception or transmission. */
  static const field32_t CEC_CR_TXSOM      = {.msk = 0x00000002U, .pos = 1};    /** @brief Tx start of message TXSOM is set by software to command transmission of the first byte of a CEC message. If the CEC message consists of only one byte, TXEOM must be set before of TXSOM. Start-Bit is effectively started on the CEC line after SFT is counted. If TXSOM is set while a message reception is ongoing, transmission will start after the end of reception. TXSOM is cleared by hardware after the last byte of the message is sent with a positive acknowledge (TXEND=1), in case of transmission underrun (TXUDR=1), negative acknowledge (TXACKE=1), and transmission error (TXERR=1). It is also cleared by CECEN=0. It is not cleared and transmission is automatically retried in case of arbitration lost (ARBLST=1). TXSOM can be also used as a status bit informing application whether any transmission request is pending or under execution. The application can abort a transmission request at any time by clearing the CECEN bit. Note: TXSOM must be set when CECEN=1 TXSOM must be set when transmission data is available into TXDR headers first four bits containing own peripheral address are taken from TXDR[7:4], not from CEC_CFGR.OAR which is used only for reception. */
  static const field32_t CEC_CR_TXEOM      = {.msk = 0x00000004U, .pos = 2};    /** @brief Tx end of message the TXEOM bit is set by software to command transmission of the last byte of a CEC message. TXEOM is cleared by hardware at the same time and under the same conditions as for TXSOM. Note: TXEOM must be set when CECEN=1 TXEOM must be set before writing transmission data to TXDR if TXEOM is set when TXSOM=0, transmitted message will consist of 1 byte (HEADER) only (PING message). */
  static const field32_t CEC_CFGR_SFT      = {.msk = 0x00000007U, .pos = 0};    /** @brief Signal free time SFT bits are set by software. In the sft=0x0 configuration the number of nominal data bit periods waited before transmission is ruled by hardware according to the transmission history. In all the other configurations the SFT number is determined by software. * 0x0 ** 2.5 data-bit periods if CEC is the last bus initiator with unsuccessful transmission (ARBLST=1, TXERR=1, TXUDR=1 or TXACKE= 1) ** 4 data-bit periods if CEC is the new bus initiator ** 6 data-bit periods if CEC is the last bus initiator with successful transmission (TXEOM=1) * 0x1: 0.5 nominal data bit periods * 0x2: 1.5 nominal data bit periods * 0x3: 2.5 nominal data bit periods * 0x4: 3.5 nominal data bit periods * 0x5: 4.5 nominal data bit periods * 0x6: 5.5 nominal data bit periods * 0x7: 6.5 nominal data bit periods. */
  static const field32_t CEC_CFGR_RXTOL    = {.msk = 0x00000008U, .pos = 3};    /** @brief Rx-Tolerance the RXTOL bit is set and cleared by software. ** start-bit, +/- 200 s rise, +/- 200 s fall. ** data-bit: +/- 200 s rise. +/- 350 s fall. ** start-bit: +/- 400 s rise, +/- 400 s fall ** data-bit: +/-300 s rise, +/- 500 s fall. */
  static const field32_t CEC_CFGR_BRESTP   = {.msk = 0x00000010U, .pos = 4};    /** @brief Rx-Stop on bit rising error the BRESTP bit is set and cleared by software. */
  static const field32_t CEC_CFGR_BREGEN   = {.msk = 0x00000020U, .pos = 5};    /** @brief Generate error-bit on bit rising error the BREGEN bit is set and cleared by software. Note: if BRDNOGEN=0, an error-bit is generated upon BRE detection with BRESTP=1 in broadcast even if BREGEN=0. */
  static const field32_t CEC_CFGR_LBPEGEN  = {.msk = 0x00000040U, .pos = 6};    /** @brief Generate error-bit on long bit period error the LBPEGEN bit is set and cleared by software. Note: if BRDNOGEN=0, an error-bit is generated upon LBPE detection in broadcast even if LBPEGEN=0. */
  static const field32_t CEC_CFGR_BRDNOGEN = {.msk = 0x00000080U, .pos = 7};    /** @brief Avoid error-bit generation in broadcast the BRDNOGEN bit is set and cleared by software. */
  static const field32_t CEC_CFGR_SFTOPT   = {.msk = 0x00000100U, .pos = 8};    /** @brief SFT option bit the SFTOPT bit is set and cleared by software. */
  static const field32_t CEC_CFGR_OAR      = {.msk = 0x7FFF0000U, .pos = 16};   /** @brief Own addresses configuration the OAR bits are set by software to select which destination logical addresses has to be considered in receive mode. Each bit, when set, enables the CEC logical address identified by the given bit position. At the end of HEADER reception, the received destination address is compared with the enabled addresses. In case of matching address, the incoming message is acknowledged and received. In case of non-matching address, the incoming message is received only in listen mode (LSTN=1), but without acknowledge sent. Broadcast messages are always received. Example: OAR = 0b000 0000 0010 0001 means that CEC acknowledges addresses 0x0 and 0x5. Consequently, each message directed to one of these addresses is received. */
  static const field32_t CEC_CFGR_LSTN     = {.msk = 0x80000000U, .pos = 31};   /** @brief Listen mode LSTN bit is set and cleared by software. */
  static const field32_t CEC_TXDR_TXD      = {.msk = 0x000000FFU, .pos = 0};    /** @brief Tx data register. TXD is a write-only register containing the data byte to be transmitted. Note: TXD must be written when TXSTART=1. */
  static const field32_t CEC_RXDR_RXD      = {.msk = 0x000000FFU, .pos = 0};    /** @brief Rx data register. RXD is read-only and contains the last data byte which has been received from the CEC line. */
  static const field32_t CEC_ISR_RXBR      = {.msk = 0x00000001U, .pos = 0};    /** @brief Rx-Byte received the RXBR bit is set by hardware to inform application that a new byte has been received from the CEC line and stored into the RXD buffer. RXBR is cleared by software write at 1. */
  static const field32_t CEC_ISR_RXEND     = {.msk = 0x00000002U, .pos = 1};    /** @brief End of reception RXEND is set by hardware to inform application that the last byte of a CEC message is received from the CEC line and stored into the RXD buffer. RXEND is set at the same time of RXBR. RXEND is cleared by software write at 1. */
  static const field32_t CEC_ISR_RXOVR     = {.msk = 0x00000004U, .pos = 2};    /** @brief Rx-Overrun RXOVR is set by hardware if RXBR is not yet cleared at the time a new byte is received on the CEC line and stored into RXD. RXOVR assertion stops message reception so that no acknowledge is sent. In case of broadcast, a negative acknowledge is sent. RXOVR is cleared by software write at 1. */
  static const field32_t CEC_ISR_BRE       = {.msk = 0x00000008U, .pos = 3};    /** @brief Rx-Bit rising error BRE is set by hardware in case a data-bit waveform is detected with bit rising error. BRE is set either at the time the misplaced rising edge occurs, or at the end of the maximum BRE tolerance allowed by RXTOL, in case rising edge is still longing. BRE stops message reception if BRESTP=1. BRE generates an error-bit on the CEC line if BREGEN=1. BRE is cleared by software write at 1. */
  static const field32_t CEC_ISR_SBPE      = {.msk = 0x00000010U, .pos = 4};    /** @brief Rx-Short bit period error SBPE is set by hardware in case a data-bit waveform is detected with short bit period error. SBPE is set at the time the anticipated falling edge occurs. SBPE generates an error-bit on the CEC line. SBPE is cleared by software write at 1. */
  static const field32_t CEC_ISR_LBPE      = {.msk = 0x00000020U, .pos = 5};    /** @brief Rx-Long bit period error LBPE is set by hardware in case a data-bit waveform is detected with long bit period error. LBPE is set at the end of the maximum bit-extension tolerance allowed by RXTOL, in case falling edge is still longing. LBPE always stops reception of the CEC message. LBPE generates an error-bit on the CEC line if LBPEGEN=1. In case of broadcast, error-bit is generated even in case of LBPEGEN=0. LBPE is cleared by software write at 1. */
  static const field32_t CEC_ISR_RXACKE    = {.msk = 0x00000040U, .pos = 6};    /** @brief Rx-Missing acknowledge in receive mode, RXACKE is set by hardware to inform application that no acknowledge was seen on the CEC line. RXACKE applies only for broadcast messages and in listen mode also for not directly addressed messages (destination address not enabled in OAR). RXACKE aborts message reception. RXACKE is cleared by software write at 1. */
  static const field32_t CEC_ISR_ARBLST    = {.msk = 0x00000080U, .pos = 7};    /** @brief Arbitration lost ARBLST is set by hardware to inform application that CEC device is switching to reception due to arbitration lost event following the TXSOM command. ARBLST can be due either to a contending CEC device starting earlier or starting at the same time but with higher HEADER priority. After ARBLST assertion TXSOM bit keeps pending for next transmission attempt. ARBLST is cleared by software write at 1. */
  static const field32_t CEC_ISR_TXBR      = {.msk = 0x00000100U, .pos = 8};    /** @brief Tx-Byte request TXBR is set by hardware to inform application that the next transmission data has to be written to TXDR. TXBR is set when the 4th bit of currently transmitted byte is sent. Application must write the next byte to TXDR within 6 nominal data-bit periods before transmission underrun error occurs (TXUDR). TXBR is cleared by software write at 1. */
  static const field32_t CEC_ISR_TXEND     = {.msk = 0x00000200U, .pos = 9};    /** @brief End of transmission TXEND is set by hardware to inform application that the last byte of the CEC message has been successfully transmitted. TXEND clears the TXSOM and TXEOM control bits. TXEND is cleared by software write at 1. */
  static const field32_t CEC_ISR_TXUDR     = {.msk = 0x00000400U, .pos = 10};   /** @brief Tx-Buffer underrun in transmission mode, TXUDR is set by hardware if application was not in time to load TXDR before of next byte transmission. TXUDR aborts message transmission and clears TXSOM and TXEOM control bits. TXUDR is cleared by software write at 1. */
  static const field32_t CEC_ISR_TXERR     = {.msk = 0x00000800U, .pos = 11};   /** @brief Tx-Error in transmission mode, TXERR is set by hardware if the CEC initiator detects low impedance on the CEC line while it is released. TXERR aborts message transmission and clears TXSOM and TXEOM controls. TXERR is cleared by software write at 1. */
  static const field32_t CEC_ISR_TXACKE    = {.msk = 0x00001000U, .pos = 12};   /** @brief Tx-Missing acknowledge error in transmission mode, TXACKE is set by hardware to inform application that no acknowledge was received. In case of broadcast transmission, TXACKE informs application that a negative acknowledge was received. TXACKE aborts message transmission and clears TXSOM and TXEOM controls. TXACKE is cleared by software write at 1. */
  static const field32_t CEC_IER_RXBRIE    = {.msk = 0x00000001U, .pos = 0};    /** @brief Rx-Byte received interrupt enable the RXBRIE bit is set and cleared by software. */
  static const field32_t CEC_IER_RXENDIE   = {.msk = 0x00000002U, .pos = 1};    /** @brief End of reception interrupt enable the RXENDIE bit is set and cleared by software. */
  static const field32_t CEC_IER_RXOVRIE   = {.msk = 0x00000004U, .pos = 2};    /** @brief Rx-Buffer overrun interrupt enable the RXOVRIE bit is set and cleared by software. */
  static const field32_t CEC_IER_BREIE     = {.msk = 0x00000008U, .pos = 3};    /** @brief Bit rising error interrupt enable the BREIE bit is set and cleared by software. */
  static const field32_t CEC_IER_SBPEIE    = {.msk = 0x00000010U, .pos = 4};    /** @brief Short bit period error interrupt enable the SBPEIE bit is set and cleared by software. */
  static const field32_t CEC_IER_LBPEIE    = {.msk = 0x00000020U, .pos = 5};    /** @brief Long bit period error interrupt enable the LBPEIE bit is set and cleared by software. */
  static const field32_t CEC_IER_RXACKIE   = {.msk = 0x00000040U, .pos = 6};    /** @brief Rx-Missing acknowledge error interrupt enable the RXACKIE bit is set and cleared by software. */
  static const field32_t CEC_IER_ARBLSTIE  = {.msk = 0x00000080U, .pos = 7};    /** @brief Arbitration lost interrupt enable the ARBLSTIE bit is set and cleared by software. */
  static const field32_t CEC_IER_TXBRIE    = {.msk = 0x00000100U, .pos = 8};    /** @brief Tx-Byte request interrupt enable the TXBRIE bit is set and cleared by software. */
  static const field32_t CEC_IER_TXENDIE   = {.msk = 0x00000200U, .pos = 9};    /** @brief Tx-End of message interrupt enable the TXENDIE bit is set and cleared by software. */
  static const field32_t CEC_IER_TXUDRIE   = {.msk = 0x00000400U, .pos = 10};   /** @brief Tx-Underrun interrupt enable the TXUDRIE bit is set and cleared by software. */
  static const field32_t CEC_IER_TXERRIE   = {.msk = 0x00000800U, .pos = 11};   /** @brief Tx-Error interrupt enable the TXERRIE bit is set and cleared by software. */
  static const field32_t CEC_IER_TXACKIE   = {.msk = 0x00001000U, .pos = 12};   /** @brief Tx-Missing acknowledge error interrupt enable the TXACKEIE bit is set and cleared by software. */

  /************************************************************************************************
   * HSEM Definitions
   ************************************************************************************************/

  /**** HSEM Register Definitions ****/

  static const rw_reg32_t HSEM_IER  = (rw_reg32_t)0x58026500U;   /** @brief HSEM interrupt enable register. */
  static const ro_reg32_t HSEM_ICR  = (ro_reg32_t)0x58026504U;   /** @brief HSEM interrupt clear register. */
  static const ro_reg32_t HSEM_ISR  = (ro_reg32_t)0x58026508U;   /** @brief HSEM interrupt status register. */
  static const ro_reg32_t HSEM_MISR = (ro_reg32_t)0x5802650CU;   /** @brief HSEM masked interrupt status register. */
  static const rw_reg32_t HSEM_CR   = (rw_reg32_t)0x58026540U;   /** @brief HSEM clear register. */
  static const rw_reg32_t HSEM_KEYR = (rw_reg32_t)0x58026544U;   /** @brief HSEM interrupt clear register. */

  /**** Enumerated HSEM Register Definitions ****/

  static const rw_reg32_t HSEM_Rx[32] = {
    [0]  = (rw_reg32_t)0x58026400U,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [1]  = (rw_reg32_t)0x58026404U,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [2]  = (rw_reg32_t)0x58026408U,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [3]  = (rw_reg32_t)0x5802640CU,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [4]  = (rw_reg32_t)0x58026410U,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [5]  = (rw_reg32_t)0x58026414U,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [6]  = (rw_reg32_t)0x58026418U,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [7]  = (rw_reg32_t)0x5802641CU,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [8]  = (rw_reg32_t)0x58026420U,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [9]  = (rw_reg32_t)0x58026424U,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [10] = (rw_reg32_t)0x58026428U,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [11] = (rw_reg32_t)0x5802642CU,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [12] = (rw_reg32_t)0x58026430U,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [13] = (rw_reg32_t)0x58026434U,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [14] = (rw_reg32_t)0x58026438U,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [15] = (rw_reg32_t)0x5802643CU,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [16] = (rw_reg32_t)0x58026440U,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [17] = (rw_reg32_t)0x58026444U,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [18] = (rw_reg32_t)0x58026448U,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [19] = (rw_reg32_t)0x5802644CU,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [20] = (rw_reg32_t)0x58026450U,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [21] = (rw_reg32_t)0x58026454U,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [22] = (rw_reg32_t)0x58026458U,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [23] = (rw_reg32_t)0x5802645CU,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [24] = (rw_reg32_t)0x58026460U,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [25] = (rw_reg32_t)0x58026464U,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [26] = (rw_reg32_t)0x58026468U,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [27] = (rw_reg32_t)0x5802646CU,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [28] = (rw_reg32_t)0x58026470U,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [29] = (rw_reg32_t)0x58026474U,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [30] = (rw_reg32_t)0x58026478U,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
    [31] = (rw_reg32_t)0x5802647CU,   /** @brief HSEM register HSEM_R0 HSEM_R31. */
  };

  static const ro_reg32_t HSEM_RLRx[32] = {
    [0]  = (ro_reg32_t)0x58026480U,   /** @brief HSEM read lock register. */
    [1]  = (ro_reg32_t)0x58026484U,   /** @brief HSEM read lock register. */
    [2]  = (ro_reg32_t)0x58026488U,   /** @brief HSEM read lock register. */
    [3]  = (ro_reg32_t)0x5802648CU,   /** @brief HSEM read lock register. */
    [4]  = (ro_reg32_t)0x58026490U,   /** @brief HSEM read lock register. */
    [5]  = (ro_reg32_t)0x58026494U,   /** @brief HSEM read lock register. */
    [6]  = (ro_reg32_t)0x58026498U,   /** @brief HSEM read lock register. */
    [7]  = (ro_reg32_t)0x5802649CU,   /** @brief HSEM read lock register. */
    [8]  = (ro_reg32_t)0x580264A0U,   /** @brief HSEM read lock register. */
    [9]  = (ro_reg32_t)0x580264A4U,   /** @brief HSEM read lock register. */
    [10] = (ro_reg32_t)0x580264A8U,   /** @brief HSEM read lock register. */
    [11] = (ro_reg32_t)0x580264ACU,   /** @brief HSEM read lock register. */
    [12] = (ro_reg32_t)0x580264B0U,   /** @brief HSEM read lock register. */
    [13] = (ro_reg32_t)0x580264B4U,   /** @brief HSEM read lock register. */
    [14] = (ro_reg32_t)0x580264B8U,   /** @brief HSEM read lock register. */
    [15] = (ro_reg32_t)0x580264BCU,   /** @brief HSEM read lock register. */
    [16] = (ro_reg32_t)0x580264C0U,   /** @brief HSEM read lock register. */
    [17] = (ro_reg32_t)0x580264C4U,   /** @brief HSEM read lock register. */
    [18] = (ro_reg32_t)0x580264C8U,   /** @brief HSEM read lock register. */
    [19] = (ro_reg32_t)0x580264CCU,   /** @brief HSEM read lock register. */
    [20] = (ro_reg32_t)0x580264D0U,   /** @brief HSEM read lock register. */
    [21] = (ro_reg32_t)0x580264D4U,   /** @brief HSEM read lock register. */
    [22] = (ro_reg32_t)0x580264D8U,   /** @brief HSEM read lock register. */
    [23] = (ro_reg32_t)0x580264DCU,   /** @brief HSEM read lock register. */
    [24] = (ro_reg32_t)0x580264E0U,   /** @brief HSEM read lock register. */
    [25] = (ro_reg32_t)0x580264E4U,   /** @brief HSEM read lock register. */
    [26] = (ro_reg32_t)0x580264E8U,   /** @brief HSEM read lock register. */
    [27] = (ro_reg32_t)0x580264ECU,   /** @brief HSEM read lock register. */
    [28] = (ro_reg32_t)0x580264F0U,   /** @brief HSEM read lock register. */
    [29] = (ro_reg32_t)0x580264F4U,   /** @brief HSEM read lock register. */
    [30] = (ro_reg32_t)0x580264F8U,   /** @brief HSEM read lock register. */
    [31] = (ro_reg32_t)0x580264FCU,   /** @brief HSEM read lock register. */
  };

  /**** HSEM Register Field Definitions ****/

  static const field32_t HSEM_Rx_PROCID     = {.msk = 0x000000FFU, .pos = 0};    /** @brief Semaphore processid. */
  static const field32_t HSEM_Rx_COREID     = {.msk = 0x00000F00U, .pos = 8};    /** @brief Semaphore core id. */
  static const field32_t HSEM_Rx_LOCK       = {.msk = 0x80000000U, .pos = 31};   /** @brief Lock indication. */
  static const field32_t HSEM_RLRx_PROCID   = {.msk = 0x000000FFU, .pos = 0};    /** @brief Semaphore processid. */
  static const field32_t HSEM_RLRx_COREID   = {.msk = 0x00000F00U, .pos = 8};    /** @brief Semaphore core id. */
  static const field32_t HSEM_RLRx_LOCK     = {.msk = 0x80000000U, .pos = 31};   /** @brief Lock indication. */
  static const field32_t HSEM_CR_COREID     = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Core ID of semaphores to be cleared. */
  static const field32_t HSEM_CR_KEY        = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief Semaphore clear key. */
  static const field32_t HSEM_KEYR_KEY      = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief Semaphore clear key. */

  /**** Enumerated HSEM Register Field Definitions ****/

  static field32_t const HSEM_IER_ISEMx[32] = {
    [0]  = {.msk = 0x00000001U, .pos = 0},    /** @brief Interrupt semaphore n enable bit. */
    [1]  = {.msk = 0x00000002U, .pos = 1},    /** @brief Interrupt semaphore n enable bit. */
    [2]  = {.msk = 0x00000004U, .pos = 2},    /** @brief Interrupt semaphore n enable bit. */
    [3]  = {.msk = 0x00000008U, .pos = 3},    /** @brief Interrupt semaphore n enable bit. */
    [4]  = {.msk = 0x00000010U, .pos = 4},    /** @brief Interrupt semaphore n enable bit. */
    [5]  = {.msk = 0x00000020U, .pos = 5},    /** @brief Interrupt semaphore n enable bit. */
    [6]  = {.msk = 0x00000040U, .pos = 6},    /** @brief Interrupt semaphore n enable bit. */
    [7]  = {.msk = 0x00000080U, .pos = 7},    /** @brief Interrupt semaphore n enable bit. */
    [8]  = {.msk = 0x00000100U, .pos = 8},    /** @brief Interrupt semaphore n enable bit. */
    [9]  = {.msk = 0x00000200U, .pos = 9},    /** @brief Interrupt semaphore n enable bit. */
    [10] = {.msk = 0x00000400U, .pos = 10},   /** @brief Interrupt semaphore n enable bit. */
    [11] = {.msk = 0x00000800U, .pos = 11},   /** @brief Interrupt semaphore n enable bit. */
    [12] = {.msk = 0x00001000U, .pos = 12},   /** @brief Interrupt semaphore n enable bit. */
    [13] = {.msk = 0x00002000U, .pos = 13},   /** @brief Interrupt semaphore n enable bit. */
    [14] = {.msk = 0x00004000U, .pos = 14},   /** @brief Interrupt semaphore n enable bit. */
    [15] = {.msk = 0x00008000U, .pos = 15},   /** @brief Interrupt semaphore n enable bit. */
    [16] = {.msk = 0x00010000U, .pos = 16},   /** @brief Interrupt semaphore n enable bit. */
    [17] = {.msk = 0x00020000U, .pos = 17},   /** @brief Interrupt semaphore n enable bit. */
    [18] = {.msk = 0x00040000U, .pos = 18},   /** @brief Interrupt semaphore n enable bit. */
    [19] = {.msk = 0x00080000U, .pos = 19},   /** @brief Interrupt semaphore n enable bit. */
    [20] = {.msk = 0x00100000U, .pos = 20},   /** @brief Interrupt semaphore n enable bit. */
    [21] = {.msk = 0x00200000U, .pos = 21},   /** @brief Interrupt semaphore n enable bit. */
    [22] = {.msk = 0x00400000U, .pos = 22},   /** @brief Interrupt semaphore n enable bit. */
    [23] = {.msk = 0x00800000U, .pos = 23},   /** @brief Interrupt semaphore n enable bit. */
    [24] = {.msk = 0x01000000U, .pos = 24},   /** @brief Interrupt semaphore n enable bit. */
    [25] = {.msk = 0x02000000U, .pos = 25},   /** @brief Interrupt semaphore n enable bit. */
    [26] = {.msk = 0x04000000U, .pos = 26},   /** @brief Interrupt semaphore n enable bit. */
    [27] = {.msk = 0x08000000U, .pos = 27},   /** @brief Interrupt semaphore n enable bit. */
    [28] = {.msk = 0x10000000U, .pos = 28},   /** @brief Interrupt semaphore n enable bit. */
    [29] = {.msk = 0x20000000U, .pos = 29},   /** @brief Interrupt semaphore n enable bit. */
    [30] = {.msk = 0x40000000U, .pos = 30},   /** @brief Interrupt semaphore n enable bit. */
    [31] = {.msk = 0x80000000U, .pos = 31},   /** @brief Interrupt(N) semaphore n enable bit. */
  };

  /************************************************************************************************
   * I2Cx Definitions
   ************************************************************************************************/

  /**** Enumerated I2Cx Register Definitions ****/

  static const rw_reg32_t I2Cx_CRx[5][3] = {
    [1] = {
      [1] = (rw_reg32_t)0x40005400U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [2] = (rw_reg32_t)0x40005404U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    },
    [2] = {
      [1] = (rw_reg32_t)0x40005800U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [2] = (rw_reg32_t)0x40005804U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    },
    [3] = {
      [1] = (rw_reg32_t)0x40005C00U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [2] = (rw_reg32_t)0x40005C04U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    },
    [4] = {
      [1] = (rw_reg32_t)0x58001C00U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [2] = (rw_reg32_t)0x58001C04U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    },
  };

  static const rw_reg32_t I2Cx_OARx[5][3] = {
    [1] = {
      [1] = (rw_reg32_t)0x40005408U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [2] = (rw_reg32_t)0x4000540CU,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    },
    [2] = {
      [1] = (rw_reg32_t)0x40005808U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [2] = (rw_reg32_t)0x4000580CU,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    },
    [3] = {
      [1] = (rw_reg32_t)0x40005C08U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [2] = (rw_reg32_t)0x40005C0CU,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    },
    [4] = {
      [1] = (rw_reg32_t)0x58001C08U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [2] = (rw_reg32_t)0x58001C0CU,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    },
  };

  static const rw_reg32_t I2Cx_TIMINGR[5] = {
    [1] = (rw_reg32_t)0x40005410U,   /** @brief Access: no wait states. */
    [2] = (rw_reg32_t)0x40005810U,   /** @brief Access: no wait states. */
    [3] = (rw_reg32_t)0x40005C10U,   /** @brief Access: no wait states. */
    [4] = (rw_reg32_t)0x58001C10U,   /** @brief Access: no wait states. */
  };

  static const rw_reg32_t I2Cx_TIMEOUTR[5] = {
    [1] = (rw_reg32_t)0x40005414U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    [2] = (rw_reg32_t)0x40005814U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    [3] = (rw_reg32_t)0x40005C14U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    [4] = (rw_reg32_t)0x58001C14U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
  };

  static const rw_reg32_t I2Cx_ISR[5] = {
    [1] = (rw_reg32_t)0x40005418U,   /** @brief Access: no wait states. */
    [2] = (rw_reg32_t)0x40005818U,   /** @brief Access: no wait states. */
    [3] = (rw_reg32_t)0x40005C18U,   /** @brief Access: no wait states. */
    [4] = (rw_reg32_t)0x58001C18U,   /** @brief Access: no wait states. */
  };

  static const rw_reg32_t I2Cx_ICR[5] = {
    [1] = (rw_reg32_t)0x4000541CU,   /** @brief Access: no wait states. */
    [2] = (rw_reg32_t)0x4000581CU,   /** @brief Access: no wait states. */
    [3] = (rw_reg32_t)0x40005C1CU,   /** @brief Access: no wait states. */
    [4] = (rw_reg32_t)0x58001C1CU,   /** @brief Access: no wait states. */
  };

  static const ro_reg32_t I2Cx_PECR[5] = {
    [1] = (ro_reg32_t)0x40005420U,   /** @brief Access: no wait states. */
    [2] = (ro_reg32_t)0x40005820U,   /** @brief Access: no wait states. */
    [3] = (ro_reg32_t)0x40005C20U,   /** @brief Access: no wait states. */
    [4] = (ro_reg32_t)0x58001C20U,   /** @brief Access: no wait states. */
  };

  static const ro_reg32_t I2Cx_RXDR[5] = {
    [1] = (ro_reg32_t)0x40005424U,   /** @brief Access: no wait states. */
    [2] = (ro_reg32_t)0x40005824U,   /** @brief Access: no wait states. */
    [3] = (ro_reg32_t)0x40005C24U,   /** @brief Access: no wait states. */
    [4] = (ro_reg32_t)0x58001C24U,   /** @brief Access: no wait states. */
  };

  static const rw_reg32_t I2Cx_TXDR[5] = {
    [1] = (rw_reg32_t)0x40005428U,   /** @brief Access: no wait states. */
    [2] = (rw_reg32_t)0x40005828U,   /** @brief Access: no wait states. */
    [3] = (rw_reg32_t)0x40005C28U,   /** @brief Access: no wait states. */
    [4] = (rw_reg32_t)0x58001C28U,   /** @brief Access: no wait states. */
  };

  /**** I2Cx Register Field Definitions ****/

  static const field32_t I2Cx_CRx_PE            = {.msk = 0x00000001U, .pos = 0};    /** @brief Peripheral enable note: when PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles. */
  static const field32_t I2Cx_CRx_TXIE          = {.msk = 0x00000002U, .pos = 1};    /** @brief TX interrupt enable. */
  static const field32_t I2Cx_CRx_RXIE          = {.msk = 0x00000004U, .pos = 2};    /** @brief RX interrupt enable. */
  static const field32_t I2Cx_CRx_ADDRIE        = {.msk = 0x00000008U, .pos = 3};    /** @brief Address match interrupt enable (slave only). */
  static const field32_t I2Cx_CRx_NACKIE        = {.msk = 0x00000010U, .pos = 4};    /** @brief Not acknowledge received interrupt enable. */
  static const field32_t I2Cx_CRx_STOPIE        = {.msk = 0x00000020U, .pos = 5};    /** @brief STOP detection interrupt enable. */
  static const field32_t I2Cx_CRx_TCIE          = {.msk = 0x00000040U, .pos = 6};    /** @brief Transfer complete interrupt enable note: any of these events will generate an interrupt: transfer complete (TC) transfer complete reload (TCR). */
  static const field32_t I2Cx_CRx_ERRIE         = {.msk = 0x00000080U, .pos = 7};    /** @brief Error interrupts enable note: any of these errors generate an interrupt: arbitration loss (ARLO) bus error detection (BERR) overrun/underrun (OVR) timeout detection (TIMEOUT) PEC error detection (PECERR) alert pin event detection (ALERT). */
  static const field32_t I2Cx_CRx_DNF           = {.msk = 0x00000F00U, .pos = 8};    /** @brief Digital noise filter these bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF[3:0] * ti2cclk ... Note: if the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0). */
  static const field32_t I2Cx_CRx_ANFOFF        = {.msk = 0x00001000U, .pos = 12};   /** @brief Analog noise filter OFF note: this bit can only be programmed when the I2C is disabled (PE = 0). */
  static const field32_t I2Cx_CRx_TXDMAEN       = {.msk = 0x00004000U, .pos = 14};   /** @brief DMA transmission requests enable. */
  static const field32_t I2Cx_CRx_RXDMAEN       = {.msk = 0x00008000U, .pos = 15};   /** @brief DMA reception requests enable. */
  static const field32_t I2Cx_CRx_SBC           = {.msk = 0x00010000U, .pos = 16};   /** @brief Slave byte control this bit is used to enable hardware byte control in slave mode. */
  static const field32_t I2Cx_CRx_NOSTRETCH     = {.msk = 0x00020000U, .pos = 17};   /** @brief Clock stretching disable this bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: this bit can only be programmed when the I2C is disabled (PE = 0). */
  static const field32_t I2Cx_CRx_WUPEN         = {.msk = 0x00040000U, .pos = 18};   /** @brief Wakeup from stop mode enable note: if the wakeup from stop mode feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. Note: WUPEN can be set only when DNF = 0000. */
  static const field32_t I2Cx_CRx_GCEN          = {.msk = 0x00080000U, .pos = 19};   /** @brief General call enable. */
  static const field32_t I2Cx_CRx_SMBHEN        = {.msk = 0x00100000U, .pos = 20};   /** @brief SMBus host address enable note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const field32_t I2Cx_CRx_SMBDEN        = {.msk = 0x00200000U, .pos = 21};   /** @brief SMBus device default address enable note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const field32_t I2Cx_CRx_ALERTEN       = {.msk = 0x00400000U, .pos = 22};   /** @brief SMBus alert enable device mode (SMBHEN=0): host mode (SMBHEN=1): note: when ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const field32_t I2Cx_CRx_PECEN         = {.msk = 0x00800000U, .pos = 23};   /** @brief PEC enable note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const field32_t I2Cx_OARx_OA1          = {.msk = 0x000003FFU, .pos = 0};    /** @brief Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bits 9:8 of address note: these bits can be written only when OA1EN=0. OA1[7:1]: interface address bits 7:1 of address note: these bits can be written only when OA1EN=0. OA1[0]: interface address 7-bit addressing mode: dont care 10-bit addressing mode: bit 0 of address note: this bit can be written only when OA1EN=0. */
  static const field32_t I2Cx_OARx_OA1MODE      = {.msk = 0x00000400U, .pos = 10};   /** @brief Own address 1 10-bit mode note: this bit can be written only when OA1EN=0. */
  static const field32_t I2Cx_OARx_OA1EN        = {.msk = 0x00008000U, .pos = 15};   /** @brief Own address 1 enable. */
  static const field32_t I2Cx_TIMINGR_SCLL      = {.msk = 0x000000FFU, .pos = 0};    /** @brief SCL low period (master mode) this field is used to generate the SCL low period in master mode. TSCLL = (SCLL+1) x tpresc note: SCLL is also used to generate tbuf and tsu:sta timings. */
  static const field32_t I2Cx_TIMINGR_SCLH      = {.msk = 0x0000FF00U, .pos = 8};    /** @brief SCL high period (master mode) this field is used to generate the SCL high period in master mode. TSCLH = (SCLH+1) x tpresc note: SCLH is also used to generate tsu:sto and thd:sta timing. */
  static const field32_t I2Cx_TIMINGR_SDADEL    = {.msk = 0x000F0000U, .pos = 16};   /** @brief Data hold time this field is used to generate the delay tsdadel between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tsdadel. TSDADEL= SDADEL x tpresc note: SDADEL is used to generate thd:dat timing. */
  static const field32_t I2Cx_TIMINGR_SCLDEL    = {.msk = 0x00F00000U, .pos = 20};   /** @brief Data setup time this field is used to generate a delay tscldel between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tscldel. TSCLDEL = (SCLDEL+1) x tpresc note: tscldel is used to generate tsu:dat timing. */
  static const field32_t I2Cx_TIMINGR_PRESC     = {.msk = 0xF0000000U, .pos = 28};   /** @brief Timing prescaler this field is used to prescale I2CCLK in order to generate the clock period tpresc used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). TPRESC = (PRESC+1) x ti2cclk. */
  static const field32_t I2Cx_TIMEOUTR_TIMEOUTA = {.msk = 0x00000FFFU, .pos = 0};    /** @brief Bus timeout A this field is used to configure: the SCL low timeout condition ttimeout when TIDLE=0 ttimeout= (TIMEOUTA+1) x 2048 x ti2cclk the bus idle condition (both SCL and SDA high) when TIDLE=1 tidle= (TIMEOUTA+1) x 4 x ti2cclk note: these bits can be written only when TIMOUTEN=0. */
  static const field32_t I2Cx_TIMEOUTR_TIDLE    = {.msk = 0x00001000U, .pos = 12};   /** @brief Idle clock timeout detection note: this bit can be written only when TIMOUTEN=0. */
  static const field32_t I2Cx_TIMEOUTR_TIMOUTEN = {.msk = 0x00008000U, .pos = 15};   /** @brief Clock timeout enable. */
  static const field32_t I2Cx_TIMEOUTR_TIMEOUTB = {.msk = 0x0FFF0000U, .pos = 16};   /** @brief Bus timeout B this field is used to configure the cumulative clock extension timeout: in master mode, the master cumulative clock low extend time (tlow:mext) is detected in slave mode, the slave cumulative clock low extend time (tlow:sext) is detected tlow:ext= (TIMEOUTB+1) x 2048 x ti2cclk note: these bits can be written only when TEXTEN=0. */
  static const field32_t I2Cx_TIMEOUTR_TEXTEN   = {.msk = 0x80000000U, .pos = 31};   /** @brief Extended clock timeout enable. */
  static const field32_t I2Cx_ISR_TXE           = {.msk = 0x00000001U, .pos = 0};    /** @brief Transmit data register empty (transmitters) this bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR. Note: this bit is set by hardware when PE=0. */
  static const field32_t I2Cx_ISR_TXIS          = {.msk = 0x00000002U, .pos = 1};    /** @brief Transmit interrupt status (transmitters) this bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software when NOSTRETCH=1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN=1). Note: this bit is cleared by hardware when PE=0. */
  static const field32_t I2Cx_ISR_RXNE          = {.msk = 0x00000004U, .pos = 2};    /** @brief Receive data register not empty (receivers) this bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. Note: this bit is cleared by hardware when PE=0. */
  static const field32_t I2Cx_ISR_ADDR          = {.msk = 0x00000008U, .pos = 3};    /** @brief Address matched (slave mode) this bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit. Note: this bit is cleared by hardware when PE=0. */
  static const field32_t I2Cx_ISR_NACKF         = {.msk = 0x00000010U, .pos = 4};    /** @brief Not acknowledge received flag this flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit. Note: this bit is cleared by hardware when PE=0. */
  static const field32_t I2Cx_ISR_STOPF         = {.msk = 0x00000020U, .pos = 5};    /** @brief Stop detection flag this flag is set by hardware when a stop condition is detected on the bus and the peripheral is involved in this transfer: either as a master, provided that the STOP condition is generated by the peripheral. Or as a slave, provided that the peripheral has been addressed previously during this transfer. It is cleared by software by setting the STOPCF bit. Note: this bit is cleared by hardware when PE=0. */
  static const field32_t I2Cx_ISR_TC            = {.msk = 0x00000040U, .pos = 6};    /** @brief Transfer complete (master mode) this flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set. Note: this bit is cleared by hardware when PE=0. */
  static const field32_t I2Cx_ISR_TCR           = {.msk = 0x00000080U, .pos = 7};    /** @brief Transfer complete reload this flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value. Note: this bit is cleared by hardware when PE=0. This flag is only for master mode, or for slave mode when the SBC bit is set. */
  static const field32_t I2Cx_ISR_BERR          = {.msk = 0x00000100U, .pos = 8};    /** @brief Bus error this flag is set by hardware when a misplaced start or stop condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit. Note: this bit is cleared by hardware when PE=0. */
  static const field32_t I2Cx_ISR_ARLO          = {.msk = 0x00000200U, .pos = 9};    /** @brief Arbitration lost this flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit. Note: this bit is cleared by hardware when PE=0. */
  static const field32_t I2Cx_ISR_OVR           = {.msk = 0x00000400U, .pos = 10};   /** @brief Overrun/Underrun (slave mode) this flag is set by hardware in slave mode with NOSTRETCH=1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit. Note: this bit is cleared by hardware when PE=0. */
  static const field32_t I2Cx_ISR_PECERR        = {.msk = 0x00000800U, .pos = 11};   /** @brief PEC error in reception this flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit. Note: this bit is cleared by hardware when PE=0. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const field32_t I2Cx_ISR_TIMEOUT       = {.msk = 0x00001000U, .pos = 12};   /** @brief Timeout or tlow detection flag this flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit. Note: this bit is cleared by hardware when PE=0. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const field32_t I2Cx_ISR_ALERT         = {.msk = 0x00002000U, .pos = 13};   /** @brief SMBus alert this flag is set by hardware when SMBHEN=1 (smbus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit. Note: this bit is cleared by hardware when PE=0. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const field32_t I2Cx_ISR_BUSY          = {.msk = 0x00008000U, .pos = 15};   /** @brief Bus busy this flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a stop condition is detected, or when PE=0. */
  static const field32_t I2Cx_ISR_DIR           = {.msk = 0x00010000U, .pos = 16};   /** @brief Transfer direction (slave mode) this flag is updated when an address match event occurs (ADDR=1). */
  static const field32_t I2Cx_ISR_ADDCODE       = {.msk = 0x00FE0000U, .pos = 17};   /** @brief Address match code (slave mode) these bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 msbs of the address. */
  static const field32_t I2Cx_ICR_ADDRCF        = {.msk = 0x00000008U, .pos = 3};    /** @brief Address matched flag clear writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register. */
  static const field32_t I2Cx_ICR_NACKCF        = {.msk = 0x00000010U, .pos = 4};    /** @brief Not acknowledge flag clear writing 1 to this bit clears the ACKF flag in I2C_ISR register. */
  static const field32_t I2Cx_ICR_STOPCF        = {.msk = 0x00000020U, .pos = 5};    /** @brief Stop detection flag clear writing 1 to this bit clears the STOPF flag in the I2C_ISR register. */
  static const field32_t I2Cx_ICR_BERRCF        = {.msk = 0x00000100U, .pos = 8};    /** @brief Bus error flag clear writing 1 to this bit clears the BERRF flag in the I2C_ISR register. */
  static const field32_t I2Cx_ICR_ARLOCF        = {.msk = 0x00000200U, .pos = 9};    /** @brief Arbitration lost flag clear writing 1 to this bit clears the ARLO flag in the I2C_ISR register. */
  static const field32_t I2Cx_ICR_OVRCF         = {.msk = 0x00000400U, .pos = 10};   /** @brief Overrun/Underrun flag clear writing 1 to this bit clears the OVR flag in the I2C_ISR register. */
  static const field32_t I2Cx_ICR_PECCF         = {.msk = 0x00000800U, .pos = 11};   /** @brief PEC error flag clear writing 1 to this bit clears the PECERR flag in the I2C_ISR register. Note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const field32_t I2Cx_ICR_TIMOUTCF      = {.msk = 0x00001000U, .pos = 12};   /** @brief Timeout detection flag clear writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register. Note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const field32_t I2Cx_ICR_ALERTCF       = {.msk = 0x00002000U, .pos = 13};   /** @brief Alert flag clear writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const field32_t I2Cx_PECR_PEC          = {.msk = 0x000000FFU, .pos = 0};    /** @brief Packet error checking register this field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE=0. */
  static const field32_t I2Cx_RXDR_RXDATA       = {.msk = 0x000000FFU, .pos = 0};    /** @brief 8-bit receive data data byte received from the I2C bus. */
  static const field32_t I2Cx_TXDR_TXDATA       = {.msk = 0x000000FFU, .pos = 0};    /** @brief 8-bit transmit data data byte to be transmitted to the I2C bus. Note: these bits can be written only when TXE=1. */

  /************************************************************************************************
   * GPIOx Definitions
   ************************************************************************************************/

  /**** Enumerated GPIOx Register Definitions ****/

  static const rw_reg32_t GPIOx_MODER[11] = {
    [0]  = (rw_reg32_t)0x58020000U,   /** @brief GPIO port mode register. */
    [1]  = (rw_reg32_t)0x58020400U,   /** @brief GPIO port mode register. */
    [2]  = (rw_reg32_t)0x58020800U,   /** @brief GPIO port mode register. */
    [3]  = (rw_reg32_t)0x58020C00U,   /** @brief GPIO port mode register. */
    [4]  = (rw_reg32_t)0x58021000U,   /** @brief GPIO port mode register. */
    [5]  = (rw_reg32_t)0x58021400U,   /** @brief GPIO port mode register. */
    [6]  = (rw_reg32_t)0x58021800U,   /** @brief GPIO port mode register. */
    [7]  = (rw_reg32_t)0x58021C00U,   /** @brief GPIO port mode register. */
    [8]  = (rw_reg32_t)0x58022000U,   /** @brief GPIO port mode register. */
    [9]  = (rw_reg32_t)0x58022400U,   /** @brief GPIO port mode register. */
    [10] = (rw_reg32_t)0x58022800U,   /** @brief GPIO port mode register. */
  };

  static const rw_reg32_t GPIOx_OTYPER[11] = {
    [0]  = (rw_reg32_t)0x58020004U,   /** @brief GPIO port output type register. */
    [1]  = (rw_reg32_t)0x58020404U,   /** @brief GPIO port output type register. */
    [2]  = (rw_reg32_t)0x58020804U,   /** @brief GPIO port output type register. */
    [3]  = (rw_reg32_t)0x58020C04U,   /** @brief GPIO port output type register. */
    [4]  = (rw_reg32_t)0x58021004U,   /** @brief GPIO port output type register. */
    [5]  = (rw_reg32_t)0x58021404U,   /** @brief GPIO port output type register. */
    [6]  = (rw_reg32_t)0x58021804U,   /** @brief GPIO port output type register. */
    [7]  = (rw_reg32_t)0x58021C04U,   /** @brief GPIO port output type register. */
    [8]  = (rw_reg32_t)0x58022004U,   /** @brief GPIO port output type register. */
    [9]  = (rw_reg32_t)0x58022404U,   /** @brief GPIO port output type register. */
    [10] = (rw_reg32_t)0x58022804U,   /** @brief GPIO port output type register. */
  };

  static const rw_reg32_t GPIOx_OSPEEDR[11] = {
    [0]  = (rw_reg32_t)0x58020008U,   /** @brief GPIO port output speed register. */
    [1]  = (rw_reg32_t)0x58020408U,   /** @brief GPIO port output speed register. */
    [2]  = (rw_reg32_t)0x58020808U,   /** @brief GPIO port output speed register. */
    [3]  = (rw_reg32_t)0x58020C08U,   /** @brief GPIO port output speed register. */
    [4]  = (rw_reg32_t)0x58021008U,   /** @brief GPIO port output speed register. */
    [5]  = (rw_reg32_t)0x58021408U,   /** @brief GPIO port output speed register. */
    [6]  = (rw_reg32_t)0x58021808U,   /** @brief GPIO port output speed register. */
    [7]  = (rw_reg32_t)0x58021C08U,   /** @brief GPIO port output speed register. */
    [8]  = (rw_reg32_t)0x58022008U,   /** @brief GPIO port output speed register. */
    [9]  = (rw_reg32_t)0x58022408U,   /** @brief GPIO port output speed register. */
    [10] = (rw_reg32_t)0x58022808U,   /** @brief GPIO port output speed register. */
  };

  static const rw_reg32_t GPIOx_PUPDR[11] = {
    [0]  = (rw_reg32_t)0x5802000CU,   /** @brief GPIO port pull-up/pull-down register. */
    [1]  = (rw_reg32_t)0x5802040CU,   /** @brief GPIO port pull-up/pull-down register. */
    [2]  = (rw_reg32_t)0x5802080CU,   /** @brief GPIO port pull-up/pull-down register. */
    [3]  = (rw_reg32_t)0x58020C0CU,   /** @brief GPIO port pull-up/pull-down register. */
    [4]  = (rw_reg32_t)0x5802100CU,   /** @brief GPIO port pull-up/pull-down register. */
    [5]  = (rw_reg32_t)0x5802140CU,   /** @brief GPIO port pull-up/pull-down register. */
    [6]  = (rw_reg32_t)0x5802180CU,   /** @brief GPIO port pull-up/pull-down register. */
    [7]  = (rw_reg32_t)0x58021C0CU,   /** @brief GPIO port pull-up/pull-down register. */
    [8]  = (rw_reg32_t)0x5802200CU,   /** @brief GPIO port pull-up/pull-down register. */
    [9]  = (rw_reg32_t)0x5802240CU,   /** @brief GPIO port pull-up/pull-down register. */
    [10] = (rw_reg32_t)0x5802280CU,   /** @brief GPIO port pull-up/pull-down register. */
  };

  static const ro_reg32_t GPIOx_IDR[11] = {
    [0]  = (ro_reg32_t)0x58020010U,   /** @brief GPIO port input data register. */
    [1]  = (ro_reg32_t)0x58020410U,   /** @brief GPIO port input data register. */
    [2]  = (ro_reg32_t)0x58020810U,   /** @brief GPIO port input data register. */
    [3]  = (ro_reg32_t)0x58020C10U,   /** @brief GPIO port input data register. */
    [4]  = (ro_reg32_t)0x58021010U,   /** @brief GPIO port input data register. */
    [5]  = (ro_reg32_t)0x58021410U,   /** @brief GPIO port input data register. */
    [6]  = (ro_reg32_t)0x58021810U,   /** @brief GPIO port input data register. */
    [7]  = (ro_reg32_t)0x58021C10U,   /** @brief GPIO port input data register. */
    [8]  = (ro_reg32_t)0x58022010U,   /** @brief GPIO port input data register. */
    [9]  = (ro_reg32_t)0x58022410U,   /** @brief GPIO port input data register. */
    [10] = (ro_reg32_t)0x58022810U,   /** @brief GPIO port input data register. */
  };

  static const rw_reg32_t GPIOx_ODR[11] = {
    [0]  = (rw_reg32_t)0x58020014U,   /** @brief GPIO port output data register. */
    [1]  = (rw_reg32_t)0x58020414U,   /** @brief GPIO port output data register. */
    [2]  = (rw_reg32_t)0x58020814U,   /** @brief GPIO port output data register. */
    [3]  = (rw_reg32_t)0x58020C14U,   /** @brief GPIO port output data register. */
    [4]  = (rw_reg32_t)0x58021014U,   /** @brief GPIO port output data register. */
    [5]  = (rw_reg32_t)0x58021414U,   /** @brief GPIO port output data register. */
    [6]  = (rw_reg32_t)0x58021814U,   /** @brief GPIO port output data register. */
    [7]  = (rw_reg32_t)0x58021C14U,   /** @brief GPIO port output data register. */
    [8]  = (rw_reg32_t)0x58022014U,   /** @brief GPIO port output data register. */
    [9]  = (rw_reg32_t)0x58022414U,   /** @brief GPIO port output data register. */
    [10] = (rw_reg32_t)0x58022814U,   /** @brief GPIO port output data register. */
  };

  static const rw_reg32_t GPIOx_BSRR[11] = {
    [0]  = (rw_reg32_t)0x58020018U,   /** @brief GPIO port bit set/reset register. */
    [1]  = (rw_reg32_t)0x58020418U,   /** @brief GPIO port bit set/reset register. */
    [2]  = (rw_reg32_t)0x58020818U,   /** @brief GPIO port bit set/reset register. */
    [3]  = (rw_reg32_t)0x58020C18U,   /** @brief GPIO port bit set/reset register. */
    [4]  = (rw_reg32_t)0x58021018U,   /** @brief GPIO port bit set/reset register. */
    [5]  = (rw_reg32_t)0x58021418U,   /** @brief GPIO port bit set/reset register. */
    [6]  = (rw_reg32_t)0x58021818U,   /** @brief GPIO port bit set/reset register. */
    [7]  = (rw_reg32_t)0x58021C18U,   /** @brief GPIO port bit set/reset register. */
    [8]  = (rw_reg32_t)0x58022018U,   /** @brief GPIO port bit set/reset register. */
    [9]  = (rw_reg32_t)0x58022418U,   /** @brief GPIO port bit set/reset register. */
    [10] = (rw_reg32_t)0x58022818U,   /** @brief GPIO port bit set/reset register. */
  };

  static const rw_reg32_t GPIOx_LCKR[11] = {
    [0]  = (rw_reg32_t)0x5802001CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    [1]  = (rw_reg32_t)0x5802041CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    [2]  = (rw_reg32_t)0x5802081CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    [3]  = (rw_reg32_t)0x58020C1CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    [4]  = (rw_reg32_t)0x5802101CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    [5]  = (rw_reg32_t)0x5802141CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    [6]  = (rw_reg32_t)0x5802181CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    [7]  = (rw_reg32_t)0x58021C1CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    [8]  = (rw_reg32_t)0x5802201CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    [9]  = (rw_reg32_t)0x5802241CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    [10] = (rw_reg32_t)0x5802281CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
  };

  static const rw_reg32_t GPIOx_AFRL[11] = {
    [0]  = (rw_reg32_t)0x58020020U,   /** @brief GPIO alternate function low register. */
    [1]  = (rw_reg32_t)0x58020420U,   /** @brief GPIO alternate function low register. */
    [2]  = (rw_reg32_t)0x58020820U,   /** @brief GPIO alternate function low register. */
    [3]  = (rw_reg32_t)0x58020C20U,   /** @brief GPIO alternate function low register. */
    [4]  = (rw_reg32_t)0x58021020U,   /** @brief GPIO alternate function low register. */
    [5]  = (rw_reg32_t)0x58021420U,   /** @brief GPIO alternate function low register. */
    [6]  = (rw_reg32_t)0x58021820U,   /** @brief GPIO alternate function low register. */
    [7]  = (rw_reg32_t)0x58021C20U,   /** @brief GPIO alternate function low register. */
    [8]  = (rw_reg32_t)0x58022020U,   /** @brief GPIO alternate function low register. */
    [9]  = (rw_reg32_t)0x58022420U,   /** @brief GPIO alternate function low register. */
    [10] = (rw_reg32_t)0x58022820U,   /** @brief GPIO alternate function low register. */
  };

  static const rw_reg32_t GPIOx_AFRH[11] = {
    [0]  = (rw_reg32_t)0x58020024U,   /** @brief GPIO alternate function high register. */
    [1]  = (rw_reg32_t)0x58020424U,   /** @brief GPIO alternate function high register. */
    [2]  = (rw_reg32_t)0x58020824U,   /** @brief GPIO alternate function high register. */
    [3]  = (rw_reg32_t)0x58020C24U,   /** @brief GPIO alternate function high register. */
    [4]  = (rw_reg32_t)0x58021024U,   /** @brief GPIO alternate function high register. */
    [5]  = (rw_reg32_t)0x58021424U,   /** @brief GPIO alternate function high register. */
    [6]  = (rw_reg32_t)0x58021824U,   /** @brief GPIO alternate function high register. */
    [7]  = (rw_reg32_t)0x58021C24U,   /** @brief GPIO alternate function high register. */
    [8]  = (rw_reg32_t)0x58022024U,   /** @brief GPIO alternate function high register. */
    [9]  = (rw_reg32_t)0x58022424U,   /** @brief GPIO alternate function high register. */
    [10] = (rw_reg32_t)0x58022824U,   /** @brief GPIO alternate function high register. */
  };

  /**** GPIOx Register Field Definitions ****/

  static const field32_t GPIOx_LCKR_LCKK = {.msk = 0x00010000U, .pos = 16};   /** @brief Lock key this bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) note: during the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset. */

  /**** Enumerated GPIOx Register Field Definitions ****/

  static field32_t const GPIOx_MODER_MODEx[16] = {
    [0]  = {.msk = 0x00000003U, .pos = 0},    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [1]  = {.msk = 0x0000000CU, .pos = 2},    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [2]  = {.msk = 0x00000030U, .pos = 4},    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [3]  = {.msk = 0x000000C0U, .pos = 6},    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [4]  = {.msk = 0x00000300U, .pos = 8},    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [5]  = {.msk = 0x00000C00U, .pos = 10},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [6]  = {.msk = 0x00003000U, .pos = 12},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [7]  = {.msk = 0x0000C000U, .pos = 14},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [8]  = {.msk = 0x00030000U, .pos = 16},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [9]  = {.msk = 0x000C0000U, .pos = 18},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [10] = {.msk = 0x00300000U, .pos = 20},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [11] = {.msk = 0x00C00000U, .pos = 22},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [12] = {.msk = 0x03000000U, .pos = 24},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [13] = {.msk = 0x0C000000U, .pos = 26},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [14] = {.msk = 0x30000000U, .pos = 28},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [15] = {.msk = 0xC0000000U, .pos = 30},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
  };

  static field32_t const GPIOx_OTYPER_OTx[16] = {
    [0]  = {.msk = 0x00000001U, .pos = 0},    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [1]  = {.msk = 0x00000002U, .pos = 1},    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [2]  = {.msk = 0x00000004U, .pos = 2},    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [3]  = {.msk = 0x00000008U, .pos = 3},    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [4]  = {.msk = 0x00000010U, .pos = 4},    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [5]  = {.msk = 0x00000020U, .pos = 5},    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [6]  = {.msk = 0x00000040U, .pos = 6},    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [7]  = {.msk = 0x00000080U, .pos = 7},    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [8]  = {.msk = 0x00000100U, .pos = 8},    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [9]  = {.msk = 0x00000200U, .pos = 9},    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [10] = {.msk = 0x00000400U, .pos = 10},   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [11] = {.msk = 0x00000800U, .pos = 11},   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [12] = {.msk = 0x00001000U, .pos = 12},   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [13] = {.msk = 0x00002000U, .pos = 13},   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [14] = {.msk = 0x00004000U, .pos = 14},   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [15] = {.msk = 0x00008000U, .pos = 15},   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
  };

  static field32_t const GPIOx_OSPEEDR_OSPEEDx[16] = {
    [0]  = {.msk = 0x00000003U, .pos = 0},    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [1]  = {.msk = 0x0000000CU, .pos = 2},    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [2]  = {.msk = 0x00000030U, .pos = 4},    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [3]  = {.msk = 0x000000C0U, .pos = 6},    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [4]  = {.msk = 0x00000300U, .pos = 8},    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [5]  = {.msk = 0x00000C00U, .pos = 10},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [6]  = {.msk = 0x00003000U, .pos = 12},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [7]  = {.msk = 0x0000C000U, .pos = 14},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [8]  = {.msk = 0x00030000U, .pos = 16},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [9]  = {.msk = 0x000C0000U, .pos = 18},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [10] = {.msk = 0x00300000U, .pos = 20},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [11] = {.msk = 0x00C00000U, .pos = 22},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [12] = {.msk = 0x03000000U, .pos = 24},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [13] = {.msk = 0x0C000000U, .pos = 26},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [14] = {.msk = 0x30000000U, .pos = 28},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [15] = {.msk = 0xC0000000U, .pos = 30},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
  };

  static field32_t const GPIOx_PUPDR_PUPDx[16] = {
    [0]  = {.msk = 0x00000003U, .pos = 0},    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down. */
    [1]  = {.msk = 0x0000000CU, .pos = 2},    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down. */
    [2]  = {.msk = 0x00000030U, .pos = 4},    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down. */
    [3]  = {.msk = 0x000000C0U, .pos = 6},    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down. */
    [4]  = {.msk = 0x00000300U, .pos = 8},    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down. */
    [5]  = {.msk = 0x00000C00U, .pos = 10},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down. */
    [6]  = {.msk = 0x00003000U, .pos = 12},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down. */
    [7]  = {.msk = 0x0000C000U, .pos = 14},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down. */
    [8]  = {.msk = 0x00030000U, .pos = 16},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down. */
    [9]  = {.msk = 0x000C0000U, .pos = 18},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down. */
    [10] = {.msk = 0x00300000U, .pos = 20},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down. */
    [11] = {.msk = 0x00C00000U, .pos = 22},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down. */
    [12] = {.msk = 0x03000000U, .pos = 24},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down. */
    [13] = {.msk = 0x0C000000U, .pos = 26},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down. */
    [14] = {.msk = 0x30000000U, .pos = 28},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down. */
    [15] = {.msk = 0xC0000000U, .pos = 30},   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down. */
  };

  static field32_t const GPIOx_IDR_IDx[16] = {
    [0]  = {.msk = 0x00000001U, .pos = 0},    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [1]  = {.msk = 0x00000002U, .pos = 1},    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [2]  = {.msk = 0x00000004U, .pos = 2},    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [3]  = {.msk = 0x00000008U, .pos = 3},    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [4]  = {.msk = 0x00000010U, .pos = 4},    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [5]  = {.msk = 0x00000020U, .pos = 5},    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [6]  = {.msk = 0x00000040U, .pos = 6},    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [7]  = {.msk = 0x00000080U, .pos = 7},    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [8]  = {.msk = 0x00000100U, .pos = 8},    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [9]  = {.msk = 0x00000200U, .pos = 9},    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [10] = {.msk = 0x00000400U, .pos = 10},   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [11] = {.msk = 0x00000800U, .pos = 11},   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [12] = {.msk = 0x00001000U, .pos = 12},   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [13] = {.msk = 0x00002000U, .pos = 13},   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [14] = {.msk = 0x00004000U, .pos = 14},   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [15] = {.msk = 0x00008000U, .pos = 15},   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
  };

  static field32_t const GPIOx_ODR_ODx[16] = {
    [0]  = {.msk = 0x00000001U, .pos = 0},    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [1]  = {.msk = 0x00000002U, .pos = 1},    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [2]  = {.msk = 0x00000004U, .pos = 2},    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [3]  = {.msk = 0x00000008U, .pos = 3},    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [4]  = {.msk = 0x00000010U, .pos = 4},    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [5]  = {.msk = 0x00000020U, .pos = 5},    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [6]  = {.msk = 0x00000040U, .pos = 6},    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [7]  = {.msk = 0x00000080U, .pos = 7},    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [8]  = {.msk = 0x00000100U, .pos = 8},    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [9]  = {.msk = 0x00000200U, .pos = 9},    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [10] = {.msk = 0x00000400U, .pos = 10},   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [11] = {.msk = 0x00000800U, .pos = 11},   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [12] = {.msk = 0x00001000U, .pos = 12},   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [13] = {.msk = 0x00002000U, .pos = 13},   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [14] = {.msk = 0x00004000U, .pos = 14},   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [15] = {.msk = 0x00008000U, .pos = 15},   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
  };

  static field32_t const GPIOx_BSRR_BSx[16] = {
    [0]  = {.msk = 0x00000001U, .pos = 0},    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [1]  = {.msk = 0x00000002U, .pos = 1},    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [2]  = {.msk = 0x00000004U, .pos = 2},    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [3]  = {.msk = 0x00000008U, .pos = 3},    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [4]  = {.msk = 0x00000010U, .pos = 4},    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [5]  = {.msk = 0x00000020U, .pos = 5},    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [6]  = {.msk = 0x00000040U, .pos = 6},    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [7]  = {.msk = 0x00000080U, .pos = 7},    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [8]  = {.msk = 0x00000100U, .pos = 8},    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [9]  = {.msk = 0x00000200U, .pos = 9},    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [10] = {.msk = 0x00000400U, .pos = 10},   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [11] = {.msk = 0x00000800U, .pos = 11},   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [12] = {.msk = 0x00001000U, .pos = 12},   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [13] = {.msk = 0x00002000U, .pos = 13},   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [14] = {.msk = 0x00004000U, .pos = 14},   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [15] = {.msk = 0x00008000U, .pos = 15},   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
  };

  static field32_t const GPIOx_BSRR_BRx[16] = {
    [0]  = {.msk = 0x00010000U, .pos = 16},   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [1]  = {.msk = 0x00020000U, .pos = 17},   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [2]  = {.msk = 0x00040000U, .pos = 18},   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [3]  = {.msk = 0x00080000U, .pos = 19},   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [4]  = {.msk = 0x00100000U, .pos = 20},   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [5]  = {.msk = 0x00200000U, .pos = 21},   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [6]  = {.msk = 0x00400000U, .pos = 22},   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [7]  = {.msk = 0x00800000U, .pos = 23},   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [8]  = {.msk = 0x01000000U, .pos = 24},   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [9]  = {.msk = 0x02000000U, .pos = 25},   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [10] = {.msk = 0x04000000U, .pos = 26},   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [11] = {.msk = 0x08000000U, .pos = 27},   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [12] = {.msk = 0x10000000U, .pos = 28},   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [13] = {.msk = 0x20000000U, .pos = 29},   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [14] = {.msk = 0x40000000U, .pos = 30},   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [15] = {.msk = 0x80000000U, .pos = 31},   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
  };

  static field32_t const GPIOx_LCKR_LCKx[16] = {
    [0]  = {.msk = 0x00000001U, .pos = 0},    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [1]  = {.msk = 0x00000002U, .pos = 1},    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [2]  = {.msk = 0x00000004U, .pos = 2},    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [3]  = {.msk = 0x00000008U, .pos = 3},    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [4]  = {.msk = 0x00000010U, .pos = 4},    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [5]  = {.msk = 0x00000020U, .pos = 5},    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [6]  = {.msk = 0x00000040U, .pos = 6},    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [7]  = {.msk = 0x00000080U, .pos = 7},    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [8]  = {.msk = 0x00000100U, .pos = 8},    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [9]  = {.msk = 0x00000200U, .pos = 9},    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [10] = {.msk = 0x00000400U, .pos = 10},   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [11] = {.msk = 0x00000800U, .pos = 11},   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [12] = {.msk = 0x00001000U, .pos = 12},   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [13] = {.msk = 0x00002000U, .pos = 13},   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [14] = {.msk = 0x00004000U, .pos = 14},   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [15] = {.msk = 0x00008000U, .pos = 15},   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
  };

  static field32_t const GPIOx_AFRL_AFSELx[8] = {
    [0] = {.msk = 0x0000000FU, .pos = 0},    /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection:. */
    [1] = {.msk = 0x000000F0U, .pos = 4},    /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection:. */
    [2] = {.msk = 0x00000F00U, .pos = 8},    /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection:. */
    [3] = {.msk = 0x0000F000U, .pos = 12},   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection:. */
    [4] = {.msk = 0x000F0000U, .pos = 16},   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection:. */
    [5] = {.msk = 0x00F00000U, .pos = 20},   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection:. */
    [6] = {.msk = 0x0F000000U, .pos = 24},   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection:. */
    [7] = {.msk = 0xF0000000U, .pos = 28},   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection:. */
  };

  static field32_t const GPIOx_AFRH_AFSELx[8] = {
    [0] = {.msk = 0x0000000FU, .pos = 0},    /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection:. */
    [1] = {.msk = 0x000000F0U, .pos = 4},    /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection:. */
    [2] = {.msk = 0x00000F00U, .pos = 8},    /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection:. */
    [3] = {.msk = 0x0000F000U, .pos = 12},   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection:. */
    [4] = {.msk = 0x000F0000U, .pos = 16},   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection:. */
    [5] = {.msk = 0x00F00000U, .pos = 20},   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection:. */
    [6] = {.msk = 0x0F000000U, .pos = 24},   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection:. */
    [7] = {.msk = 0xF0000000U, .pos = 28},   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection:. */
  };

  /************************************************************************************************
   * JPEG Definitions
   ************************************************************************************************/

  /**** JPEG Register Definitions ****/

  static const rw_reg32_t JPEG_CR  = (rw_reg32_t)0x52003030U;   /** @brief JPEG control register. */
  static const ro_reg32_t JPEG_SR  = (ro_reg32_t)0x52003034U;   /** @brief JPEG status register. */
  static const rw_reg32_t JPEG_CFR = (rw_reg32_t)0x52003038U;   /** @brief JPEG clear flag register. */
  static const rw_reg32_t JPEG_DIR = (rw_reg32_t)0x52003040U;   /** @brief JPEG data input register. */
  static const ro_reg32_t JPEG_DOR = (ro_reg32_t)0x52003044U;   /** @brief JPEG data output register. */

  /**** Enumerated JPEG Register Definitions ****/

  static const rw_reg32_t JPEG_CONFRx[4] = {
    [0] = (rw_reg32_t)0x52003000U,   /** @brief JPEG codec control register. */
    [1] = (rw_reg32_t)0x52003004U,   /** @brief JPEG codec configuration register 1. */
    [2] = (rw_reg32_t)0x52003008U,   /** @brief JPEG codec configuration register 2. */
    [3] = (rw_reg32_t)0x5200300CU,   /** @brief JPEG codec configuration register 3. */
  };

  static const rw_reg32_t JPEG_CONFRNx[5] = {
    [1] = (rw_reg32_t)0x52003010U,   /** @brief JPEG codec configuration register 4-7. */
    [2] = (rw_reg32_t)0x52003014U,   /** @brief JPEG codec configuration register 4-7. */
    [3] = (rw_reg32_t)0x52003018U,   /** @brief JPEG codec configuration register 4-7. */
    [4] = (rw_reg32_t)0x5200301CU,   /** @brief JPEG codec configuration register 4-7. */
  };

  /**** JPEG Register Field Definitions ****/

  static const field32_t JPEG_CONFRx_START = {.msk = 0x00000001U, .pos = 0};    /** @brief Start this bit start or stop the encoding or decoding process. Read this register always return 0. */
  static const field32_t JPEG_CONFRNx_HD   = {.msk = 0x00000001U, .pos = 0};    /** @brief Huffman DC selects the huffman table for encoding the DC coefficients. */
  static const field32_t JPEG_CONFRNx_HA   = {.msk = 0x00000002U, .pos = 1};    /** @brief Huffman AC selects the huffman table for encoding the AC coefficients. */
  static const field32_t JPEG_CONFRNx_QT   = {.msk = 0x0000000CU, .pos = 2};    /** @brief Quantization table selects quantization table associated with a color component. */
  static const field32_t JPEG_CONFRNx_NB   = {.msk = 0x000000F0U, .pos = 4};    /** @brief Number of block number of data units minus 1 that belong to a particular color in the MCU. */
  static const field32_t JPEG_CONFRNx_VSF  = {.msk = 0x00000F00U, .pos = 8};    /** @brief Vertical sampling factor vertical sampling factor for component i. */
  static const field32_t JPEG_CONFRNx_HSF  = {.msk = 0x0000F000U, .pos = 12};   /** @brief Horizontal sampling factor horizontal sampling factor for component i. */
  static const field32_t JPEG_CR_JCEN      = {.msk = 0x00000001U, .pos = 0};    /** @brief JPEG core enable enable the JPEG codec core. */
  static const field32_t JPEG_CR_IFTIE     = {.msk = 0x00000002U, .pos = 1};    /** @brief Input FIFO threshold interrupt enable this bit enables the interrupt generation when input FIFO reach the threshold. */
  static const field32_t JPEG_CR_IFNFIE    = {.msk = 0x00000004U, .pos = 2};    /** @brief Input FIFO not full interrupt enable this bit enables the interrupt generation when input FIFO is not empty. */
  static const field32_t JPEG_CR_OFTIE     = {.msk = 0x00000008U, .pos = 3};    /** @brief Output FIFO threshold interrupt enable this bit enables the interrupt generation when output FIFO reach the threshold. */
  static const field32_t JPEG_CR_OFNEIE    = {.msk = 0x00000010U, .pos = 4};    /** @brief Output FIFO not empty interrupt enable this bit enables the interrupt generation when output FIFO is not empty. */
  static const field32_t JPEG_CR_EOCIE     = {.msk = 0x00000020U, .pos = 5};    /** @brief End of conversion interrupt enable this bit enables the interrupt generation on the end of conversion. */
  static const field32_t JPEG_CR_HPDIE     = {.msk = 0x00000040U, .pos = 6};    /** @brief Header parsing done interrupt enable this bit enables the interrupt generation on the header parsing operation. */
  static const field32_t JPEG_CR_IDMAEN    = {.msk = 0x00000800U, .pos = 11};   /** @brief Input DMA enable enable the DMA request generation for the input FIFO. */
  static const field32_t JPEG_CR_ODMAEN    = {.msk = 0x00001000U, .pos = 12};   /** @brief Output DMA enable enable the DMA request generation for the output FIFO. */
  static const field32_t JPEG_CR_IFF       = {.msk = 0x00002000U, .pos = 13};   /** @brief Input FIFO flush this bit flush the input FIFO. This bit is always read as 0. */
  static const field32_t JPEG_CR_OFF       = {.msk = 0x00004000U, .pos = 14};   /** @brief Output FIFO flush this bit flush the output FIFO. This bit is always read as 0. */
  static const field32_t JPEG_SR_IFTF      = {.msk = 0x00000002U, .pos = 1};    /** @brief Input FIFO threshold flag this bit is set when the input FIFO is not full and is bellow its threshold. */
  static const field32_t JPEG_SR_IFNFF     = {.msk = 0x00000004U, .pos = 2};    /** @brief Input FIFO not full flag this bit is set when the input FIFO is not full (a data can be written). */
  static const field32_t JPEG_SR_OFTF      = {.msk = 0x00000008U, .pos = 3};    /** @brief Output FIFO threshold flag this bit is set when the output FIFO is not empty and has reach its threshold. */
  static const field32_t JPEG_SR_OFNEF     = {.msk = 0x00000010U, .pos = 4};    /** @brief Output FIFO not empty flag this bit is set when the output FIFO is not empty (a data is available). */
  static const field32_t JPEG_SR_EOCF      = {.msk = 0x00000020U, .pos = 5};    /** @brief End of conversion flag this bit is set when the JPEG codec core has finished the encoding or the decoding process and than last data has been sent to the output FIFO. */
  static const field32_t JPEG_SR_HPDF      = {.msk = 0x00000040U, .pos = 6};    /** @brief Header parsing done flag this bit is set in decode mode when the JPEG codec has finished the parsing of the headers and the internal registers have been updated. */
  static const field32_t JPEG_SR_COF       = {.msk = 0x00000080U, .pos = 7};    /** @brief Codec operation flag this bit is set when when a JPEG codec operation is on going (encoding or decoding). */
  static const field32_t JPEG_CFR_CEOCF    = {.msk = 0x00000020U, .pos = 5};    /** @brief Clear end of conversion flag writing 1 clears the end of conversion flag of the JPEG status register. */
  static const field32_t JPEG_CFR_CHPDF    = {.msk = 0x00000040U, .pos = 6};    /** @brief Clear header parsing done flag writing 1 clears the header parsing done flag of the JPEG status register. */

  /************************************************************************************************
   * MDMA Definitions
   ************************************************************************************************/

  /**** MDMA Register Definitions ****/

  static const ro_reg32_t MDMA_MDMA_GISR0 = (ro_reg32_t)0x52000000U;   /** @brief MDMA global interrupt/status register. */

  /**** Enumerated MDMA Register Definitions ****/

  static const ro_reg32_t MDMA_MDMA_CxISR[16] = {
    [0]  = (ro_reg32_t)0x52000040U,   /** @brief MDMA channel x interrupt/status register. */
    [1]  = (ro_reg32_t)0x52000080U,   /** @brief MDMA channel x interrupt/status register. */
    [2]  = (ro_reg32_t)0x520000C0U,   /** @brief MDMA channel x interrupt/status register. */
    [3]  = (ro_reg32_t)0x52000100U,   /** @brief MDMA channel x interrupt/status register. */
    [4]  = (ro_reg32_t)0x52000140U,   /** @brief MDMA channel x interrupt/status register. */
    [5]  = (ro_reg32_t)0x52000180U,   /** @brief MDMA channel x interrupt/status register. */
    [6]  = (ro_reg32_t)0x520001C0U,   /** @brief MDMA channel x interrupt/status register. */
    [7]  = (ro_reg32_t)0x52000200U,   /** @brief MDMA channel x interrupt/status register. */
    [8]  = (ro_reg32_t)0x52000240U,   /** @brief MDMA channel x interrupt/status register. */
    [9]  = (ro_reg32_t)0x52000280U,   /** @brief MDMA channel x interrupt/status register. */
    [10] = (ro_reg32_t)0x520002C0U,   /** @brief MDMA channel x interrupt/status register. */
    [11] = (ro_reg32_t)0x52000300U,   /** @brief MDMA channel x interrupt/status register. */
    [12] = (ro_reg32_t)0x52000340U,   /** @brief MDMA channel x interrupt/status register. */
    [13] = (ro_reg32_t)0x52000380U,   /** @brief MDMA channel x interrupt/status register. */
    [14] = (ro_reg32_t)0x520003C0U,   /** @brief MDMA channel x interrupt/status register. */
    [15] = (ro_reg32_t)0x52000400U,   /** @brief MDMA channel x interrupt/status register. */
  };

  static const rw_reg32_t MDMA_MDMA_CxIFCR[16] = {
    [0]  = (rw_reg32_t)0x52000044U,   /** @brief MDMA channel x interrupt flag clear register. */
    [1]  = (rw_reg32_t)0x52000084U,   /** @brief MDMA channel x interrupt flag clear register. */
    [2]  = (rw_reg32_t)0x520000C4U,   /** @brief MDMA channel x interrupt flag clear register. */
    [3]  = (rw_reg32_t)0x52000104U,   /** @brief MDMA channel x interrupt flag clear register. */
    [4]  = (rw_reg32_t)0x52000144U,   /** @brief MDMA channel x interrupt flag clear register. */
    [5]  = (rw_reg32_t)0x52000184U,   /** @brief MDMA channel x interrupt flag clear register. */
    [6]  = (rw_reg32_t)0x520001C4U,   /** @brief MDMA channel x interrupt flag clear register. */
    [7]  = (rw_reg32_t)0x52000204U,   /** @brief MDMA channel x interrupt flag clear register. */
    [8]  = (rw_reg32_t)0x52000244U,   /** @brief MDMA channel x interrupt flag clear register. */
    [9]  = (rw_reg32_t)0x52000284U,   /** @brief MDMA channel x interrupt flag clear register. */
    [10] = (rw_reg32_t)0x520002C4U,   /** @brief MDMA channel x interrupt flag clear register. */
    [11] = (rw_reg32_t)0x52000304U,   /** @brief MDMA channel x interrupt flag clear register. */
    [12] = (rw_reg32_t)0x52000344U,   /** @brief MDMA channel x interrupt flag clear register. */
    [13] = (rw_reg32_t)0x52000384U,   /** @brief MDMA channel x interrupt flag clear register. */
    [14] = (rw_reg32_t)0x520003C4U,   /** @brief MDMA channel x interrupt flag clear register. */
    [15] = (rw_reg32_t)0x52000404U,   /** @brief MDMA channel x interrupt flag clear register. */
  };

  static const ro_reg32_t MDMA_MDMA_CxESR[16] = {
    [0]  = (ro_reg32_t)0x52000048U,   /** @brief MDMA channel x error status register. */
    [1]  = (ro_reg32_t)0x52000088U,   /** @brief MDMA channel x error status register. */
    [2]  = (ro_reg32_t)0x520000C8U,   /** @brief MDMA channel x error status register. */
    [3]  = (ro_reg32_t)0x52000108U,   /** @brief MDMA channel x error status register. */
    [4]  = (ro_reg32_t)0x52000148U,   /** @brief MDMA channel x error status register. */
    [5]  = (ro_reg32_t)0x52000188U,   /** @brief MDMA channel x error status register. */
    [6]  = (ro_reg32_t)0x520001C8U,   /** @brief MDMA channel x error status register. */
    [7]  = (ro_reg32_t)0x52000208U,   /** @brief MDMA channel x error status register. */
    [8]  = (ro_reg32_t)0x52000248U,   /** @brief MDMA channel x error status register. */
    [9]  = (ro_reg32_t)0x52000288U,   /** @brief MDMA channel x error status register. */
    [10] = (ro_reg32_t)0x520002C8U,   /** @brief MDMA channel x error status register. */
    [11] = (ro_reg32_t)0x52000308U,   /** @brief MDMA channel x error status register. */
    [12] = (ro_reg32_t)0x52000348U,   /** @brief MDMA channel x error status register. */
    [13] = (ro_reg32_t)0x52000388U,   /** @brief MDMA channel x error status register. */
    [14] = (ro_reg32_t)0x520003C8U,   /** @brief MDMA channel x error status register. */
    [15] = (ro_reg32_t)0x52000408U,   /** @brief MDMA channel x error status register. */
  };

  static const rw_reg32_t MDMA_MDMA_CxCR[16] = {
    [0]  = (rw_reg32_t)0x5200004CU,   /** @brief This register is used to control the concerned channel. */
    [1]  = (rw_reg32_t)0x5200008CU,   /** @brief This register is used to control the concerned channel. */
    [2]  = (rw_reg32_t)0x520000CCU,   /** @brief This register is used to control the concerned channel. */
    [3]  = (rw_reg32_t)0x5200010CU,   /** @brief This register is used to control the concerned channel. */
    [4]  = (rw_reg32_t)0x5200014CU,   /** @brief This register is used to control the concerned channel. */
    [5]  = (rw_reg32_t)0x5200018CU,   /** @brief This register is used to control the concerned channel. */
    [6]  = (rw_reg32_t)0x520001CCU,   /** @brief This register is used to control the concerned channel. */
    [7]  = (rw_reg32_t)0x5200020CU,   /** @brief This register is used to control the concerned channel. */
    [8]  = (rw_reg32_t)0x5200024CU,   /** @brief This register is used to control the concerned channel. */
    [9]  = (rw_reg32_t)0x5200028CU,   /** @brief This register is used to control the concerned channel. */
    [10] = (rw_reg32_t)0x520002CCU,   /** @brief This register is used to control the concerned channel. */
    [11] = (rw_reg32_t)0x5200030CU,   /** @brief This register is used to control the concerned channel. */
    [12] = (rw_reg32_t)0x5200034CU,   /** @brief This register is used to control the concerned channel. */
    [13] = (rw_reg32_t)0x5200038CU,   /** @brief This register is used to control the concerned channel. */
    [14] = (rw_reg32_t)0x520003CCU,   /** @brief This register is used to control the concerned channel. */
    [15] = (rw_reg32_t)0x5200040CU,   /** @brief This register is used to control the concerned channel. */
  };

  static const rw_reg32_t MDMA_MDMA_CxTCR[16] = {
    [0]  = (rw_reg32_t)0x52000050U,   /** @brief This register is used to configure the concerned channel. */
    [1]  = (rw_reg32_t)0x52000090U,   /** @brief This register is used to configure the concerned channel. */
    [2]  = (rw_reg32_t)0x520000D0U,   /** @brief This register is used to configure the concerned channel. */
    [3]  = (rw_reg32_t)0x52000110U,   /** @brief This register is used to configure the concerned channel. */
    [4]  = (rw_reg32_t)0x52000150U,   /** @brief This register is used to configure the concerned channel. */
    [5]  = (rw_reg32_t)0x52000190U,   /** @brief This register is used to configure the concerned channel. */
    [6]  = (rw_reg32_t)0x520001D0U,   /** @brief This register is used to configure the concerned channel. */
    [7]  = (rw_reg32_t)0x52000210U,   /** @brief This register is used to configure the concerned channel. */
    [8]  = (rw_reg32_t)0x52000250U,   /** @brief This register is used to configure the concerned channel. */
    [9]  = (rw_reg32_t)0x52000290U,   /** @brief This register is used to configure the concerned channel. */
    [10] = (rw_reg32_t)0x520002D0U,   /** @brief This register is used to configure the concerned channel. */
    [11] = (rw_reg32_t)0x52000310U,   /** @brief This register is used to configure the concerned channel. */
    [12] = (rw_reg32_t)0x52000350U,   /** @brief This register is used to configure the concerned channel. */
    [13] = (rw_reg32_t)0x52000390U,   /** @brief This register is used to configure the concerned channel. */
    [14] = (rw_reg32_t)0x520003D0U,   /** @brief This register is used to configure the concerned channel. */
    [15] = (rw_reg32_t)0x52000410U,   /** @brief This register is used to configure the concerned channel. */
  };

  static const rw_reg32_t MDMA_MDMA_CxBNDTR[16] = {
    [0]  = (rw_reg32_t)0x52000054U,   /** @brief MDMA channel x block number of data register. */
    [1]  = (rw_reg32_t)0x52000094U,   /** @brief MDMA channel x block number of data register. */
    [2]  = (rw_reg32_t)0x520000D4U,   /** @brief MDMA channel x block number of data register. */
    [3]  = (rw_reg32_t)0x52000114U,   /** @brief MDMA channel x block number of data register. */
    [4]  = (rw_reg32_t)0x52000154U,   /** @brief MDMA channel x block number of data register. */
    [5]  = (rw_reg32_t)0x52000194U,   /** @brief MDMA channel x block number of data register. */
    [6]  = (rw_reg32_t)0x520001D4U,   /** @brief MDMA channel x block number of data register. */
    [7]  = (rw_reg32_t)0x52000214U,   /** @brief MDMA channel x block number of data register. */
    [8]  = (rw_reg32_t)0x52000254U,   /** @brief MDMA channel x block number of data register. */
    [9]  = (rw_reg32_t)0x52000294U,   /** @brief MDMA channel x block number of data register. */
    [10] = (rw_reg32_t)0x520002D4U,   /** @brief MDMA channel x block number of data register. */
    [11] = (rw_reg32_t)0x52000314U,   /** @brief MDMA channel x block number of data register. */
    [12] = (rw_reg32_t)0x52000354U,   /** @brief MDMA channel x block number of data register. */
    [13] = (rw_reg32_t)0x52000394U,   /** @brief MDMA channel x block number of data register. */
    [14] = (rw_reg32_t)0x520003D4U,   /** @brief MDMA channel x block number of data register. */
    [15] = (rw_reg32_t)0x52000414U,   /** @brief MDMA channel x block number of data register. */
  };

  static const rw_reg32_t MDMA_MDMA_CxSAR[16] = {
    [0]  = (rw_reg32_t)0x52000058U,   /** @brief MDMA channel x source address register. */
    [1]  = (rw_reg32_t)0x52000098U,   /** @brief MDMA channel x source address register. */
    [2]  = (rw_reg32_t)0x520000D8U,   /** @brief MDMA channel x source address register. */
    [3]  = (rw_reg32_t)0x52000118U,   /** @brief MDMA channel x source address register. */
    [4]  = (rw_reg32_t)0x52000158U,   /** @brief MDMA channel x source address register. */
    [5]  = (rw_reg32_t)0x52000198U,   /** @brief MDMA channel x source address register. */
    [6]  = (rw_reg32_t)0x520001D8U,   /** @brief MDMA channel x source address register. */
    [7]  = (rw_reg32_t)0x52000218U,   /** @brief MDMA channel x source address register. */
    [8]  = (rw_reg32_t)0x52000258U,   /** @brief MDMA channel x source address register. */
    [9]  = (rw_reg32_t)0x52000298U,   /** @brief MDMA channel x source address register. */
    [10] = (rw_reg32_t)0x520002D8U,   /** @brief MDMA channel x source address register. */
    [11] = (rw_reg32_t)0x52000318U,   /** @brief MDMA channel x source address register. */
    [12] = (rw_reg32_t)0x52000358U,   /** @brief MDMA channel x source address register. */
    [13] = (rw_reg32_t)0x52000398U,   /** @brief MDMA channel x source address register. */
    [14] = (rw_reg32_t)0x520003D8U,   /** @brief MDMA channel x source address register. */
    [15] = (rw_reg32_t)0x52000418U,   /** @brief MDMA channel x source address register. */
  };

  static const rw_reg32_t MDMA_MDMA_CxDAR[16] = {
    [0]  = (rw_reg32_t)0x5200005CU,   /** @brief MDMA channel x destination address register. */
    [1]  = (rw_reg32_t)0x5200009CU,   /** @brief MDMA channel x destination address register. */
    [2]  = (rw_reg32_t)0x520000DCU,   /** @brief MDMA channel x destination address register. */
    [3]  = (rw_reg32_t)0x5200011CU,   /** @brief MDMA channel x destination address register. */
    [4]  = (rw_reg32_t)0x5200015CU,   /** @brief MDMA channel x destination address register. */
    [5]  = (rw_reg32_t)0x5200019CU,   /** @brief MDMA channel x destination address register. */
    [6]  = (rw_reg32_t)0x520001DCU,   /** @brief MDMA channel x destination address register. */
    [7]  = (rw_reg32_t)0x5200021CU,   /** @brief MDMA channel x destination address register. */
    [8]  = (rw_reg32_t)0x5200025CU,   /** @brief MDMA channel x destination address register. */
    [9]  = (rw_reg32_t)0x5200029CU,   /** @brief MDMA channel x destination address register. */
    [10] = (rw_reg32_t)0x520002DCU,   /** @brief MDMA channel x destination address register. */
    [11] = (rw_reg32_t)0x5200031CU,   /** @brief MDMA channel x destination address register. */
    [12] = (rw_reg32_t)0x5200035CU,   /** @brief MDMA channel x destination address register. */
    [13] = (rw_reg32_t)0x5200039CU,   /** @brief MDMA channel x destination address register. */
    [14] = (rw_reg32_t)0x520003DCU,   /** @brief MDMA channel x destination address register. */
    [15] = (rw_reg32_t)0x5200041CU,   /** @brief MDMA channel x destination address register. */
  };

  static const rw_reg32_t MDMA_MDMA_CxBRUR[16] = {
    [0]  = (rw_reg32_t)0x52000060U,   /** @brief MDMA channel x block repeat address update register. */
    [1]  = (rw_reg32_t)0x520000A0U,   /** @brief MDMA channel x block repeat address update register. */
    [2]  = (rw_reg32_t)0x520000E0U,   /** @brief MDMA channel x block repeat address update register. */
    [3]  = (rw_reg32_t)0x52000120U,   /** @brief MDMA channel x block repeat address update register. */
    [4]  = (rw_reg32_t)0x52000160U,   /** @brief MDMA channel x block repeat address update register. */
    [5]  = (rw_reg32_t)0x520001A0U,   /** @brief MDMA channel x block repeat address update register. */
    [6]  = (rw_reg32_t)0x520001E0U,   /** @brief MDMA channel x block repeat address update register. */
    [7]  = (rw_reg32_t)0x52000220U,   /** @brief MDMA channel x block repeat address update register. */
    [8]  = (rw_reg32_t)0x52000260U,   /** @brief MDMA channel x block repeat address update register. */
    [9]  = (rw_reg32_t)0x520002A0U,   /** @brief MDMA channel x block repeat address update register. */
    [10] = (rw_reg32_t)0x520002E0U,   /** @brief MDMA channel x block repeat address update register. */
    [11] = (rw_reg32_t)0x52000320U,   /** @brief MDMA channel x block repeat address update register. */
    [12] = (rw_reg32_t)0x52000360U,   /** @brief MDMA channel x block repeat address update register. */
    [13] = (rw_reg32_t)0x520003A0U,   /** @brief MDMA channel x block repeat address update register. */
    [14] = (rw_reg32_t)0x520003E0U,   /** @brief MDMA channel x block repeat address update register. */
    [15] = (rw_reg32_t)0x52000420U,   /** @brief MDMA channel x block repeat address update register. */
  };

  static const rw_reg32_t MDMA_MDMA_CxLAR[16] = {
    [0]  = (rw_reg32_t)0x52000064U,   /** @brief MDMA channel x link address register. */
    [1]  = (rw_reg32_t)0x520000A4U,   /** @brief MDMA channel x link address register. */
    [2]  = (rw_reg32_t)0x520000E4U,   /** @brief MDMA channel x link address register. */
    [3]  = (rw_reg32_t)0x52000124U,   /** @brief MDMA channel x link address register. */
    [4]  = (rw_reg32_t)0x52000164U,   /** @brief MDMA channel x link address register. */
    [5]  = (rw_reg32_t)0x520001A4U,   /** @brief MDMA channel x link address register. */
    [6]  = (rw_reg32_t)0x520001E4U,   /** @brief MDMA channel x link address register. */
    [7]  = (rw_reg32_t)0x52000224U,   /** @brief MDMA channel x link address register. */
    [8]  = (rw_reg32_t)0x52000264U,   /** @brief MDMA channel x link address register. */
    [9]  = (rw_reg32_t)0x520002A4U,   /** @brief MDMA channel x link address register. */
    [10] = (rw_reg32_t)0x520002E4U,   /** @brief MDMA channel x link address register. */
    [11] = (rw_reg32_t)0x52000324U,   /** @brief MDMA channel x link address register. */
    [12] = (rw_reg32_t)0x52000364U,   /** @brief MDMA channel x link address register. */
    [13] = (rw_reg32_t)0x520003A4U,   /** @brief MDMA channel x link address register. */
    [14] = (rw_reg32_t)0x520003E4U,   /** @brief MDMA channel x link address register. */
    [15] = (rw_reg32_t)0x52000424U,   /** @brief MDMA channel x link address register. */
  };

  static const rw_reg32_t MDMA_MDMA_CxTBR[16] = {
    [0]  = (rw_reg32_t)0x52000068U,   /** @brief MDMA channel x trigger and bus selection register. */
    [1]  = (rw_reg32_t)0x520000A8U,   /** @brief MDMA channel x trigger and bus selection register. */
    [2]  = (rw_reg32_t)0x520000E8U,   /** @brief MDMA channel x trigger and bus selection register. */
    [3]  = (rw_reg32_t)0x52000128U,   /** @brief MDMA channel x trigger and bus selection register. */
    [4]  = (rw_reg32_t)0x52000168U,   /** @brief MDMA channel x trigger and bus selection register. */
    [5]  = (rw_reg32_t)0x520001A8U,   /** @brief MDMA channel x trigger and bus selection register. */
    [6]  = (rw_reg32_t)0x520001E8U,   /** @brief MDMA channel x trigger and bus selection register. */
    [7]  = (rw_reg32_t)0x52000228U,   /** @brief MDMA channel x trigger and bus selection register. */
    [8]  = (rw_reg32_t)0x52000268U,   /** @brief MDMA channel x trigger and bus selection register. */
    [9]  = (rw_reg32_t)0x520002A8U,   /** @brief MDMA channel x trigger and bus selection register. */
    [10] = (rw_reg32_t)0x520002E8U,   /** @brief MDMA channel x trigger and bus selection register. */
    [11] = (rw_reg32_t)0x52000328U,   /** @brief MDMA channel x trigger and bus selection register. */
    [12] = (rw_reg32_t)0x52000368U,   /** @brief MDMA channel x trigger and bus selection register. */
    [13] = (rw_reg32_t)0x520003A8U,   /** @brief MDMA channel x trigger and bus selection register. */
    [14] = (rw_reg32_t)0x520003E8U,   /** @brief MDMA channel x trigger and bus selection register. */
    [15] = (rw_reg32_t)0x52000428U,   /** @brief MDMA channel x trigger and bus selection register. */
  };

  static const rw_reg32_t MDMA_MDMA_CxMAR[16] = {
    [0]  = (rw_reg32_t)0x52000070U,   /** @brief MDMA channel x mask address register. */
    [1]  = (rw_reg32_t)0x520000B0U,   /** @brief MDMA channel x mask address register. */
    [2]  = (rw_reg32_t)0x520000F0U,   /** @brief MDMA channel x mask address register. */
    [3]  = (rw_reg32_t)0x52000130U,   /** @brief MDMA channel x mask address register. */
    [4]  = (rw_reg32_t)0x52000170U,   /** @brief MDMA channel x mask address register. */
    [5]  = (rw_reg32_t)0x520001B0U,   /** @brief MDMA channel x mask address register. */
    [6]  = (rw_reg32_t)0x520001F0U,   /** @brief MDMA channel x mask address register. */
    [7]  = (rw_reg32_t)0x52000230U,   /** @brief MDMA channel x mask address register. */
    [8]  = (rw_reg32_t)0x52000270U,   /** @brief MDMA channel x mask address register. */
    [9]  = (rw_reg32_t)0x520002B0U,   /** @brief MDMA channel x mask address register. */
    [10] = (rw_reg32_t)0x520002F0U,   /** @brief MDMA channel x mask address register. */
    [11] = (rw_reg32_t)0x52000330U,   /** @brief MDMA channel x mask address register. */
    [12] = (rw_reg32_t)0x52000370U,   /** @brief MDMA channel x mask address register. */
    [13] = (rw_reg32_t)0x520003B0U,   /** @brief MDMA channel x mask address register. */
    [14] = (rw_reg32_t)0x520003F0U,   /** @brief MDMA channel x mask address register. */
    [15] = (rw_reg32_t)0x52000430U,   /** @brief MDMA channel x mask address register. */
  };

  static const rw_reg32_t MDMA_MDMA_CxMDR[16] = {
    [0]  = (rw_reg32_t)0x52000074U,   /** @brief MDMA channel x mask data register. */
    [1]  = (rw_reg32_t)0x520000B4U,   /** @brief MDMA channel x mask data register. */
    [2]  = (rw_reg32_t)0x520000F4U,   /** @brief MDMA channel x mask data register. */
    [3]  = (rw_reg32_t)0x52000134U,   /** @brief MDMA channel x mask data register. */
    [4]  = (rw_reg32_t)0x52000174U,   /** @brief MDMA channel x mask data register. */
    [5]  = (rw_reg32_t)0x520001B4U,   /** @brief MDMA channel x mask data register. */
    [6]  = (rw_reg32_t)0x520001F4U,   /** @brief MDMA channel x mask data register. */
    [7]  = (rw_reg32_t)0x52000234U,   /** @brief MDMA channel x mask data register. */
    [8]  = (rw_reg32_t)0x52000274U,   /** @brief MDMA channel x mask data register. */
    [9]  = (rw_reg32_t)0x520002B4U,   /** @brief MDMA channel x mask data register. */
    [10] = (rw_reg32_t)0x520002F4U,   /** @brief MDMA channel x mask data register. */
    [11] = (rw_reg32_t)0x52000334U,   /** @brief MDMA channel x mask data register. */
    [12] = (rw_reg32_t)0x52000374U,   /** @brief MDMA channel x mask data register. */
    [13] = (rw_reg32_t)0x520003B4U,   /** @brief MDMA channel x mask data register. */
    [14] = (rw_reg32_t)0x520003F4U,   /** @brief MDMA channel x mask data register. */
    [15] = (rw_reg32_t)0x52000434U,   /** @brief MDMA channel x mask data register. */
  };

  /**** MDMA Register Field Definitions ****/

  static const field32_t MDMA_MDMA_CxISR_TEIF0    = {.msk = 0x00000001U, .pos = 0};    /** @brief Channel x transfer error interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
  static const field32_t MDMA_MDMA_CxISR_CTCIF0   = {.msk = 0x00000002U, .pos = 1};    /** @brief Channel x channel transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0. */
  static const field32_t MDMA_MDMA_CxISR_BRTIF0   = {.msk = 0x00000004U, .pos = 2};    /** @brief Channel x block repeat transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
  static const field32_t MDMA_MDMA_CxISR_BTIF0    = {.msk = 0x00000008U, .pos = 3};    /** @brief Channel x block transfer complete interrupt flag this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the dma_ifcry register. */
  static const field32_t MDMA_MDMA_CxISR_TCIF0    = {.msk = 0x00000010U, .pos = 4};    /** @brief Channel x buffer transfer complete. */
  static const field32_t MDMA_MDMA_CxISR_CRQA0    = {.msk = 0x00010000U, .pos = 16};   /** @brief Channel x request active flag. */
  static const field32_t MDMA_MDMA_CxIFCR_CTEIF0  = {.msk = 0x00000001U, .pos = 0};    /** @brief Channel x clear transfer error interrupt flag writing a 1 into this bit clears teifx in the mdma_isry register. */
  static const field32_t MDMA_MDMA_CxIFCR_CCTCIF0 = {.msk = 0x00000002U, .pos = 1};    /** @brief Clear channel transfer complete interrupt flag for channel x writing a 1 into this bit clears ctcifx in the mdma_isry register. */
  static const field32_t MDMA_MDMA_CxIFCR_CBRTIF0 = {.msk = 0x00000004U, .pos = 2};    /** @brief Channel x clear block repeat transfer complete interrupt flag writing a 1 into this bit clears brtifx in the mdma_isry register. */
  static const field32_t MDMA_MDMA_CxIFCR_CBTIF0  = {.msk = 0x00000008U, .pos = 3};    /** @brief Channel x clear block transfer complete interrupt flag writing a 1 into this bit clears btifx in the mdma_isry register. */
  static const field32_t MDMA_MDMA_CxIFCR_CLTCIF0 = {.msk = 0x00000010U, .pos = 4};    /** @brief CLear buffer transfer complete interrupt flag for channel x writing a 1 into this bit clears tcifx in the mdma_isry register. */
  static const field32_t MDMA_MDMA_CxESR_TEA      = {.msk = 0x0000007FU, .pos = 0};    /** @brief Transfer error address these bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 lsbits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: the SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: it is not set in case of a link data error. */
  static const field32_t MDMA_MDMA_CxESR_TED      = {.msk = 0x00000080U, .pos = 7};    /** @brief Transfer error direction these bit is set and cleared by HW, in case of an MDMA data transfer error. */
  static const field32_t MDMA_MDMA_CxESR_TELD     = {.msk = 0x00000100U, .pos = 8};    /** @brief Transfer error link data these bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
  static const field32_t MDMA_MDMA_CxESR_TEMD     = {.msk = 0x00000200U, .pos = 9};    /** @brief Transfer error mask data these bit is set by HW, in case of a transfer error while writing the mask data. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
  static const field32_t MDMA_MDMA_CxESR_ASE      = {.msk = 0x00000400U, .pos = 10};   /** @brief Address/Size error these bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
  static const field32_t MDMA_MDMA_CxESR_BSE      = {.msk = 0x00000800U, .pos = 11};   /** @brief Block size error these bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the cteifx bit in the dma_ifcry register. */
  static const field32_t MDMA_MDMA_CxCR_EN        = {.msk = 0x00000001U, .pos = 0};    /** @brief Channel enable. */
  static const field32_t MDMA_MDMA_CxCR_TEIE      = {.msk = 0x00000002U, .pos = 1};    /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
  static const field32_t MDMA_MDMA_CxCR_CTCIE     = {.msk = 0x00000004U, .pos = 2};    /** @brief Channel transfer complete interrupt enable this bit is set and cleared by software. */
  static const field32_t MDMA_MDMA_CxCR_BRTIE     = {.msk = 0x00000008U, .pos = 3};    /** @brief Block repeat transfer interrupt enable this bit is set and cleared by software. */
  static const field32_t MDMA_MDMA_CxCR_BTIE      = {.msk = 0x00000010U, .pos = 4};    /** @brief Block transfer interrupt enable this bit is set and cleared by software. */
  static const field32_t MDMA_MDMA_CxCR_TCIE      = {.msk = 0x00000020U, .pos = 5};    /** @brief Buffer transfer complete interrupt enable this bit is set and cleared by software. */
  static const field32_t MDMA_MDMA_CxCR_PL        = {.msk = 0x000000C0U, .pos = 6};    /** @brief Priority level these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. */
  static const field32_t MDMA_MDMA_CxCR_BEX       = {.msk = 0x00001000U, .pos = 12};   /** @brief Byte endianness exchange. */
  static const field32_t MDMA_MDMA_CxCR_HEX       = {.msk = 0x00002000U, .pos = 13};   /** @brief Half word endianes exchange. */
  static const field32_t MDMA_MDMA_CxCR_WEX       = {.msk = 0x00004000U, .pos = 14};   /** @brief Word endianness exchange. */
  static const field32_t MDMA_MDMA_CxCR_SWRQ      = {.msk = 0x00010000U, .pos = 16};   /** @brief SW request writing a 1 into this bit sets the crqax in mdma_isry register, activating the request on channel x note: either the whole cxcr register or the 8-bit/16-bit register @ address offset: 0x4e + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor cxmar write access). */
  static const field32_t MDMA_MDMA_CxTCR_SINC     = {.msk = 0x00000003U, .pos = 0};    /** @brief Source increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when source is AHB (SBUS=1), SINC = 00 is forbidden. In linked list mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00). */
  static const field32_t MDMA_MDMA_CxTCR_DINC     = {.msk = 0x0000000CU, .pos = 2};    /** @brief Destination increment mode these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: when destination is AHB (DBUS=1), DINC = 00 is forbidden. */
  static const field32_t MDMA_MDMA_CxTCR_SSIZE    = {.msk = 0x00000030U, .pos = 4};    /** @brief Source data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0 note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1). */
  static const field32_t MDMA_MDMA_CxTCR_DSIZE    = {.msk = 0x000000C0U, .pos = 6};    /** @brief Destination data size these bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: if a value of 11 is programmed for the TCM access/ahb port, a transfer error will occur (TEIF bit set) if DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1). */
  static const field32_t MDMA_MDMA_CxTCR_SINCOS   = {.msk = 0x00000300U, .pos = 8};    /** @brief Source increment offset size. */
  static const field32_t MDMA_MDMA_CxTCR_DINCOS   = {.msk = 0x00000C00U, .pos = 10};   /** @brief Destination increment offset. */
  static const field32_t MDMA_MDMA_CxTCR_SBURST   = {.msk = 0x00007000U, .pos = 12};   /** @brief Source burst transfer configuration. */
  static const field32_t MDMA_MDMA_CxTCR_DBURST   = {.msk = 0x00038000U, .pos = 15};   /** @brief Destination burst transfer configuration. */
  static const field32_t MDMA_MDMA_CxTCR_TLEN     = {.msk = 0x01FC0000U, .pos = 18};   /** @brief Buffer transfer lengh. */
  static const field32_t MDMA_MDMA_CxTCR_PKE      = {.msk = 0x02000000U, .pos = 25};   /** @brief PacK enable these bit is set and cleared by software. If the source size is smaller than the destination, it will be padded according to the PAM value. If the source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0. */
  static const field32_t MDMA_MDMA_CxTCR_PAM      = {.msk = 0x0C000000U, .pos = 26};   /** @brief Padding/Alignement mode these bits are set and cleared by software. Case 1: source data size smaller than destination data size - 3 options are valid. Case 2: source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0. */
  static const field32_t MDMA_MDMA_CxTCR_TRGM     = {.msk = 0x30000000U, .pos = 28};   /** @brief Trigger mode these bits are set and cleared by software. Note: if TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0. */
  static const field32_t MDMA_MDMA_CxTCR_SWRM     = {.msk = 0x40000000U, .pos = 30};   /** @brief SW request mode this bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the cxmar contains a valid address, the cxmdr value will also be written @ cxmar address. This bit is protected and can be written only if EN is 0. */
  static const field32_t MDMA_MDMA_CxTCR_BWM      = {.msk = 0x80000000U, .pos = 31};   /** @brief Bufferable write mode this bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: all MDMA destination accesses are non-cacheable. */
  static const field32_t MDMA_MDMA_CxBNDTR_BNDT   = {.msk = 0x0001FFFFU, .pos = 0};    /** @brief Block number of data to transfer. */
  static const field32_t MDMA_MDMA_CxBNDTR_BRSUM  = {.msk = 0x00040000U, .pos = 18};   /** @brief Block repeat source address update mode these bits are protected and can be written only if EN is 0. */
  static const field32_t MDMA_MDMA_CxBNDTR_BRDUM  = {.msk = 0x00080000U, .pos = 19};   /** @brief Block repeat destination address update mode these bits are protected and can be written only if EN is 0. */
  static const field32_t MDMA_MDMA_CxBNDTR_BRC    = {.msk = 0xFFF00000U, .pos = 20};   /** @brief Block repeat count this field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in linked list mode - i.e. Link address valid). These bits are protected and can be written only if EN is 0. */
  static const field32_t MDMA_MDMA_CxBRUR_SUV     = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Source adresse update value. */
  static const field32_t MDMA_MDMA_CxBRUR_DUV     = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief Destination address update. */
  static const field32_t MDMA_MDMA_CxTBR_TSEL     = {.msk = 0x0000003FU, .pos = 0};    /** @brief Trigger selection. */
  static const field32_t MDMA_MDMA_CxTBR_SBUS     = {.msk = 0x00010000U, .pos = 16};   /** @brief Source BUS select this bit is protected and can be written only if EN is 0. */
  static const field32_t MDMA_MDMA_CxTBR_DBUS     = {.msk = 0x00020000U, .pos = 17};   /** @brief Destination BUS slect this bit is protected and can be written only if EN is 0. */

  /**** Enumerated MDMA Register Field Definitions ****/

  static field32_t const MDMA_MDMA_GISR0_GIFx[16] = {
    [0]  = {.msk = 0x00000001U, .pos = 0},    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex). */
    [1]  = {.msk = 0x00000002U, .pos = 1},    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex). */
    [2]  = {.msk = 0x00000004U, .pos = 2},    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex). */
    [3]  = {.msk = 0x00000008U, .pos = 3},    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex). */
    [4]  = {.msk = 0x00000010U, .pos = 4},    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex). */
    [5]  = {.msk = 0x00000020U, .pos = 5},    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex). */
    [6]  = {.msk = 0x00000040U, .pos = 6},    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex). */
    [7]  = {.msk = 0x00000080U, .pos = 7},    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex). */
    [8]  = {.msk = 0x00000100U, .pos = 8},    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex). */
    [9]  = {.msk = 0x00000200U, .pos = 9},    /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex). */
    [10] = {.msk = 0x00000400U, .pos = 10},   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex). */
    [11] = {.msk = 0x00000800U, .pos = 11},   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex). */
    [12] = {.msk = 0x00001000U, .pos = 12},   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex). */
    [13] = {.msk = 0x00002000U, .pos = 13},   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex). */
    [14] = {.msk = 0x00004000U, .pos = 14},   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex). */
    [15] = {.msk = 0x00008000U, .pos = 15},   /** @brief Channel x global interrupt flag (x=...) this bit is set and reset by hardware. It is a logical OR of all the channel x interrupt flags (ctcifx, btifx, brtifx, teifx) which are enabled in the interrupt mask register (ctciex, btiex, brtiex, teiex). */
  };

  /************************************************************************************************
   * QUADSPI Definitions
   ************************************************************************************************/

  /**** QUADSPI Register Definitions ****/

  static const rw_reg32_t QUADSPI_CR    = (rw_reg32_t)0x52005000U;   /** @brief QUADSPI control register. */
  static const rw_reg32_t QUADSPI_DCR   = (rw_reg32_t)0x52005004U;   /** @brief QUADSPI device configuration register. */
  static const ro_reg32_t QUADSPI_SR    = (ro_reg32_t)0x52005008U;   /** @brief QUADSPI status register. */
  static const rw_reg32_t QUADSPI_FCR   = (rw_reg32_t)0x5200500CU;   /** @brief QUADSPI flag clear register. */
  static const rw_reg32_t QUADSPI_DLR   = (rw_reg32_t)0x52005010U;   /** @brief QUADSPI data length register. */
  static const rw_reg32_t QUADSPI_CCR   = (rw_reg32_t)0x52005014U;   /** @brief QUADSPI communication configuration register. */
  static const rw_reg32_t QUADSPI_AR    = (rw_reg32_t)0x52005018U;   /** @brief QUADSPI address register. */
  static const rw_reg32_t QUADSPI_ABR   = (rw_reg32_t)0x5200501CU;   /** @brief QUADSPI alternate bytes registers. */
  static const rw_reg32_t QUADSPI_DR    = (rw_reg32_t)0x52005020U;   /** @brief QUADSPI data register. */
  static const rw_reg32_t QUADSPI_PSMKR = (rw_reg32_t)0x52005024U;   /** @brief QUADSPI polling status mask register. */
  static const rw_reg32_t QUADSPI_PSMAR = (rw_reg32_t)0x52005028U;   /** @brief QUADSPI polling status match register. */
  static const rw_reg32_t QUADSPI_PIR   = (rw_reg32_t)0x5200502CU;   /** @brief QUADSPI polling interval register. */
  static const rw_reg32_t QUADSPI_LPTR  = (rw_reg32_t)0x52005030U;   /** @brief QUADSPI low-power timeout register. */

  /**** QUADSPI Register Field Definitions ****/

  static const field32_t QUADSPI_CR_EN           = {.msk = 0x00000001U, .pos = 0};    /** @brief Enable enable the QUADSPI. */
  static const field32_t QUADSPI_CR_ABORT        = {.msk = 0x00000002U, .pos = 1};    /** @brief Abort request this bit aborts the on-going command sequence. It is automatically reset once the abort is complete. This bit stops the current transfer. In polling mode or memory-mapped mode, this bit also reset the APM bit or the DM bit. */
  static const field32_t QUADSPI_CR_DMAEN        = {.msk = 0x00000004U, .pos = 2};    /** @brief DMA enable in indirect mode, DMA can be used to input or output data via the QUADSPI_DR register. DMA transfers are initiated when the FIFO threshold flag, FTF, is set. */
  static const field32_t QUADSPI_CR_TCEN         = {.msk = 0x00000008U, .pos = 3};    /** @brief Timeout counter enable this bit is valid only when memory-mapped mode (FMODE = 11) is selected. Activating this bit causes the chip select (ncs) to be released (and thus reduces consumption) if there has not been an access after a certain amount of time, where this time is defined by TIMEOUT[15:0] (QUADSPI_LPTR). Enable the timeout counter. By default, the QUADSPI never stops its prefetch operation, keeping the previous read operation active with ncs maintained low, even if no access to the flash memory occurs for a long time. Since flash memories tend to consume more when ncs is held low, the application might want to activate the timeout counter (TCEN = 1, QUADSPI_CR[3]) so that ncs is released after a period of TIMEOUT[15:0] (QUADSPI_LPTR) cycles have elapsed without an access since when the FIFO becomes full with prefetch data. This bit can be modified only when BUSY = 0. */
  static const field32_t QUADSPI_CR_SSHIFT       = {.msk = 0x00000010U, .pos = 4};    /** @brief Sample shift by default, the QUADSPI samples data 1/2 of a CLK cycle after the data is driven by the flash memory. This bit allows the data is to be sampled later in order to account for external signal delays. Firmware must assure that SSHIFT = 0 when in DDR mode (when DDRM = 1). This field can be modified only when BUSY = 0. */
  static const field32_t QUADSPI_CR_DFM          = {.msk = 0x00000040U, .pos = 6};    /** @brief Dual-flash mode this bit activates dual-flash mode, where two external flash memories are used simultaneously to double throughput and capacity. This bit can be modified only when BUSY = 0. */
  static const field32_t QUADSPI_CR_FSEL         = {.msk = 0x00000080U, .pos = 7};    /** @brief Flash memory selection this bit selects the flash memory to be addressed in single flash mode (when DFM = 0). This bit can be modified only when BUSY = 0. This bit is ignored when DFM = 1. */
  static const field32_t QUADSPI_CR_FTHRES       = {.msk = 0x00001F00U, .pos = 8};    /** @brief FIFO threshold level defines, in indirect mode, the threshold number of bytes in the FIFO that will cause the FIFO threshold flag (FTF, QUADSPI_SR[2]) to be set. In indirect write mode (FMODE = 00): ... In indirect read mode (FMODE = 01): ... If DMAEN = 1, then the DMA controller for the corresponding channel must be disabled before changing the FTHRES value. */
  static const field32_t QUADSPI_CR_TEIE         = {.msk = 0x00010000U, .pos = 16};   /** @brief Transfer error interrupt enable this bit enables the transfer error interrupt. */
  static const field32_t QUADSPI_CR_TCIE         = {.msk = 0x00020000U, .pos = 17};   /** @brief Transfer complete interrupt enable this bit enables the transfer complete interrupt. */
  static const field32_t QUADSPI_CR_FTIE         = {.msk = 0x00040000U, .pos = 18};   /** @brief FIFO threshold interrupt enable this bit enables the FIFO threshold interrupt. */
  static const field32_t QUADSPI_CR_SMIE         = {.msk = 0x00080000U, .pos = 19};   /** @brief Status match interrupt enable this bit enables the status match interrupt. */
  static const field32_t QUADSPI_CR_TOIE         = {.msk = 0x00100000U, .pos = 20};   /** @brief TimeOut interrupt enable this bit enables the timeout interrupt. */
  static const field32_t QUADSPI_CR_APMS         = {.msk = 0x00400000U, .pos = 22};   /** @brief Automatic poll mode stop this bit determines if automatic polling is stopped after a match. This bit can be modified only when BUSY = 0. */
  static const field32_t QUADSPI_CR_PMM          = {.msk = 0x00800000U, .pos = 23};   /** @brief Polling match mode this bit indicates which method should be used for determining a match during automatic polling mode. This bit can be modified only when BUSY = 0. */
  static const field32_t QUADSPI_CR_PRESCALER    = {.msk = 0xFF000000U, .pos = 24};   /** @brief Clock prescaler. */
  static const field32_t QUADSPI_DCR_CKMODE      = {.msk = 0x00000001U, .pos = 0};    /** @brief Indicates the level that clk takes between command. */
  static const field32_t QUADSPI_DCR_CSHT        = {.msk = 0x00000700U, .pos = 8};    /** @brief Chip select high time CSHT+1 defines the minimum number of CLK cycles which the chip select (ncs) must remain high between commands issued to the flash memory. ... This field can be modified only when BUSY = 0. */
  static const field32_t QUADSPI_DCR_FSIZE       = {.msk = 0x001F0000U, .pos = 16};   /** @brief Flash memory size this field defines the size of external memory using the following formula: number of bytes in flash memory = 2[FSIZE+1] FSIZE+1 is effectively the number of address bits required to address the flash memory. The flash memory capacity can be up to 4GB (addressed using 32 bits) in indirect mode, but the addressable space in memory-mapped mode is limited to 256MB. If DFM = 1, FSIZE indicates the total capacity of the two flash memories together. This field can be modified only when BUSY = 0. */
  static const field32_t QUADSPI_SR_TEF          = {.msk = 0x00000001U, .pos = 0};    /** @brief Transfer error flag this bit is set in indirect mode when an invalid address is being accessed in indirect mode. It is cleared by writing 1 to CTEF. */
  static const field32_t QUADSPI_SR_TCF          = {.msk = 0x00000002U, .pos = 1};    /** @brief Transfer complete flag this bit is set in indirect mode when the programmed number of data has been transferred or in any mode when the transfer has been aborted.it is cleared by writing 1 to CTCF. */
  static const field32_t QUADSPI_SR_FTF          = {.msk = 0x00000004U, .pos = 2};    /** @brief FIFO threshold flag in indirect mode, this bit is set when the FIFO threshold has been reached, or if there is any data left in the FIFO after reads from the flash memory are complete. It is cleared automatically as soon as threshold condition is no longer true. In automatic polling mode this bit is set every time the status register is read, and the bit is cleared when the data register is read. */
  static const field32_t QUADSPI_SR_SMF          = {.msk = 0x00000008U, .pos = 3};    /** @brief Status match flag this bit is set in automatic polling mode when the unmasked received data matches the corresponding bits in the match register (QUADSPI_PSMAR). It is cleared by writing 1 to CSMF. */
  static const field32_t QUADSPI_SR_TOF          = {.msk = 0x00000010U, .pos = 4};    /** @brief Timeout flag this bit is set when timeout occurs. It is cleared by writing 1 to CTOF. */
  static const field32_t QUADSPI_SR_BUSY         = {.msk = 0x00000020U, .pos = 5};    /** @brief Busy this bit is set when an operation is on going. This bit clears automatically when the operation with the flash memory is finished and the FIFO is empty. */
  static const field32_t QUADSPI_SR_FLEVEL       = {.msk = 0x00003F00U, .pos = 8};    /** @brief FIFO level this field gives the number of valid bytes which are being held in the FIFO. FLEVEL = 0 when the FIFO is empty, and 16 when it is full. In memory-mapped mode and in automatic status polling mode, FLEVEL is zero. */
  static const field32_t QUADSPI_FCR_CTEF        = {.msk = 0x00000001U, .pos = 0};    /** @brief Clear transfer error flag writing 1 clears the TEF flag in the QUADSPI_SR register. */
  static const field32_t QUADSPI_FCR_CTCF        = {.msk = 0x00000002U, .pos = 1};    /** @brief Clear transfer complete flag writing 1 clears the TCF flag in the QUADSPI_SR register. */
  static const field32_t QUADSPI_FCR_CSMF        = {.msk = 0x00000008U, .pos = 3};    /** @brief Clear status match flag writing 1 clears the SMF flag in the QUADSPI_SR register. */
  static const field32_t QUADSPI_FCR_CTOF        = {.msk = 0x00000010U, .pos = 4};    /** @brief Clear timeout flag writing 1 clears the TOF flag in the QUADSPI_SR register. */
  static const field32_t QUADSPI_CCR_INSTRUCTION = {.msk = 0x000000FFU, .pos = 0};    /** @brief Instruction instruction to be send to the external SPI device. This field can be written only when BUSY = 0. */
  static const field32_t QUADSPI_CCR_IMODE       = {.msk = 0x00000300U, .pos = 8};    /** @brief Instruction mode this field defines the instruction phase mode of operation: this field can be written only when BUSY = 0. */
  static const field32_t QUADSPI_CCR_ADMODE      = {.msk = 0x00000C00U, .pos = 10};   /** @brief Address mode this field defines the address phase mode of operation: this field can be written only when BUSY = 0. */
  static const field32_t QUADSPI_CCR_ADSIZE      = {.msk = 0x00003000U, .pos = 12};   /** @brief Address size this bit defines address size: this field can be written only when BUSY = 0. */
  static const field32_t QUADSPI_CCR_ABMODE      = {.msk = 0x0000C000U, .pos = 14};   /** @brief Alternate bytes mode this field defines the alternate-bytes phase mode of operation: this field can be written only when BUSY = 0. */
  static const field32_t QUADSPI_CCR_ABSIZE      = {.msk = 0x00030000U, .pos = 16};   /** @brief Alternate bytes size this bit defines alternate bytes size: this field can be written only when BUSY = 0. */
  static const field32_t QUADSPI_CCR_DCYC        = {.msk = 0x007C0000U, .pos = 18};   /** @brief Number of dummy cycles this field defines the duration of the dummy phase. In both SDR and DDR modes, it specifies a number of CLK cycles (0-31). This field can be written only when BUSY = 0. */
  static const field32_t QUADSPI_CCR_DMODE       = {.msk = 0x03000000U, .pos = 24};   /** @brief Data mode this field defines the data phases mode of operation: this field also determines the dummy phase mode of operation. This field can be written only when BUSY = 0. */
  static const field32_t QUADSPI_CCR_FMODE       = {.msk = 0x0C000000U, .pos = 26};   /** @brief Functional mode this field defines the QUADSPI functional mode of operation. If DMAEN = 1 already, then the DMA controller for the corresponding channel must be disabled before changing the FMODE value. This field can be written only when BUSY = 0. */
  static const field32_t QUADSPI_CCR_SIOO        = {.msk = 0x10000000U, .pos = 28};   /** @brief Send instruction only once mode see section15.3.11: sending the instruction only once on page13. This bit has no effect when IMODE = 00. This field can be written only when BUSY = 0. */
  static const field32_t QUADSPI_CCR_DHHC        = {.msk = 0x40000000U, .pos = 30};   /** @brief DDR hold delay the data output by 1/4 of the QUADSPI output clock cycle in DDR mode: this feature is only active in DDR mode. This field can be written only when BUSY = 0. */
  static const field32_t QUADSPI_CCR_DDRM        = {.msk = 0x80000000U, .pos = 31};   /** @brief Double data rate mode this bit sets the DDR mode for the address, alternate byte and data phase: this field can be written only when BUSY = 0. */
  static const field32_t QUADSPI_PIR_INTERVAL    = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Polling interval number of CLK cycles between to read during automatic polling phases. This field can be written only when BUSY = 0. */
  static const field32_t QUADSPI_LPTR_TIMEOUT    = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timeout period after each access in memory-mapped mode, the QUADSPI prefetches the subsequent bytes and holds these bytes in the FIFO. This field indicates how many CLK cycles the QUADSPI waits after the FIFO becomes full until it raises ncs, putting the flash memory in a lower-consumption state. This field can be written only when BUSY = 0. */

  /************************************************************************************************
   * RNG Definitions
   ************************************************************************************************/

  /**** RNG Register Definitions ****/

  static const rw_reg32_t RNG_CR = (rw_reg32_t)0x48021800U;   /** @brief RNG control register. */
  static const rw_reg32_t RNG_SR = (rw_reg32_t)0x48021804U;   /** @brief RNG status register. */
  static const ro_reg32_t RNG_DR = (ro_reg32_t)0x48021808U;   /** @brief The RNG_DR register is a read-only register that delivers a 32-bit random value when read. The content of this register is valid when DRDY= 1, even if RNGEN=0. */

  /**** RNG Register Field Definitions ****/

  static const field32_t RNG_CR_RNGEN = {.msk = 0x00000004U, .pos = 2};   /** @brief Random number generator enable. */
  static const field32_t RNG_CR_IE    = {.msk = 0x00000008U, .pos = 3};   /** @brief Interrupt enable. */
  static const field32_t RNG_CR_CED   = {.msk = 0x00000020U, .pos = 5};   /** @brief Clock error detection note: the clock error detection can be used only when ck_rc48 or ck_pll1_q (ck_pll1_q = 48mhz) source is selected otherwise, CED bit must be equal to 1. The clock error detection cannot be enabled nor disabled on the fly when RNG peripheral is enabled, to enable or disable CED the RNG must be disabled. */
  static const field32_t RNG_SR_DRDY  = {.msk = 0x00000001U, .pos = 0};   /** @brief Data ready note: if IE=1 in RNG_CR, an interrupt is generated when DRDY=1. It can rise when the peripheral is disabled. When the output buffer becomes empty (after reading RNG_DR), this bit returns to 0 until a new random value is generated. */
  static const field32_t RNG_SR_CECS  = {.msk = 0x00000002U, .pos = 1};   /** @brief Clock error current status note: this bit is meaningless if CED (clock error detection) bit in RNG_CR is equal to 1. */
  static const field32_t RNG_SR_SECS  = {.msk = 0x00000004U, .pos = 2};   /** @brief Seed error current status ** more than 64 consecutive bits at the same value (0 or 1) ** more than 32 consecutive alternances of 0 and 1 (0101010101...01). */
  static const field32_t RNG_SR_CEIS  = {.msk = 0x00000020U, .pos = 5};   /** @brief Clock error interrupt status this bit is set at the same time as CECS. It is cleared by writing it to 0. An interrupt is pending if IE = 1 in the RNG_CR register. Note: this bit is meaningless if CED (clock error detection) bit in RNG_CR is equal to 1. */
  static const field32_t RNG_SR_SEIS  = {.msk = 0x00000040U, .pos = 6};   /** @brief Seed error interrupt status this bit is set at the same time as SECS. It is cleared by writing it to 0. ** more than 64 consecutive bits at the same value (0 or 1) ** more than 32 consecutive alternances of 0 and 1 (0101010101...01) an interrupt is pending if IE = 1 in the RNG_CR register. */

  /************************************************************************************************
   * RTC Definitions
   ************************************************************************************************/

  /**** RTC Register Definitions ****/

  static const rw_reg32_t RTC_RTC_TR       = (rw_reg32_t)0x58004000U;   /** @brief The RTC_TR is the calendar time shadow register. This register must be written in initialization mode only. Refer to calendar initialization and configuration on page9 and reading the calendar on page10.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
  static const rw_reg32_t RTC_RTC_DR       = (rw_reg32_t)0x58004004U;   /** @brief The RTC_DR is the calendar date shadow register. This register must be written in initialization mode only. Refer to calendar initialization and configuration on page9 and reading the calendar on page10.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
  static const rw_reg32_t RTC_RTC_CR       = (rw_reg32_t)0x58004008U;   /** @brief RTC control register. */
  static const rw_reg32_t RTC_RTC_ISR      = (rw_reg32_t)0x5800400CU;   /** @brief This register is write protected (except for RTC_ISR[13:8] bits). The write access procedure is described in RTC register write protection on page9. */
  static const rw_reg32_t RTC_RTC_PRER     = (rw_reg32_t)0x58004010U;   /** @brief This register must be written in initialization mode only. The initialization must be performed in two separate write accesses. Refer to calendar initialization and configuration on page9.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
  static const rw_reg32_t RTC_RTC_WUTR     = (rw_reg32_t)0x58004014U;   /** @brief This register can be written only when WUTWF is set to 1 in rtc_isr.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
  static const rw_reg32_t RTC_RTC_ALRMAR   = (rw_reg32_t)0x5800401CU;   /** @brief This register can be written only when ALRAWF is set to 1 in RTC_ISR, or in initialization mode.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
  static const rw_reg32_t RTC_RTC_ALRMBR   = (rw_reg32_t)0x58004020U;   /** @brief This register can be written only when ALRBWF is set to 1 in RTC_ISR, or in initialization mode.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
  static const rw_reg32_t RTC_RTC_WPR      = (rw_reg32_t)0x58004024U;   /** @brief RTC write protection register. */
  static const ro_reg32_t RTC_RTC_SSR      = (ro_reg32_t)0x58004028U;   /** @brief RTC sub second register. */
  static const rw_reg32_t RTC_RTC_SHIFTR   = (rw_reg32_t)0x5800402CU;   /** @brief This register is write protected. The write access procedure is described in RTC register write protection on page9. */
  static const ro_reg32_t RTC_RTC_TSTR     = (ro_reg32_t)0x58004030U;   /** @brief The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset. */
  static const ro_reg32_t RTC_RTC_TSDR     = (ro_reg32_t)0x58004034U;   /** @brief The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset. */
  static const ro_reg32_t RTC_RTC_TSSSR    = (ro_reg32_t)0x58004038U;   /** @brief The content of this register is valid only when RTC_ISR/TSF is set. It is cleared when the RTC_ISR/TSF bit is reset. */
  static const rw_reg32_t RTC_RTC_CALR     = (rw_reg32_t)0x5800403CU;   /** @brief This register is write protected. The write access procedure is described in RTC register write protection on page9. */
  static const rw_reg32_t RTC_RTC_TAMPCR   = (rw_reg32_t)0x58004040U;   /** @brief RTC tamper and alternate function configuration register. */
  static const rw_reg32_t RTC_RTC_ALRMASSR = (rw_reg32_t)0x58004044U;   /** @brief This register can be written only when ALRAE is reset in RTC_CR register, or in initialization mode.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
  static const rw_reg32_t RTC_RTC_ALRMBSSR = (rw_reg32_t)0x58004048U;   /** @brief This register can be written only when ALRBE is reset in RTC_CR register, or in initialization mode.this register is write protected.the write access procedure is described in section: RTC register write protection. */
  static const rw_reg32_t RTC_RTC_OR       = (rw_reg32_t)0x5800404CU;   /** @brief RTC option register. */

  /**** Enumerated RTC Register Definitions ****/

  static const rw_reg32_t RTC_RTC_BKPxR[32] = {
    [0]  = (rw_reg32_t)0x58004050U,   /** @brief RTC backup registers. */
    [1]  = (rw_reg32_t)0x58004054U,   /** @brief RTC backup registers. */
    [2]  = (rw_reg32_t)0x58004058U,   /** @brief RTC backup registers. */
    [3]  = (rw_reg32_t)0x5800405CU,   /** @brief RTC backup registers. */
    [4]  = (rw_reg32_t)0x58004060U,   /** @brief RTC backup registers. */
    [5]  = (rw_reg32_t)0x58004064U,   /** @brief RTC backup registers. */
    [6]  = (rw_reg32_t)0x58004068U,   /** @brief RTC backup registers. */
    [7]  = (rw_reg32_t)0x5800406CU,   /** @brief RTC backup registers. */
    [8]  = (rw_reg32_t)0x58004070U,   /** @brief RTC backup registers. */
    [9]  = (rw_reg32_t)0x58004074U,   /** @brief RTC backup registers. */
    [10] = (rw_reg32_t)0x58004078U,   /** @brief RTC backup registers. */
    [11] = (rw_reg32_t)0x5800407CU,   /** @brief RTC backup registers. */
    [12] = (rw_reg32_t)0x58004080U,   /** @brief RTC backup registers. */
    [13] = (rw_reg32_t)0x58004084U,   /** @brief RTC backup registers. */
    [14] = (rw_reg32_t)0x58004088U,   /** @brief RTC backup registers. */
    [15] = (rw_reg32_t)0x5800408CU,   /** @brief RTC backup registers. */
    [16] = (rw_reg32_t)0x58004090U,   /** @brief RTC backup registers. */
    [17] = (rw_reg32_t)0x58004094U,   /** @brief RTC backup registers. */
    [18] = (rw_reg32_t)0x58004098U,   /** @brief RTC backup registers. */
    [19] = (rw_reg32_t)0x5800409CU,   /** @brief RTC backup registers. */
    [20] = (rw_reg32_t)0x580040A0U,   /** @brief RTC backup registers. */
    [21] = (rw_reg32_t)0x580040A4U,   /** @brief RTC backup registers. */
    [22] = (rw_reg32_t)0x580040A8U,   /** @brief RTC backup registers. */
    [23] = (rw_reg32_t)0x580040ACU,   /** @brief RTC backup registers. */
    [24] = (rw_reg32_t)0x580040B0U,   /** @brief RTC backup registers. */
    [25] = (rw_reg32_t)0x580040B4U,   /** @brief RTC backup registers. */
    [26] = (rw_reg32_t)0x580040B8U,   /** @brief RTC backup registers. */
    [27] = (rw_reg32_t)0x580040BCU,   /** @brief RTC backup registers. */
    [28] = (rw_reg32_t)0x580040C0U,   /** @brief RTC backup registers. */
    [29] = (rw_reg32_t)0x580040C4U,   /** @brief RTC backup registers. */
    [30] = (rw_reg32_t)0x580040C8U,   /** @brief RTC backup registers. */
    [31] = (rw_reg32_t)0x580040CCU,   /** @brief RTC backup registers. */
  };

  /**** RTC Register Field Definitions ****/

  static const field32_t RTC_RTC_TR_SU             = {.msk = 0x0000000FU, .pos = 0};    /** @brief Second units in BCD format. */
  static const field32_t RTC_RTC_TR_ST             = {.msk = 0x00000070U, .pos = 4};    /** @brief Second tens in BCD format. */
  static const field32_t RTC_RTC_TR_MNU            = {.msk = 0x00000F00U, .pos = 8};    /** @brief Minute units in BCD format. */
  static const field32_t RTC_RTC_TR_MNT            = {.msk = 0x00007000U, .pos = 12};   /** @brief Minute tens in BCD format. */
  static const field32_t RTC_RTC_TR_HU             = {.msk = 0x000F0000U, .pos = 16};   /** @brief Hour units in BCD format. */
  static const field32_t RTC_RTC_TR_HT             = {.msk = 0x00300000U, .pos = 20};   /** @brief Hour tens in BCD format. */
  static const field32_t RTC_RTC_TR_PM             = {.msk = 0x00400000U, .pos = 22};   /** @brief AM/PM notation. */
  static const field32_t RTC_RTC_DR_DU             = {.msk = 0x0000000FU, .pos = 0};    /** @brief Date units in BCD format. */
  static const field32_t RTC_RTC_DR_DT             = {.msk = 0x00000030U, .pos = 4};    /** @brief Date tens in BCD format. */
  static const field32_t RTC_RTC_DR_MU             = {.msk = 0x00000F00U, .pos = 8};    /** @brief Month units in BCD format. */
  static const field32_t RTC_RTC_DR_MT             = {.msk = 0x00001000U, .pos = 12};   /** @brief Month tens in BCD format. */
  static const field32_t RTC_RTC_DR_WDU            = {.msk = 0x0000E000U, .pos = 13};   /** @brief Week day units. */
  static const field32_t RTC_RTC_DR_YU             = {.msk = 0x000F0000U, .pos = 16};   /** @brief Year units in BCD format. */
  static const field32_t RTC_RTC_DR_YT             = {.msk = 0x00F00000U, .pos = 20};   /** @brief Year tens in BCD format. */
  static const field32_t RTC_RTC_CR_WUCKSEL        = {.msk = 0x00000007U, .pos = 0};    /** @brief Wakeup clock selection. */
  static const field32_t RTC_RTC_CR_TSEDGE         = {.msk = 0x00000008U, .pos = 3};    /** @brief Time-stamp event active edge TSE must be reset when TSEDGE is changed to avoid unwanted TSF setting. */
  static const field32_t RTC_RTC_CR_REFCKON        = {.msk = 0x00000010U, .pos = 4};    /** @brief RTC_REFIN reference clock detection enable (50 or 60hz) note: PREDIV_S must be 0x00ff. */
  static const field32_t RTC_RTC_CR_BYPSHAD        = {.msk = 0x00000020U, .pos = 5};    /** @brief Bypass the shadow registers note: if the frequency of the APB clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1. */
  static const field32_t RTC_RTC_CR_FMT            = {.msk = 0x00000040U, .pos = 6};    /** @brief Hour format. */
  static const field32_t RTC_RTC_CR_ALRAE          = {.msk = 0x00000100U, .pos = 8};    /** @brief Alarm A enable. */
  static const field32_t RTC_RTC_CR_ALRBE          = {.msk = 0x00000200U, .pos = 9};    /** @brief Alarm B enable. */
  static const field32_t RTC_RTC_CR_WUTE           = {.msk = 0x00000400U, .pos = 10};   /** @brief Wakeup timer enable. */
  static const field32_t RTC_RTC_CR_TSE            = {.msk = 0x00000800U, .pos = 11};   /** @brief Timestamp enable. */
  static const field32_t RTC_RTC_CR_ALRAIE         = {.msk = 0x00001000U, .pos = 12};   /** @brief Alarm A interrupt enable. */
  static const field32_t RTC_RTC_CR_ALRBIE         = {.msk = 0x00002000U, .pos = 13};   /** @brief Alarm B interrupt enable. */
  static const field32_t RTC_RTC_CR_WUTIE          = {.msk = 0x00004000U, .pos = 14};   /** @brief Wakeup timer interrupt enable. */
  static const field32_t RTC_RTC_CR_TSIE           = {.msk = 0x00008000U, .pos = 15};   /** @brief Time-stamp interrupt enable. */
  static const field32_t RTC_RTC_CR_ADD1H          = {.msk = 0x00010000U, .pos = 16};   /** @brief Add 1 hour (summer time change) when this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0. */
  static const field32_t RTC_RTC_CR_SUB1H          = {.msk = 0x00020000U, .pos = 17};   /** @brief Subtract 1 hour (winter time change) when this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0. Setting this bit has no effect when current hour is 0. */
  static const field32_t RTC_RTC_CR_BKP            = {.msk = 0x00040000U, .pos = 18};   /** @brief Backup this bit can be written by the user to memorize whether the daylight saving time change has been performed or not. */
  static const field32_t RTC_RTC_CR_COSEL          = {.msk = 0x00080000U, .pos = 19};   /** @brief Calibration output selection when COE=1, this bit selects which signal is output on RTC_CALIB. These frequencies are valid for RTCCLK at 32.768 khz and prescalers at their default values (PREDIV_A=127 and PREDIV_S=255). Refer to section24.3.15: calibration clock output. */
  static const field32_t RTC_RTC_CR_POL            = {.msk = 0x00100000U, .pos = 20};   /** @brief Output polarity this bit is used to configure the polarity of RTC_ALARM output. */
  static const field32_t RTC_RTC_CR_OSEL           = {.msk = 0x00600000U, .pos = 21};   /** @brief Output selection these bits are used to select the flag to be routed to RTC_ALARM output. */
  static const field32_t RTC_RTC_CR_COE            = {.msk = 0x00800000U, .pos = 23};   /** @brief Calibration output enable this bit enables the RTC_CALIB output. */
  static const field32_t RTC_RTC_CR_ITSE           = {.msk = 0x01000000U, .pos = 24};   /** @brief Timestamp on internal event enable. */
  static const field32_t RTC_RTC_ISR_ALRAWF        = {.msk = 0x00000001U, .pos = 0};    /** @brief Alarm A write flag this bit is set by hardware when alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode. */
  static const field32_t RTC_RTC_ISR_ALRBWF        = {.msk = 0x00000002U, .pos = 1};    /** @brief Alarm B write flag this bit is set by hardware when alarm B values can be changed, after the ALRBE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode. */
  static const field32_t RTC_RTC_ISR_WUTWF         = {.msk = 0x00000004U, .pos = 2};    /** @brief Wakeup timer write flag this bit is set by hardware up to 2 RTCCLK cycles after the WUTE bit has been set to 0 in RTC_CR, and is cleared up to 2 RTCCLK cycles after the WUTE bit has been set to 1. The wakeup timer values can be changed when WUTE bit is cleared and WUTWF is set. */
  static const field32_t RTC_RTC_ISR_SHPF          = {.msk = 0x00000008U, .pos = 3};    /** @brief Shift operation pending this flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect. */
  static const field32_t RTC_RTC_ISR_INITS         = {.msk = 0x00000010U, .pos = 4};    /** @brief Initialization status flag this bit is set by hardware when the calendar year field is different from 0 (backup domain reset state). */
  static const field32_t RTC_RTC_ISR_RSF           = {.msk = 0x00000020U, .pos = 5};    /** @brief Registers synchronization flag this bit is set by hardware each time the calendar registers are copied into the shadow registers (rtc_ssrx, rtc_trx and rtc_drx). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF=1), or when in bypass shadow register mode (BYPSHAD=1). This bit can also be cleared by software. It is cleared either by software or by hardware in initialization mode. */
  static const field32_t RTC_RTC_ISR_INITF         = {.msk = 0x00000040U, .pos = 6};    /** @brief Initialization flag when this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated. */
  static const field32_t RTC_RTC_ISR_INIT          = {.msk = 0x00000080U, .pos = 7};    /** @brief Initialization mode. */
  static const field32_t RTC_RTC_ISR_ALRAF         = {.msk = 0x00000100U, .pos = 8};    /** @brief Alarm A flag this flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm A register (RTC_ALRMAR). This flag is cleared by software by writing 0. */
  static const field32_t RTC_RTC_ISR_ALRBF         = {.msk = 0x00000200U, .pos = 9};    /** @brief Alarm B flag this flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm B register (RTC_ALRMBR). This flag is cleared by software by writing 0. */
  static const field32_t RTC_RTC_ISR_WUTF          = {.msk = 0x00000400U, .pos = 10};   /** @brief Wakeup timer flag this flag is set by hardware when the wakeup auto-reload counter reaches 0. This flag is cleared by software by writing 0. This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again. */
  static const field32_t RTC_RTC_ISR_TSF           = {.msk = 0x00000800U, .pos = 11};   /** @brief Time-stamp flag this flag is set by hardware when a time-stamp event occurs. This flag is cleared by software by writing 0. */
  static const field32_t RTC_RTC_ISR_TSOVF         = {.msk = 0x00001000U, .pos = 12};   /** @brief Time-stamp overflow flag this flag is set by hardware when a time-stamp event occurs while TSF is already set. This flag is cleared by software by writing 0. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a time-stamp event occurs immediately before the TSF bit is cleared. */
  static const field32_t RTC_RTC_ISR_RECALPF       = {.msk = 0x00010000U, .pos = 16};   /** @brief Recalibration pending flag the RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to re-calibration on-the-fly. */
  static const field32_t RTC_RTC_ISR_ITSF          = {.msk = 0x00020000U, .pos = 17};   /** @brief Internal ttime-stamp flag. */
  static const field32_t RTC_RTC_PRER_PREDIV_S     = {.msk = 0x00007FFFU, .pos = 0};    /** @brief Synchronous prescaler factor this is the synchronous division factor: ck_spre frequency = ck_apre frequency/(prediv_s+1). */
  static const field32_t RTC_RTC_PRER_PREDIV_A     = {.msk = 0x007F0000U, .pos = 16};   /** @brief Asynchronous prescaler factor this is the asynchronous division factor: ck_apre frequency = RTCCLK frequency/(prediv_a+1). */
  static const field32_t RTC_RTC_WUTR_WUT          = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Wakeup auto-reload value bits when the wakeup timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0] + 1) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register when WUCKSEL[2] = 1, the wakeup timer becomes 17-bits and WUCKSEL[1] effectively becomes WUT[16] the most-significant bit to be reloaded into the timer. The first assertion of WUTF occurs (WUT+1) ck_wut cycles after WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] =011 (RTCCLK/2) is forbidden. */
  static const field32_t RTC_RTC_ALRMAR_SU         = {.msk = 0x0000000FU, .pos = 0};    /** @brief Second units in BCD format. */
  static const field32_t RTC_RTC_ALRMAR_ST         = {.msk = 0x00000070U, .pos = 4};    /** @brief Second tens in BCD format. */
  static const field32_t RTC_RTC_ALRMAR_MNU        = {.msk = 0x00000F00U, .pos = 8};    /** @brief Minute units in BCD format. */
  static const field32_t RTC_RTC_ALRMAR_MNT        = {.msk = 0x00007000U, .pos = 12};   /** @brief Minute tens in BCD format. */
  static const field32_t RTC_RTC_ALRMAR_HU         = {.msk = 0x000F0000U, .pos = 16};   /** @brief Hour units in BCD format. */
  static const field32_t RTC_RTC_ALRMAR_HT         = {.msk = 0x00300000U, .pos = 20};   /** @brief Hour tens in BCD format. */
  static const field32_t RTC_RTC_ALRMAR_PM         = {.msk = 0x00400000U, .pos = 22};   /** @brief AM/PM notation. */
  static const field32_t RTC_RTC_ALRMAR_DU         = {.msk = 0x0F000000U, .pos = 24};   /** @brief Date units or day in BCD format. */
  static const field32_t RTC_RTC_ALRMAR_DT         = {.msk = 0x30000000U, .pos = 28};   /** @brief Date tens in BCD format. */
  static const field32_t RTC_RTC_ALRMAR_WDSEL      = {.msk = 0x40000000U, .pos = 30};   /** @brief Week day selection. */
  static const field32_t RTC_RTC_ALRMBR_SU         = {.msk = 0x0000000FU, .pos = 0};    /** @brief Second units in BCD format. */
  static const field32_t RTC_RTC_ALRMBR_ST         = {.msk = 0x00000070U, .pos = 4};    /** @brief Second tens in BCD format. */
  static const field32_t RTC_RTC_ALRMBR_MNU        = {.msk = 0x00000F00U, .pos = 8};    /** @brief Minute units in BCD format. */
  static const field32_t RTC_RTC_ALRMBR_MNT        = {.msk = 0x00007000U, .pos = 12};   /** @brief Minute tens in BCD format. */
  static const field32_t RTC_RTC_ALRMBR_HU         = {.msk = 0x000F0000U, .pos = 16};   /** @brief Hour units in BCD format. */
  static const field32_t RTC_RTC_ALRMBR_HT         = {.msk = 0x00300000U, .pos = 20};   /** @brief Hour tens in BCD format. */
  static const field32_t RTC_RTC_ALRMBR_PM         = {.msk = 0x00400000U, .pos = 22};   /** @brief AM/PM notation. */
  static const field32_t RTC_RTC_ALRMBR_DU         = {.msk = 0x0F000000U, .pos = 24};   /** @brief Date units or day in BCD format. */
  static const field32_t RTC_RTC_ALRMBR_DT         = {.msk = 0x30000000U, .pos = 28};   /** @brief Date tens in BCD format. */
  static const field32_t RTC_RTC_ALRMBR_WDSEL      = {.msk = 0x40000000U, .pos = 30};   /** @brief Week day selection. */
  static const field32_t RTC_RTC_WPR_KEY           = {.msk = 0x000000FFU, .pos = 0};    /** @brief Write protection key this byte is written by software. Reading this byte always returns 0x00. Refer to RTC register write protection for a description of how to unlock RTC register write protection. */
  static const field32_t RTC_RTC_SSR_SS            = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Sub second value SS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below: second fraction = (PREDIV_S - SS) / (PREDIV_S + 1) note: SS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR. */
  static const field32_t RTC_RTC_SHIFTR_SUBFS      = {.msk = 0x00007FFFU, .pos = 0};    /** @brief Subtract a fraction of a second these bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). The value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by: delay (seconds) = SUBFS / (PREDIV_S + 1) A fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by: advance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))). Note: writing to SUBFS causes RSF to be cleared. Software can then wait until RSF=1 to be sure that the shadow registers have been updated with the shifted time. */
  static const field32_t RTC_RTC_SHIFTR_ADD1S      = {.msk = 0x80000000U, .pos = 31};   /** @brief Add one second this bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). This function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation. */
  static const field32_t RTC_RTC_TSTR_SU           = {.msk = 0x0000000FU, .pos = 0};    /** @brief Second units in BCD format. */
  static const field32_t RTC_RTC_TSTR_ST           = {.msk = 0x00000070U, .pos = 4};    /** @brief Second tens in BCD format. */
  static const field32_t RTC_RTC_TSTR_MNU          = {.msk = 0x00000F00U, .pos = 8};    /** @brief Minute units in BCD format. */
  static const field32_t RTC_RTC_TSTR_MNT          = {.msk = 0x00007000U, .pos = 12};   /** @brief Minute tens in BCD format. */
  static const field32_t RTC_RTC_TSTR_HU           = {.msk = 0x000F0000U, .pos = 16};   /** @brief Hour units in BCD format. */
  static const field32_t RTC_RTC_TSTR_HT           = {.msk = 0x00300000U, .pos = 20};   /** @brief Hour tens in BCD format. */
  static const field32_t RTC_RTC_TSTR_PM           = {.msk = 0x00400000U, .pos = 22};   /** @brief AM/PM notation. */
  static const field32_t RTC_RTC_TSDR_DU           = {.msk = 0x0000000FU, .pos = 0};    /** @brief Date units in BCD format. */
  static const field32_t RTC_RTC_TSDR_DT           = {.msk = 0x00000030U, .pos = 4};    /** @brief Date tens in BCD format. */
  static const field32_t RTC_RTC_TSDR_MU           = {.msk = 0x00000F00U, .pos = 8};    /** @brief Month units in BCD format. */
  static const field32_t RTC_RTC_TSDR_MT           = {.msk = 0x00001000U, .pos = 12};   /** @brief Month tens in BCD format. */
  static const field32_t RTC_RTC_TSDR_WDU          = {.msk = 0x0000E000U, .pos = 13};   /** @brief Week day units. */
  static const field32_t RTC_RTC_TSSSR_SS          = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Sub second value SS[15:0] is the value of the synchronous prescaler counter when the timestamp event occurred. */
  static const field32_t RTC_RTC_CALR_CALM         = {.msk = 0x000001FFU, .pos = 0};    /** @brief Calibration minus the frequency of the calendar is reduced by masking CALM out of 220 RTCCLK pulses (32 seconds if the input frequency is 32768 hz). This decreases the frequency of the calendar with a resolution of 0.9537 ppm. To increase the frequency of the calendar, this feature should be used in conjunction with CALP. See section24.3.12: RTC smooth digital calibration on page13. */
  static const field32_t RTC_RTC_CALR_CALP         = {.msk = 0x00008000U, .pos = 15};   /** @brief Increase frequency of RTC by 488.5 ppm this feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution. If the input frequency is 32768 hz, the number of RTCCLK pulses added during a 32-second window is calculated as follows: (512 * CALP) - CALM. Refer to section24.3.12: RTC smooth digital calibration. */
  static const field32_t RTC_RTC_TAMPCR_TAMPIE     = {.msk = 0x00000004U, .pos = 2};    /** @brief Tamper interrupt enable. */
  static const field32_t RTC_RTC_TAMPCR_TAMPTS     = {.msk = 0x00000080U, .pos = 7};    /** @brief Activate timestamp on tamper detection event TAMPTS is valid even if TSE=0 in the RTC_CR register. */
  static const field32_t RTC_RTC_TAMPCR_TAMPFREQ   = {.msk = 0x00000700U, .pos = 8};    /** @brief Tamper sampling frequency determines the frequency at which each of the rtc_tampx inputs are sampled. */
  static const field32_t RTC_RTC_TAMPCR_TAMPFLT    = {.msk = 0x00001800U, .pos = 11};   /** @brief RTC_TAMPx filter count these bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a tamper event. TAMPFLT is valid for each of the rtc_tampx inputs. */
  static const field32_t RTC_RTC_TAMPCR_TAMPPRCH   = {.msk = 0x00006000U, .pos = 13};   /** @brief RTC_TAMPx precharge duration these bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the rtc_tampx inputs. */
  static const field32_t RTC_RTC_TAMPCR_TAMPPUDIS  = {.msk = 0x00008000U, .pos = 15};   /** @brief RTC_TAMPx pull-up disable this bit determines if each of the rtc_tampx pins are pre-charged before each sample. */
  static const field32_t RTC_RTC_ALRMASSR_SS       = {.msk = 0x00007FFFU, .pos = 0};    /** @brief Sub seconds value this value is compared with the contents of the synchronous prescaler counter to determine if alarm A is to be activated. Only bits 0 up MASKSS-1 are compared. */
  static const field32_t RTC_RTC_ALRMASSR_MASKSS   = {.msk = 0x0F000000U, .pos = 24};   /** @brief Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation. */
  static const field32_t RTC_RTC_ALRMBSSR_SS       = {.msk = 0x00007FFFU, .pos = 0};    /** @brief Sub seconds value this value is compared with the contents of the synchronous prescaler counter to determine if alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared. */
  static const field32_t RTC_RTC_ALRMBSSR_MASKSS   = {.msk = 0x0F000000U, .pos = 24};   /** @brief Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation. */
  static const field32_t RTC_RTC_OR_RTC_ALARM_TYPE = {.msk = 0x00000001U, .pos = 0};    /** @brief RTC_ALARM output type on PC13. */
  static const field32_t RTC_RTC_OR_RTC_OUT_RMP    = {.msk = 0x00000002U, .pos = 1};    /** @brief RTC_OUT remap. */

  /**** Enumerated RTC Register Field Definitions ****/

  static field32_t const RTC_RTC_ISR_TAMPxF[4] = {
    [1] = {.msk = 0x00002000U, .pos = 13},   /** @brief RTC_TAMP1 detection flag this flag is set by hardware when a tamper detection event is detected on the RTC_TAMP1 input. It is cleared by software writing 0. */
    [2] = {.msk = 0x00004000U, .pos = 14},   /** @brief RTC_TAMP2 detection flag this flag is set by hardware when a tamper detection event is detected on the RTC_TAMP2 input. It is cleared by software writing 0. */
    [3] = {.msk = 0x00008000U, .pos = 15},   /** @brief RTC_TAMP3 detection flag this flag is set by hardware when a tamper detection event is detected on the RTC_TAMP3 input. It is cleared by software writing 0. */
  };

  static field32_t const RTC_RTC_ALRMAR_MSKx[5] = {
    [1] = {.msk = 0x00000080U, .pos = 7},    /** @brief Alarm A seconds mask. */
    [2] = {.msk = 0x00008000U, .pos = 15},   /** @brief Alarm A minutes mask. */
    [3] = {.msk = 0x00800000U, .pos = 23},   /** @brief Alarm A hours mask. */
    [4] = {.msk = 0x80000000U, .pos = 31},   /** @brief Alarm A date mask. */
  };

  static field32_t const RTC_RTC_CALR_CALWx[17] = {
    [8]  = {.msk = 0x00004000U, .pos = 14},   /** @brief Use an 8-second calibration cycle period when CALW8 is set to 1, the 8-second calibration cycle period is selected. Note: CALM[1:0] are stuck at 00; when CALW8= 1. Refer to section24.3.12: RTC smooth digital calibration. */
    [16] = {.msk = 0x00002000U, .pos = 13},   /** @brief Use a 16-second calibration cycle period when CALW16 is set to 1, the 16-second calibration cycle period is selected.this bit must not be set to 1 if CALW8=1. Note: CALM[0] is stuck at 0 when CALW16= 1. Refer to section24.3.12: RTC smooth digital calibration. */
  };

  static field32_t const RTC_RTC_TAMPCR_TAMPxE[4] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief RTC_TAMP1 input detection enable. */
    [2] = {.msk = 0x00000008U, .pos = 3},   /** @brief RTC_TAMP2 input detection enable. */
    [3] = {.msk = 0x00000020U, .pos = 5},   /** @brief RTC_TAMP3 detection enable. */
  };

  static field32_t const RTC_RTC_TAMPCR_TAMPxTRG[4] = {
    [1] = {.msk = 0x00000002U, .pos = 1},   /** @brief Active level for RTC_TAMP1 input if TAMPFLT != 00 if TAMPFLT = 00:. */
    [2] = {.msk = 0x00000010U, .pos = 4},   /** @brief Active level for RTC_TAMP2 input if TAMPFLT != 00: if TAMPFLT = 00:. */
    [3] = {.msk = 0x00000040U, .pos = 6},   /** @brief Active level for RTC_TAMP3 input if TAMPFLT != 00: if TAMPFLT = 00:. */
  };

  static field32_t const RTC_RTC_TAMPCR_TAMPxIE[4] = {
    [1] = {.msk = 0x00010000U, .pos = 16},   /** @brief Tamper 1 interrupt enable. */
    [2] = {.msk = 0x00080000U, .pos = 19},   /** @brief Tamper 2 interrupt enable. */
    [3] = {.msk = 0x00400000U, .pos = 22},   /** @brief Tamper 3 interrupt enable. */
  };

  static field32_t const RTC_RTC_TAMPCR_TAMPxNOERASE[4] = {
    [1] = {.msk = 0x00020000U, .pos = 17},   /** @brief Tamper 1 no erase. */
    [2] = {.msk = 0x00100000U, .pos = 20},   /** @brief Tamper 2 no erase. */
    [3] = {.msk = 0x00800000U, .pos = 23},   /** @brief Tamper 3 no erase. */
  };

  static field32_t const RTC_RTC_TAMPCR_TAMPxMF[4] = {
    [1] = {.msk = 0x00040000U, .pos = 18},   /** @brief Tamper 1 mask flag. */
    [2] = {.msk = 0x00200000U, .pos = 21},   /** @brief Tamper 2 mask flag. */
    [3] = {.msk = 0x01000000U, .pos = 24},   /** @brief Tamper 3 mask flag. */
  };

  /************************************************************************************************
   * SAIx Definitions
   ************************************************************************************************/

  /**** Enumerated SAIx Register Definitions ****/

  static const rw_reg32_t SAIx_SAI_GCR[5] = {
    [1] = (rw_reg32_t)0x40015800U,   /** @brief Global configuration register. */
    [2] = (rw_reg32_t)0x40015C00U,   /** @brief Global configuration register. */
    [3] = (rw_reg32_t)0x40016000U,   /** @brief Global configuration register. */
    [4] = (rw_reg32_t)0x58005400U,   /** @brief Global configuration register. */
  };

  static const rw_reg32_t SAIx_SAI_ACRx[5][3] = {
    [1] = {
      [1] = (rw_reg32_t)0x40015804U,   /** @brief Configuration register 1. */
      [2] = (rw_reg32_t)0x40015808U,   /** @brief Configuration register 2. */
    },
    [2] = {
      [1] = (rw_reg32_t)0x40015C04U,   /** @brief Configuration register 1. */
      [2] = (rw_reg32_t)0x40015C08U,   /** @brief Configuration register 2. */
    },
    [3] = {
      [1] = (rw_reg32_t)0x40016004U,   /** @brief Configuration register 1. */
      [2] = (rw_reg32_t)0x40016008U,   /** @brief Configuration register 2. */
    },
    [4] = {
      [1] = (rw_reg32_t)0x58005404U,   /** @brief Configuration register 1. */
      [2] = (rw_reg32_t)0x58005408U,   /** @brief Configuration register 2. */
    },
  };

  static const rw_reg32_t SAIx_SAI_AFRCR[5] = {
    [1] = (rw_reg32_t)0x4001580CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol. */
    [2] = (rw_reg32_t)0x40015C0CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol. */
    [3] = (rw_reg32_t)0x4001600CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol. */
    [4] = (rw_reg32_t)0x5800540CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol. */
  };

  static const rw_reg32_t SAIx_SAI_ASLOTR[5] = {
    [1] = (rw_reg32_t)0x40015810U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol. */
    [2] = (rw_reg32_t)0x40015C10U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol. */
    [3] = (rw_reg32_t)0x40016010U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol. */
    [4] = (rw_reg32_t)0x58005410U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol. */
  };

  static const rw_reg32_t SAIx_SAI_AIM[5] = {
    [1] = (rw_reg32_t)0x40015814U,   /** @brief Interrupt mask register 2. */
    [2] = (rw_reg32_t)0x40015C14U,   /** @brief Interrupt mask register 2. */
    [3] = (rw_reg32_t)0x40016014U,   /** @brief Interrupt mask register 2. */
    [4] = (rw_reg32_t)0x58005414U,   /** @brief Interrupt mask register 2. */
  };

  static const ro_reg32_t SAIx_SAI_ASR[5] = {
    [1] = (ro_reg32_t)0x40015818U,   /** @brief Status register. */
    [2] = (ro_reg32_t)0x40015C18U,   /** @brief Status register. */
    [3] = (ro_reg32_t)0x40016018U,   /** @brief Status register. */
    [4] = (ro_reg32_t)0x58005418U,   /** @brief Status register. */
  };

  static const rw_reg32_t SAIx_SAI_ACLRFR[5] = {
    [1] = (rw_reg32_t)0x4001581CU,   /** @brief Clear flag register. */
    [2] = (rw_reg32_t)0x40015C1CU,   /** @brief Clear flag register. */
    [3] = (rw_reg32_t)0x4001601CU,   /** @brief Clear flag register. */
    [4] = (rw_reg32_t)0x5800541CU,   /** @brief Clear flag register. */
  };

  static const rw_reg32_t SAIx_SAI_ADR[5] = {
    [1] = (rw_reg32_t)0x40015820U,   /** @brief Data register. */
    [2] = (rw_reg32_t)0x40015C20U,   /** @brief Data register. */
    [3] = (rw_reg32_t)0x40016020U,   /** @brief Data register. */
    [4] = (rw_reg32_t)0x58005420U,   /** @brief Data register. */
  };

  static const rw_reg32_t SAIx_SAI_BCRx[5][3] = {
    [1] = {
      [1] = (rw_reg32_t)0x40015824U,   /** @brief Configuration register 1. */
      [2] = (rw_reg32_t)0x40015828U,   /** @brief Configuration register 2. */
    },
    [2] = {
      [1] = (rw_reg32_t)0x40015C24U,   /** @brief Configuration register 1. */
      [2] = (rw_reg32_t)0x40015C28U,   /** @brief Configuration register 2. */
    },
    [3] = {
      [1] = (rw_reg32_t)0x40016024U,   /** @brief Configuration register 1. */
      [2] = (rw_reg32_t)0x40016028U,   /** @brief Configuration register 2. */
    },
    [4] = {
      [1] = (rw_reg32_t)0x58005424U,   /** @brief Configuration register 1. */
      [2] = (rw_reg32_t)0x58005428U,   /** @brief Configuration register 2. */
    },
  };

  static const rw_reg32_t SAIx_SAI_BFRCR[5] = {
    [1] = (rw_reg32_t)0x4001582CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol. */
    [2] = (rw_reg32_t)0x40015C2CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol. */
    [3] = (rw_reg32_t)0x4001602CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol. */
    [4] = (rw_reg32_t)0x5800542CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol. */
  };

  static const rw_reg32_t SAIx_SAI_BSLOTR[5] = {
    [1] = (rw_reg32_t)0x40015830U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol. */
    [2] = (rw_reg32_t)0x40015C30U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol. */
    [3] = (rw_reg32_t)0x40016030U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol. */
    [4] = (rw_reg32_t)0x58005430U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol. */
  };

  static const rw_reg32_t SAIx_SAI_BIM[5] = {
    [1] = (rw_reg32_t)0x40015834U,   /** @brief Interrupt mask register 2. */
    [2] = (rw_reg32_t)0x40015C34U,   /** @brief Interrupt mask register 2. */
    [3] = (rw_reg32_t)0x40016034U,   /** @brief Interrupt mask register 2. */
    [4] = (rw_reg32_t)0x58005434U,   /** @brief Interrupt mask register 2. */
  };

  static const ro_reg32_t SAIx_SAI_BSR[5] = {
    [1] = (ro_reg32_t)0x40015838U,   /** @brief Status register. */
    [2] = (ro_reg32_t)0x40015C38U,   /** @brief Status register. */
    [3] = (ro_reg32_t)0x40016038U,   /** @brief Status register. */
    [4] = (ro_reg32_t)0x58005438U,   /** @brief Status register. */
  };

  static const rw_reg32_t SAIx_SAI_BCLRFR[5] = {
    [1] = (rw_reg32_t)0x4001583CU,   /** @brief Clear flag register. */
    [2] = (rw_reg32_t)0x40015C3CU,   /** @brief Clear flag register. */
    [3] = (rw_reg32_t)0x4001603CU,   /** @brief Clear flag register. */
    [4] = (rw_reg32_t)0x5800543CU,   /** @brief Clear flag register. */
  };

  static const rw_reg32_t SAIx_SAI_BDR[5] = {
    [1] = (rw_reg32_t)0x40015840U,   /** @brief Data register. */
    [2] = (rw_reg32_t)0x40015C40U,   /** @brief Data register. */
    [3] = (rw_reg32_t)0x40016040U,   /** @brief Data register. */
    [4] = (rw_reg32_t)0x58005440U,   /** @brief Data register. */
  };

  static const rw_reg32_t SAIx_SAI_PDMCR[5] = {
    [1] = (rw_reg32_t)0x40015844U,   /** @brief PDM control register. */
    [2] = (rw_reg32_t)0x40015C44U,   /** @brief PDM control register. */
    [3] = (rw_reg32_t)0x40016044U,   /** @brief PDM control register. */
    [4] = (rw_reg32_t)0x58005444U,   /** @brief PDM control register. */
  };

  static const rw_reg32_t SAIx_SAI_PDMDLY[5] = {
    [1] = (rw_reg32_t)0x40015848U,   /** @brief PDM delay register. */
    [2] = (rw_reg32_t)0x40015C48U,   /** @brief PDM delay register. */
    [3] = (rw_reg32_t)0x40016048U,   /** @brief PDM delay register. */
    [4] = (rw_reg32_t)0x58005448U,   /** @brief PDM delay register. */
  };

  /**** SAIx Register Field Definitions ****/

  static const field32_t SAIx_SAI_GCR_SYNCOUT     = {.msk = 0x00000030U, .pos = 4};    /** @brief Synchronization outputs these bits are set and cleared by software. */
  static const field32_t SAIx_SAI_GCR_SYNCIN      = {.msk = 0x00000003U, .pos = 0};    /** @brief Synchronization inputs. */
  static const field32_t SAIx_SAI_ACRx_MODE       = {.msk = 0x00000003U, .pos = 0};    /** @brief SAIx audio block mode immediately. */
  static const field32_t SAIx_SAI_ACRx_PRTCFG     = {.msk = 0x0000000CU, .pos = 2};    /** @brief Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. */
  static const field32_t SAIx_SAI_ACRx_DS         = {.msk = 0x000000E0U, .pos = 5};    /** @brief Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. */
  static const field32_t SAIx_SAI_ACRx_LSBFIRST   = {.msk = 0x00000100U, .pos = 8};    /** @brief Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first. */
  static const field32_t SAIx_SAI_ACRx_CKSTR      = {.msk = 0x00000200U, .pos = 9};    /** @brief Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol. */
  static const field32_t SAIx_SAI_ACRx_SYNCEN     = {.msk = 0x00000C00U, .pos = 10};   /** @brief Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: the audio sub-block should be configured as asynchronous when SPDIF mode is enabled. */
  static const field32_t SAIx_SAI_ACRx_MONO       = {.msk = 0x00001000U, .pos = 12};   /** @brief Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to section: mono/stereo mode for more details. */
  static const field32_t SAIx_SAI_ACRx_OUTDRIV    = {.msk = 0x00002000U, .pos = 13};   /** @brief Output drive. This bit is set and cleared by software. Note: this bit has to be set before enabling the audio block and after the audio block configuration. */
  static const field32_t SAIx_SAI_ACRx_SAIXEN     = {.msk = 0x00010000U, .pos = 16};   /** @brief Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of saix audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: when saix block is configured in master mode, the clock must be present on the input of saix before setting SAIXEN bit. */
  static const field32_t SAIx_SAI_ACRx_DMAEN      = {.msk = 0x00020000U, .pos = 17};   /** @brief DMA enable. This bit is set and cleared by software. Note: since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode. */
  static const field32_t SAIx_SAI_ACRx_NOMCK      = {.msk = 0x00080000U, .pos = 19};   /** @brief No divider. */
  static const field32_t SAIx_SAI_ACRx_MCKDIV     = {.msk = 0x00F00000U, .pos = 20};   /** @brief Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula:. */
  static const field32_t SAIx_SAI_ACRx_OSR        = {.msk = 0x04000000U, .pos = 26};   /** @brief Oversampling ratio for master clock. */
  static const field32_t SAIx_SAI_AFRCR_FRL       = {.msk = 0x000000FFU, .pos = 0};    /** @brief Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of sai_xslotr register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on mclk_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. */
  static const field32_t SAIx_SAI_AFRCR_FSALL     = {.msk = 0x00007F00U, .pos = 8};    /** @brief Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame these bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. */
  static const field32_t SAIx_SAI_AFRCR_FSDEF     = {.msk = 0x00010000U, .pos = 16};   /** @brief Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the sai_xslotr register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or msb/lsb-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled. */
  static const field32_t SAIx_SAI_AFRCR_FSPOL     = {.msk = 0x00020000U, .pos = 17};   /** @brief Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
  static const field32_t SAIx_SAI_AFRCR_FSOFF     = {.msk = 0x00040000U, .pos = 18};   /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
  static const field32_t SAIx_SAI_ASLOTR_FBOFF    = {.msk = 0x0000001FU, .pos = 0};    /** @brief First bit offset these bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const field32_t SAIx_SAI_ASLOTR_SLOTSZ   = {.msk = 0x000000C0U, .pos = 6};    /** @brief Slot size this bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to section: output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const field32_t SAIx_SAI_ASLOTR_NBSLOT   = {.msk = 0x00000F00U, .pos = 8};    /** @brief Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the sai_xfrcr register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const field32_t SAIx_SAI_ASLOTR_SLOTEN   = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const field32_t SAIx_SAI_AIM_OVRUDRIE    = {.msk = 0x00000001U, .pos = 0};    /** @brief Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the sai_xsr register is set. */
  static const field32_t SAIx_SAI_AIM_MUTEDETIE   = {.msk = 0x00000002U, .pos = 1};    /** @brief Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the sai_xsr register is set. This bit has a meaning only if the audio block is configured in receiver mode. */
  static const field32_t SAIx_SAI_AIM_WCKCFGIE    = {.msk = 0x00000004U, .pos = 2};    /** @brief Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the sai_xsr register is set. Note: this bit is used only in TDM mode and is meaningless in other modes. */
  static const field32_t SAIx_SAI_AIM_FREQIE      = {.msk = 0x00000008U, .pos = 3};    /** @brief FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the sai_xsr register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,. */
  static const field32_t SAIx_SAI_AIM_CNRDYIE     = {.msk = 0x00000010U, .pos = 4};    /** @brief Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the sai_xsr register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver. */
  static const field32_t SAIx_SAI_AIM_AFSDETIE    = {.msk = 0x00000020U, .pos = 5};    /** @brief Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the sai_xsr register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
  static const field32_t SAIx_SAI_AIM_LFSDETIE    = {.msk = 0x00000040U, .pos = 6};    /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
  static const field32_t SAIx_SAI_ASR_OVRUDR      = {.msk = 0x00000001U, .pos = 0};    /** @brief Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in sai_xim register. This flag is cleared when the software sets COVRUDR bit in sai_xclrfr register. */
  static const field32_t SAIx_SAI_ASR_MUTEDET     = {.msk = 0x00000002U, .pos = 1};    /** @brief Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the sai_xcr2 register). It can generate an interrupt if MUTEDETIE bit is set in sai_xim register. This flag is cleared when the software sets bit CMUTEDET in the sai_xclrfr register. */
  static const field32_t SAIx_SAI_ASR_WCKCFG      = {.msk = 0x00000004U, .pos = 2};    /** @brief Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in sai_xim register. This flag is cleared when the software sets CWCKCFG bit in sai_xclrfr register. */
  static const field32_t SAIx_SAI_ASR_FREQ        = {.msk = 0x00000008U, .pos = 3};    /** @brief FIFO request. This bit is read only. The request depends on the audio block configuration: if the block is configured in transmission mode, the FIFO request is related to a write request operation in the sai_xdr. If the block configured in reception, the FIFO request related to a read request operation from the sai_xdr. This flag can generate an interrupt if FREQIE bit is set in sai_xim register. */
  static const field32_t SAIx_SAI_ASR_CNRDY       = {.msk = 0x00000010U, .pos = 4};    /** @brief Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in sai_xim register. This flag is cleared when the software sets CCNRDY bit in sai_xclrfr register. */
  static const field32_t SAIx_SAI_ASR_AFSDET      = {.msk = 0x00000020U, .pos = 5};    /** @brief Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in ac97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in sai_xim register. This flag is cleared when the software sets CAFSDET bit in sai_xclrfr register. */
  static const field32_t SAIx_SAI_ASR_LFSDET      = {.msk = 0x00000040U, .pos = 6};    /** @brief Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the sai_xim register. This flag is cleared when the software sets bit CLFSDET in sai_xclrfr register. */
  static const field32_t SAIx_SAI_ASR_FLVL        = {.msk = 0x00070000U, .pos = 16};   /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver:. */
  static const field32_t SAIx_SAI_ACLRFR_COVRUDR  = {.msk = 0x00000001U, .pos = 0};    /** @brief Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the sai_xsr register. Reading this bit always returns the value 0. */
  static const field32_t SAIx_SAI_ACLRFR_CMUTEDET = {.msk = 0x00000002U, .pos = 1};    /** @brief Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the sai_xsr register. Reading this bit always returns the value 0. */
  static const field32_t SAIx_SAI_ACLRFR_CWCKCFG  = {.msk = 0x00000004U, .pos = 2};    /** @brief Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the sai_xsr register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the sai_xcr1 register. Reading this bit always returns the value 0. */
  static const field32_t SAIx_SAI_ACLRFR_CCNRDY   = {.msk = 0x00000010U, .pos = 4};    /** @brief Clear codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the sai_xsr register. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register. Reading this bit always returns the value 0. */
  static const field32_t SAIx_SAI_ACLRFR_CAFSDET  = {.msk = 0x00000020U, .pos = 5};    /** @brief Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the sai_xsr register. It is not used in ac97or SPDIF mode. Reading this bit always returns the value 0. */
  static const field32_t SAIx_SAI_ACLRFR_CLFSDET  = {.msk = 0x00000040U, .pos = 6};    /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
  static const field32_t SAIx_SAI_BCRx_MODE       = {.msk = 0x00000003U, .pos = 0};    /** @brief SAIx audio block mode immediately. */
  static const field32_t SAIx_SAI_BCRx_PRTCFG     = {.msk = 0x0000000CU, .pos = 2};    /** @brief Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. */
  static const field32_t SAIx_SAI_BCRx_DS         = {.msk = 0x000000E0U, .pos = 5};    /** @brief Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. */
  static const field32_t SAIx_SAI_BCRx_LSBFIRST   = {.msk = 0x00000100U, .pos = 8};    /** @brief Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first. */
  static const field32_t SAIx_SAI_BCRx_CKSTR      = {.msk = 0x00000200U, .pos = 9};    /** @brief Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol. */
  static const field32_t SAIx_SAI_BCRx_SYNCEN     = {.msk = 0x00000C00U, .pos = 10};   /** @brief Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: the audio sub-block should be configured as asynchronous when SPDIF mode is enabled. */
  static const field32_t SAIx_SAI_BCRx_MONO       = {.msk = 0x00001000U, .pos = 12};   /** @brief Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to section: mono/stereo mode for more details. */
  static const field32_t SAIx_SAI_BCRx_OUTDRIV    = {.msk = 0x00002000U, .pos = 13};   /** @brief Output drive. This bit is set and cleared by software. Note: this bit has to be set before enabling the audio block and after the audio block configuration. */
  static const field32_t SAIx_SAI_BCRx_SAIXEN     = {.msk = 0x00010000U, .pos = 16};   /** @brief Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of saix audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: when saix block is configured in master mode, the clock must be present on the input of saix before setting SAIXEN bit. */
  static const field32_t SAIx_SAI_BCRx_DMAEN      = {.msk = 0x00020000U, .pos = 17};   /** @brief DMA enable. This bit is set and cleared by software. Note: since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode. */
  static const field32_t SAIx_SAI_BCRx_NOMCK      = {.msk = 0x00080000U, .pos = 19};   /** @brief No divider. */
  static const field32_t SAIx_SAI_BCRx_MCKDIV     = {.msk = 0x00F00000U, .pos = 20};   /** @brief Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula:. */
  static const field32_t SAIx_SAI_BCRx_OSR        = {.msk = 0x04000000U, .pos = 26};   /** @brief Oversampling ratio for master clock. */
  static const field32_t SAIx_SAI_BFRCR_FRL       = {.msk = 0x000000FFU, .pos = 0};    /** @brief Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of sai_xslotr register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on mclk_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. */
  static const field32_t SAIx_SAI_BFRCR_FSALL     = {.msk = 0x00007F00U, .pos = 8};    /** @brief Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame these bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. */
  static const field32_t SAIx_SAI_BFRCR_FSDEF     = {.msk = 0x00010000U, .pos = 16};   /** @brief Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the sai_xslotr register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or msb/lsb-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled. */
  static const field32_t SAIx_SAI_BFRCR_FSPOL     = {.msk = 0x00020000U, .pos = 17};   /** @brief Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
  static const field32_t SAIx_SAI_BFRCR_FSOFF     = {.msk = 0x00040000U, .pos = 18};   /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
  static const field32_t SAIx_SAI_BSLOTR_FBOFF    = {.msk = 0x0000001FU, .pos = 0};    /** @brief First bit offset these bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const field32_t SAIx_SAI_BSLOTR_SLOTSZ   = {.msk = 0x000000C0U, .pos = 6};    /** @brief Slot size this bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to section: output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const field32_t SAIx_SAI_BSLOTR_NBSLOT   = {.msk = 0x00000F00U, .pos = 8};    /** @brief Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the sai_xfrcr register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const field32_t SAIx_SAI_BSLOTR_SLOTEN   = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const field32_t SAIx_SAI_BIM_OVRUDRIE    = {.msk = 0x00000001U, .pos = 0};    /** @brief Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the sai_xsr register is set. */
  static const field32_t SAIx_SAI_BIM_MUTEDETIE   = {.msk = 0x00000002U, .pos = 1};    /** @brief Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the sai_xsr register is set. This bit has a meaning only if the audio block is configured in receiver mode. */
  static const field32_t SAIx_SAI_BIM_WCKCFGIE    = {.msk = 0x00000004U, .pos = 2};    /** @brief Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the sai_xsr register is set. Note: this bit is used only in TDM mode and is meaningless in other modes. */
  static const field32_t SAIx_SAI_BIM_FREQIE      = {.msk = 0x00000008U, .pos = 3};    /** @brief FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the sai_xsr register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,. */
  static const field32_t SAIx_SAI_BIM_CNRDYIE     = {.msk = 0x00000010U, .pos = 4};    /** @brief Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the sai_xsr register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver. */
  static const field32_t SAIx_SAI_BIM_AFSDETIE    = {.msk = 0x00000020U, .pos = 5};    /** @brief Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the sai_xsr register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
  static const field32_t SAIx_SAI_BIM_LFSDETIE    = {.msk = 0x00000040U, .pos = 6};    /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
  static const field32_t SAIx_SAI_BSR_OVRUDR      = {.msk = 0x00000001U, .pos = 0};    /** @brief Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in sai_xim register. This flag is cleared when the software sets COVRUDR bit in sai_xclrfr register. */
  static const field32_t SAIx_SAI_BSR_MUTEDET     = {.msk = 0x00000002U, .pos = 1};    /** @brief Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the sai_xcr2 register). It can generate an interrupt if MUTEDETIE bit is set in sai_xim register. This flag is cleared when the software sets bit CMUTEDET in the sai_xclrfr register. */
  static const field32_t SAIx_SAI_BSR_WCKCFG      = {.msk = 0x00000004U, .pos = 2};    /** @brief Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in sai_xim register. This flag is cleared when the software sets CWCKCFG bit in sai_xclrfr register. */
  static const field32_t SAIx_SAI_BSR_FREQ        = {.msk = 0x00000008U, .pos = 3};    /** @brief FIFO request. This bit is read only. The request depends on the audio block configuration: if the block is configured in transmission mode, the FIFO request is related to a write request operation in the sai_xdr. If the block configured in reception, the FIFO request related to a read request operation from the sai_xdr. This flag can generate an interrupt if FREQIE bit is set in sai_xim register. */
  static const field32_t SAIx_SAI_BSR_CNRDY       = {.msk = 0x00000010U, .pos = 4};    /** @brief Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in sai_xim register. This flag is cleared when the software sets CCNRDY bit in sai_xclrfr register. */
  static const field32_t SAIx_SAI_BSR_AFSDET      = {.msk = 0x00000020U, .pos = 5};    /** @brief Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in ac97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in sai_xim register. This flag is cleared when the software sets CAFSDET bit in sai_xclrfr register. */
  static const field32_t SAIx_SAI_BSR_LFSDET      = {.msk = 0x00000040U, .pos = 6};    /** @brief Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the sai_xim register. This flag is cleared when the software sets bit CLFSDET in sai_xclrfr register. */
  static const field32_t SAIx_SAI_BSR_FLVL        = {.msk = 0x00070000U, .pos = 16};   /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver:. */
  static const field32_t SAIx_SAI_BCLRFR_COVRUDR  = {.msk = 0x00000001U, .pos = 0};    /** @brief Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the sai_xsr register. Reading this bit always returns the value 0. */
  static const field32_t SAIx_SAI_BCLRFR_CMUTEDET = {.msk = 0x00000002U, .pos = 1};    /** @brief Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the sai_xsr register. Reading this bit always returns the value 0. */
  static const field32_t SAIx_SAI_BCLRFR_CWCKCFG  = {.msk = 0x00000004U, .pos = 2};    /** @brief Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the sai_xsr register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the sai_xcr1 register. Reading this bit always returns the value 0. */
  static const field32_t SAIx_SAI_BCLRFR_CCNRDY   = {.msk = 0x00000010U, .pos = 4};    /** @brief Clear codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the sai_xsr register. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register. Reading this bit always returns the value 0. */
  static const field32_t SAIx_SAI_BCLRFR_CAFSDET  = {.msk = 0x00000020U, .pos = 5};    /** @brief Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the sai_xsr register. It is not used in ac97or SPDIF mode. Reading this bit always returns the value 0. */
  static const field32_t SAIx_SAI_BCLRFR_CLFSDET  = {.msk = 0x00000040U, .pos = 6};    /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
  static const field32_t SAIx_SAI_PDMCR_PDMEN     = {.msk = 0x00000001U, .pos = 0};    /** @brief PDM enable. */
  static const field32_t SAIx_SAI_PDMCR_MICNBR    = {.msk = 0x00000030U, .pos = 4};    /** @brief Number of microphones. */

  /**** Enumerated SAIx Register Field Definitions ****/

  static field32_t const SAIx_SAI_PDMCR_CKENx[5] = {
    [1] = {.msk = 0x00000100U, .pos = 8},    /** @brief Clock enable of bitstream clock number 1. */
    [2] = {.msk = 0x00000200U, .pos = 9},    /** @brief Clock enable of bitstream clock number 2. */
    [3] = {.msk = 0x00000400U, .pos = 10},   /** @brief Clock enable of bitstream clock number 3. */
    [4] = {.msk = 0x00000800U, .pos = 11},   /** @brief Clock enable of bitstream clock number 4. */
  };

  static field32_t const SAIx_SAI_PDMDLY_DLYMxL[5] = {
    [1] = {.msk = 0x00000007U, .pos = 0},    /** @brief Delay line adjust for first microphone of pair 1. */
    [2] = {.msk = 0x00000700U, .pos = 8},    /** @brief Delay line for first microphone of pair 2. */
    [3] = {.msk = 0x00070000U, .pos = 16},   /** @brief Delay line for first microphone of pair 3. */
    [4] = {.msk = 0x07000000U, .pos = 24},   /** @brief Delay line for first microphone of pair 4. */
  };

  static field32_t const SAIx_SAI_PDMDLY_DLYMxR[5] = {
    [1] = {.msk = 0x00000070U, .pos = 4},    /** @brief Delay line adjust for second microphone of pair 1. */
    [2] = {.msk = 0x00007000U, .pos = 12},   /** @brief Delay line for second microphone of pair 2. */
    [3] = {.msk = 0x00700000U, .pos = 20},   /** @brief Delay line for second microphone of pair 3. */
    [4] = {.msk = 0x70000000U, .pos = 28},   /** @brief Delay line for second microphone of pair 4. */
  };

  /************************************************************************************************
   * SDMMCx Definitions
   ************************************************************************************************/

  /**** Enumerated SDMMCx Register Definitions ****/

  static const rw_reg32_t SDMMCx_POWER[3] = {
    [1] = (rw_reg32_t)0x52007000U,   /** @brief SDMMC power control register. */
    [2] = (rw_reg32_t)0x48022400U,   /** @brief SDMMC power control register. */
  };

  static const rw_reg32_t SDMMCx_CLKCR[3] = {
    [1] = (rw_reg32_t)0x52007004U,   /** @brief The SDMMC_CLKCR register controls the SDMMC_CK output clock, the SDMMC_RX_CLK receive clock, and the bus width. */
    [2] = (rw_reg32_t)0x48022404U,   /** @brief The SDMMC_CLKCR register controls the SDMMC_CK output clock, the SDMMC_RX_CLK receive clock, and the bus width. */
  };

  static const rw_reg32_t SDMMCx_ARGR[3] = {
    [1] = (rw_reg32_t)0x52007008U,   /** @brief The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message. */
    [2] = (rw_reg32_t)0x48022408U,   /** @brief The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message. */
  };

  static const rw_reg32_t SDMMCx_CMDR[3] = {
    [1] = (rw_reg32_t)0x5200700CU,   /** @brief The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM). */
    [2] = (rw_reg32_t)0x4802240CU,   /** @brief The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM). */
  };

  static const ro_reg32_t SDMMCx_RESPxR[3][5] = {
    [1] = {
      [1] = (ro_reg32_t)0x52007014U,   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
      [2] = (ro_reg32_t)0x52007018U,   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
      [3] = (ro_reg32_t)0x5200701CU,   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
      [4] = (ro_reg32_t)0x52007020U,   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
    },
    [2] = {
      [1] = (ro_reg32_t)0x48022414U,   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
      [2] = (ro_reg32_t)0x48022418U,   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
      [3] = (ro_reg32_t)0x4802241CU,   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
      [4] = (ro_reg32_t)0x48022420U,   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
    },
  };

  static const rw_reg32_t SDMMCx_DTIMER[3] = {
    [1] = (rw_reg32_t)0x52007024U,   /** @brief The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the wait_r or busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set. */
    [2] = (rw_reg32_t)0x48022424U,   /** @brief The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the wait_r or busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set. */
  };

  static const rw_reg32_t SDMMCx_DLENR[3] = {
    [1] = (rw_reg32_t)0x52007028U,   /** @brief The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts. */
    [2] = (rw_reg32_t)0x48022428U,   /** @brief The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts. */
  };

  static const rw_reg32_t SDMMCx_DCTRL[3] = {
    [1] = (rw_reg32_t)0x5200702CU,   /** @brief The SDMMC_DCTRL register control the data path state machine (DPSM). */
    [2] = (rw_reg32_t)0x4802242CU,   /** @brief The SDMMC_DCTRL register control the data path state machine (DPSM). */
  };

  static const ro_reg32_t SDMMCx_DCNTR[3] = {
    [1] = (ro_reg32_t)0x52007030U,   /** @brief The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the idle state to the wait_r or wait_s state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the idle state and when there has been no error, the data status end flag (DATAEND) is set. */
    [2] = (ro_reg32_t)0x48022430U,   /** @brief The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the idle state to the wait_r or wait_s state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the idle state and when there has been no error, the data status end flag (DATAEND) is set. */
  };

  static const ro_reg32_t SDMMCx_STAR[3] = {
    [1] = (ro_reg32_t)0x52007034U,   /** @brief The SDMMC_STAR register is a read-only register. It contains two types of flag:static flags (bits [29,21,11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt clear register (see sdmmc_icr)dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO). */
    [2] = (ro_reg32_t)0x48022434U,   /** @brief The SDMMC_STAR register is a read-only register. It contains two types of flag:static flags (bits [29,21,11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt clear register (see sdmmc_icr)dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO). */
  };

  static const rw_reg32_t SDMMCx_ICR[3] = {
    [1] = (rw_reg32_t)0x52007038U,   /** @brief The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register. */
    [2] = (rw_reg32_t)0x48022438U,   /** @brief The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register. */
  };

  static const rw_reg32_t SDMMCx_MASKR[3] = {
    [1] = (rw_reg32_t)0x5200703CU,   /** @brief The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1. */
    [2] = (rw_reg32_t)0x4802243CU,   /** @brief The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1. */
  };

  static const rw_reg32_t SDMMCx_ACKTIMER[3] = {
    [1] = (rw_reg32_t)0x52007040U,   /** @brief The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the wait_ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set. */
    [2] = (rw_reg32_t)0x48022440U,   /** @brief The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the wait_ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set. */
  };

  static const rw_reg32_t SDMMCx_IDMACTRLR[3] = {
    [1] = (rw_reg32_t)0x52007050U,   /** @brief The receive and transmit fifos can be read or written as 32-bit wide registers. The fifos contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. */
    [2] = (rw_reg32_t)0x48022450U,   /** @brief The receive and transmit fifos can be read or written as 32-bit wide registers. The fifos contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. */
  };

  static const rw_reg32_t SDMMCx_IDMABSIZER[3] = {
    [1] = (rw_reg32_t)0x52007054U,   /** @brief The SDMMC_IDMABSIZER register contains the buffers size when in double buffer configuration. */
    [2] = (rw_reg32_t)0x48022454U,   /** @brief The SDMMC_IDMABSIZER register contains the buffers size when in double buffer configuration. */
  };

  static const rw_reg32_t SDMMCx_IDMABASExR[3][2] = {
    [1] = {
      [0] = (rw_reg32_t)0x52007058U,   /** @brief The SDMMC_IDMABASE0R register contains the memory buffer base address in single buffer configuration and the buffer 0 base address in double buffer configuration. */
      [1] = (rw_reg32_t)0x5200705CU,   /** @brief The SDMMC_IDMABASE1R register contains the double buffer configuration second buffer memory base address. */
    },
    [2] = {
      [0] = (rw_reg32_t)0x48022458U,   /** @brief The SDMMC_IDMABASE0R register contains the memory buffer base address in single buffer configuration and the buffer 0 base address in double buffer configuration. */
      [1] = (rw_reg32_t)0x4802245CU,   /** @brief The SDMMC_IDMABASE1R register contains the double buffer configuration second buffer memory base address. */
    },
  };

  static const rw_reg32_t SDMMCx_FIFOR[3] = {
    [1] = (rw_reg32_t)0x52007080U,   /** @brief The receive and transmit fifos can be only read or written as word (32-bit) wide registers. The fifos contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the fifo.when accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated. */
    [2] = (rw_reg32_t)0x48022480U,   /** @brief The receive and transmit fifos can be only read or written as word (32-bit) wide registers. The fifos contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the fifo.when accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated. */
  };

  static const ro_reg32_t SDMMCx_RESPCMDR[3] = {
    [1] = (ro_reg32_t)0x52007010U,   /** @brief SDMMC command response register. */
    [2] = (ro_reg32_t)0x48022410U,   /** @brief SDMMC command response register. */
  };

  /**** SDMMCx Register Field Definitions ****/

  static const field32_t SDMMCx_POWER_PWRCTRL       = {.msk = 0x00000003U, .pos = 0};    /** @brief SDMMC state control bits. These bits can only be written when the SDMMC is not in the power-on state (PWRCTRL?11). These bits are used to define the functional state of the SDMMC signals: any further write will be ignored, PWRCTRL value will keep 11. */
  static const field32_t SDMMCx_POWER_VSWITCH       = {.msk = 0x00000004U, .pos = 2};    /** @brief Voltage switch sequence start. This bit is used to start the timing critical section of the voltage switch sequence:. */
  static const field32_t SDMMCx_POWER_VSWITCHEN     = {.msk = 0x00000008U, .pos = 3};    /** @brief Voltage switch procedure enable. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). This bit is used to stop the SDMMC_CK after the voltage switch command response:. */
  static const field32_t SDMMCx_POWER_DIRPOL        = {.msk = 0x00000010U, .pos = 4};    /** @brief Data and command direction signals polarity selection. This bit can only be written when the SDMMC is in the power-off state (PWRCTRL = 00). */
  static const field32_t SDMMCx_CLKCR_CLKDIV        = {.msk = 0x000003FFU, .pos = 0};    /** @brief Clock divide factor this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). This field defines the divide factor between the input clock (SDMMCCLK) and the output clock (SDMMC_CK): SDMMC_CK frequency = SDMMCCLK / [2 * CLKDIV]. 0xx: etc.. Xxx: etc.. */
  static const field32_t SDMMCx_CLKCR_PWRSAV        = {.msk = 0x00001000U, .pos = 12};   /** @brief Power saving configuration bit this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) for power saving, the SDMMC_CK clock output can be disabled when the bus is idle by setting PWRSAV:. */
  static const field32_t SDMMCx_CLKCR_WIDBUS        = {.msk = 0x0000C000U, .pos = 14};   /** @brief Wide bus mode enable bit this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). */
  static const field32_t SDMMCx_CLKCR_NEGEDGE       = {.msk = 0x00010000U, .pos = 16};   /** @brief SDMMC_CK dephasing selection bit for data and command. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). When clock division = 1 (CLKDIV = 0), this bit has no effect. Data and command change on SDMMC_CK falling edge. When clock division &gt;1 (CLKDIV &gt; 0) &amp; DDR = 0: - SDMMC_CK edge occurs on SDMMCCLK rising edge. When clock division >1 (CLKDIV > 0) & DDR = 1: - data changed on the SDMMCCLK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge. - data changed on the SDMMC_CK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge. */
  static const field32_t SDMMCx_CLKCR_HWFC_EN       = {.msk = 0x00020000U, .pos = 17};   /** @brief Hardware flow control enable this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) when hardware flow control is enabled, the meaning of the TXFIFOE and RXFIFOF flags change, please see SDMMC status register definition in section56.8.11. */
  static const field32_t SDMMCx_CLKCR_DDR           = {.msk = 0x00040000U, .pos = 18};   /** @brief Data rate signaling selection this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) DDR rate shall only be selected with 4-bit or 8-bit wide bus mode. (WIDBUS &gt; 00). DDR = 1 has no effect when WIDBUS = 00 (1-bit wide bus). DDR rate shall only be selected with clock division &gt;1. (CLKDIV &gt; 0). */
  static const field32_t SDMMCx_CLKCR_BUSSPEED      = {.msk = 0x00080000U, .pos = 19};   /** @brief Bus speed mode selection between DS, HS, SDR12, SDR25 and SDR50, DDR50, SDR104. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). */
  static const field32_t SDMMCx_CLKCR_SELCLKRX      = {.msk = 0x00300000U, .pos = 20};   /** @brief Receive clock selection. These bits can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). */
  static const field32_t SDMMCx_CMDR_CMDINDEX       = {.msk = 0x0000003FU, .pos = 0};    /** @brief Command index. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). The command index is sent to the card as part of a command message. */
  static const field32_t SDMMCx_CMDR_CMDTRANS       = {.msk = 0x00000040U, .pos = 6};    /** @brief The CPSM treats the command as a data transfer command, stops the interrupt period, and signals dataenable to the DPSM this bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues an end of interrupt period and issues dataenable signal to the DPSM when the command is sent. */
  static const field32_t SDMMCx_CMDR_CMDSTOP        = {.msk = 0x00000080U, .pos = 7};    /** @brief The CPSM treats the command as a stop transmission command and signals abort to the DPSM. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues the abort signal to the DPSM when the command is sent. */
  static const field32_t SDMMCx_CMDR_WAITRESP       = {.msk = 0x00000300U, .pos = 8};    /** @brief Wait for response bits. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). They are used to configure whether the CPSM is to wait for a response, and if yes, which kind of response. */
  static const field32_t SDMMCx_CMDR_WAITINT        = {.msk = 0x00000400U, .pos = 10};   /** @brief CPSM waits for interrupt request. If this bit is set, the CPSM disables command timeout and waits for an card interrupt request (response). If this bit is cleared in the CPSM wait state, will cause the abort of the interrupt mode. */
  static const field32_t SDMMCx_CMDR_WAITPEND       = {.msk = 0x00000800U, .pos = 11};   /** @brief CPSM waits for end of data transfer (cmdpend internal signal) from DPSM. This bit when set, the CPSM waits for the end of data transfer trigger before it starts sending a command. WAITPEND is only taken into account when DTMODE = MMC stream data transfer, WIDBUS = 1-bit wide bus mode, DPSMACT = 1 and DTDIR = from host to card. */
  static const field32_t SDMMCx_CMDR_CPSMEN         = {.msk = 0x00001000U, .pos = 12};   /** @brief Command path state machine (CPSM) enable bit this bit is written 1 by firmware, and cleared by hardware when the CPSM enters the idle state. If this bit is set, the CPSM is enabled. When DTEN = 1, no command will be transfered nor boot procedure will be started. CPSMEN is cleared to 0. */
  static const field32_t SDMMCx_CMDR_DTHOLD         = {.msk = 0x00002000U, .pos = 13};   /** @brief Hold new data block transmission and reception in the DPSM. If this bit is set, the DPSM will not move from the wait_s state to the send state or from the wait_r state to the receive state. */
  static const field32_t SDMMCx_CMDR_BOOTMODE       = {.msk = 0x00004000U, .pos = 14};   /** @brief Select the boot mode procedure to be used. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). */
  static const field32_t SDMMCx_CMDR_BOOTEN         = {.msk = 0x00008000U, .pos = 15};   /** @brief Enable boot mode procedure. */
  static const field32_t SDMMCx_CMDR_CMDSUSPEND     = {.msk = 0x00010000U, .pos = 16};   /** @brief The CPSM treats the command as a suspend or resume command and signals interrupt period start/end. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). CMDSUSPEND = 1 and CMDTRANS = 0 suspend command, start interrupt period when response bit BS=0. CMDSUSPEND = 1 and CMDTRANS = 1 resume command with data, end interrupt period when response bit DF=1. */
  static const field32_t SDMMCx_DLENR_DATALENGTH    = {.msk = 0x01FFFFFFU, .pos = 0};    /** @brief Data length value this register can only be written by firmware when DPSM is inactive (DPSMACT = 0). Number of data bytes to be transferred. When DDR = 1 DATALENGTH is truncated to a multiple of 2. (The last odd byte is not transfered) when DATALENGTH = 0 no data will be transfered, when requested by a CPSMEN and CMDTRANS = 1 also no command will be transfered. DTEN and CPSMEN are cleared to 0. */
  static const field32_t SDMMCx_DCTRL_DTEN          = {.msk = 0x00000001U, .pos = 0};    /** @brief Data transfer enable bit this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). This bit is cleared by hardware when data transfer completes. This bit shall only be used to transfer data when no associated data transfer command is used, i.e. Shall not be used with SD or emmc cards. */
  static const field32_t SDMMCx_DCTRL_DTDIR         = {.msk = 0x00000002U, .pos = 1};    /** @brief Data transfer direction selection this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
  static const field32_t SDMMCx_DCTRL_DTMODE        = {.msk = 0x0000000CU, .pos = 2};    /** @brief Data transfer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
  static const field32_t SDMMCx_DCTRL_DBLOCKSIZE    = {.msk = 0x000000F0U, .pos = 4};    /** @brief Data block size this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). Define the data block length when the block data transfer mode is selected: when DATALENGTH is not a multiple of DBLOCKSIZE, the transfered data is truncated at a multiple of DBLOCKSIZE. (Any remain data will not be transfered.) when DDR = 1, DBLOCKSIZE = 0000 shall not be used. (No data will be transfered). */
  static const field32_t SDMMCx_DCTRL_RWSTART       = {.msk = 0x00000100U, .pos = 8};    /** @brief Read wait start. If this bit is set, read wait operation starts. */
  static const field32_t SDMMCx_DCTRL_RWSTOP        = {.msk = 0x00000200U, .pos = 9};    /** @brief Read wait stop this bit is written by firmware and auto cleared by hardware when the DPSM moves from the READ_WAIT state to the WAIT_R or IDLE state. */
  static const field32_t SDMMCx_DCTRL_RWMOD         = {.msk = 0x00000400U, .pos = 10};   /** @brief Read wait mode. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
  static const field32_t SDMMCx_DCTRL_SDIOEN        = {.msk = 0x00000800U, .pos = 11};   /** @brief SD I/O interrupt enable functions this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). If this bit is set, the DPSM enables the SD I/O card specific interrupt operation. */
  static const field32_t SDMMCx_DCTRL_BOOTACKEN     = {.msk = 0x00001000U, .pos = 12};   /** @brief Enable the reception of the boot acknowledgment. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
  static const field32_t SDMMCx_DCTRL_FIFORST       = {.msk = 0x00002000U, .pos = 13};   /** @brief FIFO reset, will flush any remaining data. This bit can only be written by firmware when IDMAEN= 0 and DPSM is active (DPSMACT = 1). This bit will only take effect when a transfer error or transfer hold occurs. */
  static const field32_t SDMMCx_DCNTR_DATACOUNT     = {.msk = 0x01FFFFFFU, .pos = 0};    /** @brief Data count value when read, the number of remaining data bytes to be transferred is returned. Write has no effect. */
  static const field32_t SDMMCx_STAR_CCRCFAIL       = {.msk = 0x00000001U, .pos = 0};    /** @brief Command response received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const field32_t SDMMCx_STAR_DCRCFAIL       = {.msk = 0x00000002U, .pos = 1};    /** @brief Data block sent/received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const field32_t SDMMCx_STAR_CTIMEOUT       = {.msk = 0x00000004U, .pos = 2};    /** @brief Command response timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. The command timeout period has a fixed value of 64 SDMMC_CK clock periods. */
  static const field32_t SDMMCx_STAR_DTIMEOUT       = {.msk = 0x00000008U, .pos = 3};    /** @brief Data timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const field32_t SDMMCx_STAR_TXUNDERR       = {.msk = 0x00000010U, .pos = 4};    /** @brief Transmit FIFO underrun error or IDMA read transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const field32_t SDMMCx_STAR_RXOVERR        = {.msk = 0x00000020U, .pos = 5};    /** @brief Received FIFO overrun error or IDMA write transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const field32_t SDMMCx_STAR_CMDREND        = {.msk = 0x00000040U, .pos = 6};    /** @brief Command response received (CRC check passed, or no CRC). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const field32_t SDMMCx_STAR_CMDSENT        = {.msk = 0x00000080U, .pos = 7};    /** @brief Command sent (no response required). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const field32_t SDMMCx_STAR_DATAEND        = {.msk = 0x00000100U, .pos = 8};    /** @brief Data transfer ended correctly. (data counter, DATACOUNT is zero and no errors occur). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const field32_t SDMMCx_STAR_DHOLD          = {.msk = 0x00000200U, .pos = 9};    /** @brief Data transfer hold. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const field32_t SDMMCx_STAR_DBCKEND        = {.msk = 0x00000400U, .pos = 10};   /** @brief Data block sent/received. (CRC check passed) and DPSM moves to the READWAIT state. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const field32_t SDMMCx_STAR_DABORT         = {.msk = 0x00000800U, .pos = 11};   /** @brief Data transfer aborted by CMD12. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const field32_t SDMMCx_STAR_DPSMACT        = {.msk = 0x00001000U, .pos = 12};   /** @brief Data path state machine active, i.e. Not in idle state. This is a hardware status flag only, does not generate an interrupt. */
  static const field32_t SDMMCx_STAR_CPSMACT        = {.msk = 0x00002000U, .pos = 13};   /** @brief Command path state machine active, i.e. Not in idle state. This is a hardware status flag only, does not generate an interrupt. */
  static const field32_t SDMMCx_STAR_TXFIFOHE       = {.msk = 0x00004000U, .pos = 14};   /** @brief Transmit FIFO half empty at least half the number of words can be written into the FIFO. This bit is cleared when the FIFO becomes half+1 full. */
  static const field32_t SDMMCx_STAR_RXFIFOHF       = {.msk = 0x00008000U, .pos = 15};   /** @brief Receive FIFO half full there are at least half the number of words in the FIFO. This bit is cleared when the FIFO becomes half+1 empty. */
  static const field32_t SDMMCx_STAR_TXFIFOF        = {.msk = 0x00010000U, .pos = 16};   /** @brief Transmit FIFO full this is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes empty. */
  static const field32_t SDMMCx_STAR_RXFIFOF        = {.msk = 0x00020000U, .pos = 17};   /** @brief Receive FIFO full this bit is cleared when one FIFO location becomes empty. */
  static const field32_t SDMMCx_STAR_TXFIFOE        = {.msk = 0x00040000U, .pos = 18};   /** @brief Transmit FIFO empty this bit is cleared when one FIFO location becomes full. */
  static const field32_t SDMMCx_STAR_RXFIFOE        = {.msk = 0x00080000U, .pos = 19};   /** @brief Receive FIFO empty this is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes full. */
  static const field32_t SDMMCx_STAR_BUSYD0         = {.msk = 0x00100000U, .pos = 20};   /** @brief Inverted value of SDMMC_D0 line (busy), sampled at the end of a CMD response and a second time 2 SDMMC_CK cycles after the CMD response. This bit is reset to not busy when the SDMMCD0 line changes from busy to not busy. This bit does not signal busy due to data transfer. This is a hardware status flag only, it does not generate an interrupt. */
  static const field32_t SDMMCx_STAR_BUSYD0END      = {.msk = 0x00200000U, .pos = 21};   /** @brief End of SDMMC_D0 busy following a CMD response detected. This indicates only end of busy following a CMD response. This bit does not signal busy due to data transfer. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const field32_t SDMMCx_STAR_SDIOIT         = {.msk = 0x00400000U, .pos = 22};   /** @brief SDIO interrupt received. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const field32_t SDMMCx_STAR_ACKFAIL        = {.msk = 0x00800000U, .pos = 23};   /** @brief Boot acknowledgment received (boot acknowledgment check fail). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const field32_t SDMMCx_STAR_ACKTIMEOUT     = {.msk = 0x01000000U, .pos = 24};   /** @brief Boot acknowledgment timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const field32_t SDMMCx_STAR_VSWEND         = {.msk = 0x02000000U, .pos = 25};   /** @brief Voltage switch critical timing section completion. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const field32_t SDMMCx_STAR_CKSTOP         = {.msk = 0x04000000U, .pos = 26};   /** @brief SDMMC_CK stopped in voltage switch procedure. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const field32_t SDMMCx_STAR_IDMATE         = {.msk = 0x08000000U, .pos = 27};   /** @brief IDMA transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const field32_t SDMMCx_STAR_IDMABTC        = {.msk = 0x10000000U, .pos = 28};   /** @brief IDMA buffer transfer complete. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const field32_t SDMMCx_ICR_CCRCFAILC       = {.msk = 0x00000001U, .pos = 0};    /** @brief CCRCFAIL flag clear bit set by software to clear the CCRCFAIL flag. */
  static const field32_t SDMMCx_ICR_DCRCFAILC       = {.msk = 0x00000002U, .pos = 1};    /** @brief DCRCFAIL flag clear bit set by software to clear the DCRCFAIL flag. */
  static const field32_t SDMMCx_ICR_CTIMEOUTC       = {.msk = 0x00000004U, .pos = 2};    /** @brief CTIMEOUT flag clear bit set by software to clear the CTIMEOUT flag. */
  static const field32_t SDMMCx_ICR_DTIMEOUTC       = {.msk = 0x00000008U, .pos = 3};    /** @brief DTIMEOUT flag clear bit set by software to clear the DTIMEOUT flag. */
  static const field32_t SDMMCx_ICR_TXUNDERRC       = {.msk = 0x00000010U, .pos = 4};    /** @brief TXUNDERR flag clear bit set by software to clear TXUNDERR flag. */
  static const field32_t SDMMCx_ICR_RXOVERRC        = {.msk = 0x00000020U, .pos = 5};    /** @brief RXOVERR flag clear bit set by software to clear the RXOVERR flag. */
  static const field32_t SDMMCx_ICR_CMDRENDC        = {.msk = 0x00000040U, .pos = 6};    /** @brief CMDREND flag clear bit set by software to clear the CMDREND flag. */
  static const field32_t SDMMCx_ICR_CMDSENTC        = {.msk = 0x00000080U, .pos = 7};    /** @brief CMDSENT flag clear bit set by software to clear the CMDSENT flag. */
  static const field32_t SDMMCx_ICR_DATAENDC        = {.msk = 0x00000100U, .pos = 8};    /** @brief DATAEND flag clear bit set by software to clear the DATAEND flag. */
  static const field32_t SDMMCx_ICR_DHOLDC          = {.msk = 0x00000200U, .pos = 9};    /** @brief DHOLD flag clear bit set by software to clear the DHOLD flag. */
  static const field32_t SDMMCx_ICR_DBCKENDC        = {.msk = 0x00000400U, .pos = 10};   /** @brief DBCKEND flag clear bit set by software to clear the DBCKEND flag. */
  static const field32_t SDMMCx_ICR_DABORTC         = {.msk = 0x00000800U, .pos = 11};   /** @brief DABORT flag clear bit set by software to clear the DABORT flag. */
  static const field32_t SDMMCx_ICR_BUSYD0ENDC      = {.msk = 0x00200000U, .pos = 21};   /** @brief BUSYD0END flag clear bit set by software to clear the BUSYD0END flag. */
  static const field32_t SDMMCx_ICR_SDIOITC         = {.msk = 0x00400000U, .pos = 22};   /** @brief SDIOIT flag clear bit set by software to clear the SDIOIT flag. */
  static const field32_t SDMMCx_ICR_ACKFAILC        = {.msk = 0x00800000U, .pos = 23};   /** @brief ACKFAIL flag clear bit set by software to clear the ACKFAIL flag. */
  static const field32_t SDMMCx_ICR_ACKTIMEOUTC     = {.msk = 0x01000000U, .pos = 24};   /** @brief ACKTIMEOUT flag clear bit set by software to clear the ACKTIMEOUT flag. */
  static const field32_t SDMMCx_ICR_VSWENDC         = {.msk = 0x02000000U, .pos = 25};   /** @brief VSWEND flag clear bit set by software to clear the VSWEND flag. */
  static const field32_t SDMMCx_ICR_CKSTOPC         = {.msk = 0x04000000U, .pos = 26};   /** @brief CKSTOP flag clear bit set by software to clear the CKSTOP flag. */
  static const field32_t SDMMCx_ICR_IDMATEC         = {.msk = 0x08000000U, .pos = 27};   /** @brief IDMA transfer error clear bit set by software to clear the IDMATE flag. */
  static const field32_t SDMMCx_ICR_IDMABTCC        = {.msk = 0x10000000U, .pos = 28};   /** @brief IDMA buffer transfer complete clear bit set by software to clear the IDMABTC flag. */
  static const field32_t SDMMCx_MASKR_CCRCFAILIE    = {.msk = 0x00000001U, .pos = 0};    /** @brief Command CRC fail interrupt enable set and cleared by software to enable/disable interrupt caused by command CRC failure. */
  static const field32_t SDMMCx_MASKR_DCRCFAILIE    = {.msk = 0x00000002U, .pos = 1};    /** @brief Data CRC fail interrupt enable set and cleared by software to enable/disable interrupt caused by data CRC failure. */
  static const field32_t SDMMCx_MASKR_CTIMEOUTIE    = {.msk = 0x00000004U, .pos = 2};    /** @brief Command timeout interrupt enable set and cleared by software to enable/disable interrupt caused by command timeout. */
  static const field32_t SDMMCx_MASKR_DTIMEOUTIE    = {.msk = 0x00000008U, .pos = 3};    /** @brief Data timeout interrupt enable set and cleared by software to enable/disable interrupt caused by data timeout. */
  static const field32_t SDMMCx_MASKR_TXUNDERRIE    = {.msk = 0x00000010U, .pos = 4};    /** @brief Tx FIFO underrun error interrupt enable set and cleared by software to enable/disable interrupt caused by tx FIFO underrun error. */
  static const field32_t SDMMCx_MASKR_RXOVERRIE     = {.msk = 0x00000020U, .pos = 5};    /** @brief Rx FIFO overrun error interrupt enable set and cleared by software to enable/disable interrupt caused by rx FIFO overrun error. */
  static const field32_t SDMMCx_MASKR_CMDRENDIE     = {.msk = 0x00000040U, .pos = 6};    /** @brief Command response received interrupt enable set and cleared by software to enable/disable interrupt caused by receiving command response. */
  static const field32_t SDMMCx_MASKR_CMDSENTIE     = {.msk = 0x00000080U, .pos = 7};    /** @brief Command sent interrupt enable set and cleared by software to enable/disable interrupt caused by sending command. */
  static const field32_t SDMMCx_MASKR_DATAENDIE     = {.msk = 0x00000100U, .pos = 8};    /** @brief Data end interrupt enable set and cleared by software to enable/disable interrupt caused by data end. */
  static const field32_t SDMMCx_MASKR_DHOLDIE       = {.msk = 0x00000200U, .pos = 9};    /** @brief Data hold interrupt enable set and cleared by software to enable/disable the interrupt generated when sending new data is hold in the DPSM wait_s state. */
  static const field32_t SDMMCx_MASKR_DBCKENDIE     = {.msk = 0x00000400U, .pos = 10};   /** @brief Data block end interrupt enable set and cleared by software to enable/disable interrupt caused by data block end. */
  static const field32_t SDMMCx_MASKR_DABORTIE      = {.msk = 0x00000800U, .pos = 11};   /** @brief Data transfer aborted interrupt enable set and cleared by software to enable/disable interrupt caused by a data transfer being aborted. */
  static const field32_t SDMMCx_MASKR_TXFIFOHEIE    = {.msk = 0x00004000U, .pos = 14};   /** @brief Tx FIFO half empty interrupt enable set and cleared by software to enable/disable interrupt caused by tx FIFO half empty. */
  static const field32_t SDMMCx_MASKR_RXFIFOHFIE    = {.msk = 0x00008000U, .pos = 15};   /** @brief Rx FIFO half full interrupt enable set and cleared by software to enable/disable interrupt caused by rx FIFO half full. */
  static const field32_t SDMMCx_MASKR_RXFIFOFIE     = {.msk = 0x00020000U, .pos = 17};   /** @brief Rx FIFO full interrupt enable set and cleared by software to enable/disable interrupt caused by rx FIFO full. */
  static const field32_t SDMMCx_MASKR_TXFIFOEIE     = {.msk = 0x00040000U, .pos = 18};   /** @brief Tx FIFO empty interrupt enable set and cleared by software to enable/disable interrupt caused by tx FIFO empty. */
  static const field32_t SDMMCx_MASKR_BUSYD0ENDIE   = {.msk = 0x00200000U, .pos = 21};   /** @brief BUSYD0END interrupt enable set and cleared by software to enable/disable the interrupt generated when SDMMC_D0 signal changes from busy to NOT busy following a CMD response. */
  static const field32_t SDMMCx_MASKR_SDIOITIE      = {.msk = 0x00400000U, .pos = 22};   /** @brief SDIO mode interrupt received interrupt enable set and cleared by software to enable/disable the interrupt generated when receiving the SDIO mode interrupt. */
  static const field32_t SDMMCx_MASKR_ACKFAILIE     = {.msk = 0x00800000U, .pos = 23};   /** @brief Acknowledgment fail interrupt enable set and cleared by software to enable/disable interrupt caused by acknowledgment fail. */
  static const field32_t SDMMCx_MASKR_ACKTIMEOUTIE  = {.msk = 0x01000000U, .pos = 24};   /** @brief Acknowledgment timeout interrupt enable set and cleared by software to enable/disable interrupt caused by acknowledgment timeout. */
  static const field32_t SDMMCx_MASKR_VSWENDIE      = {.msk = 0x02000000U, .pos = 25};   /** @brief Voltage switch critical timing section completion interrupt enable set and cleared by software to enable/disable the interrupt generated when voltage switch critical timing section completion. */
  static const field32_t SDMMCx_MASKR_CKSTOPIE      = {.msk = 0x04000000U, .pos = 26};   /** @brief Voltage switch clock stopped interrupt enable set and cleared by software to enable/disable interrupt caused by voltage switch clock stopped. */
  static const field32_t SDMMCx_MASKR_IDMABTCIE     = {.msk = 0x10000000U, .pos = 28};   /** @brief IDMA buffer transfer complete interrupt enable set and cleared by software to enable/disable the interrupt generated when the IDMA has transferred all data belonging to a memory buffer. */
  static const field32_t SDMMCx_ACKTIMER_ACKTIME    = {.msk = 0x01FFFFFFU, .pos = 0};    /** @brief Boot acknowledgment timeout period this bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). Boot acknowledgment timeout period expressed in card bus clock periods. */
  static const field32_t SDMMCx_IDMACTRLR_IDMAEN    = {.msk = 0x00000001U, .pos = 0};    /** @brief IDMA enable this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
  static const field32_t SDMMCx_IDMACTRLR_IDMABMODE = {.msk = 0x00000002U, .pos = 1};    /** @brief Buffer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
  static const field32_t SDMMCx_IDMACTRLR_IDMABACT  = {.msk = 0x00000004U, .pos = 2};    /** @brief Double buffer mode active buffer indication this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). When IDMA is enabled this bit is toggled by hardware. */
  static const field32_t SDMMCx_IDMABSIZER_IDMABNDT = {.msk = 0x00001FE0U, .pos = 5};    /** @brief Number of transfers per buffer. This 8-bit value shall be multiplied by 8 to get the size of the buffer in 32-bit words and by 32 to get the size of the buffer in bytes. Example: IDMABNDT = 0x01: buffer size = 8 words = 32 bytes. These bits can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
  static const field32_t SDMMCx_RESPCMDR_RESPCMD    = {.msk = 0x0000003FU, .pos = 0};    /** @brief Response command index. */

  /************************************************************************************************
   * VREFBUF Definitions
   ************************************************************************************************/

  /**** VREFBUF Register Definitions ****/

  static const rw_reg32_t VREFBUF_CSR = (rw_reg32_t)0x58003C00U;   /** @brief VREFBUF control and status register. */
  static const rw_reg32_t VREFBUF_CCR = (rw_reg32_t)0x58003C04U;   /** @brief VREFBUF calibration control register. */

  /**** VREFBUF Register Field Definitions ****/

  static const field32_t VREFBUF_CSR_ENVR = {.msk = 0x00000001U, .pos = 0};   /** @brief Voltage reference buffer mode enable this bit is used to enable the voltage reference buffer mode. */
  static const field32_t VREFBUF_CSR_HIZ  = {.msk = 0x00000002U, .pos = 1};   /** @brief High impedance mode this bit controls the analog switch to connect or not the VREF+ pin. Refer to table196: VREF buffer modes for the mode descriptions depending on ENVR bit configuration. */
  static const field32_t VREFBUF_CSR_VRR  = {.msk = 0x00000008U, .pos = 3};   /** @brief Voltage reference buffer ready. */
  static const field32_t VREFBUF_CSR_VRS  = {.msk = 0x00000070U, .pos = 4};   /** @brief Voltage reference scale these bits select the value generated by the voltage reference buffer. Other: reserved. */
  static const field32_t VREFBUF_CCR_TRIM = {.msk = 0x0000003FU, .pos = 0};   /** @brief Trimming code these bits are automatically initialized after reset with the trimming value stored in the flash memory during the production test. Writing into these bits allows to tune the internal reference buffer voltage. */

  /************************************************************************************************
   * IWDGx Definitions
   ************************************************************************************************/

  /**** Enumerated IWDGx Register Definitions ****/

  static const rw_reg32_t IWDGx_KR[3] = {
    [1] = (rw_reg32_t)0x58004800U,   /** @brief Key register. */
    [2] = (rw_reg32_t)0x58004C00U,   /** @brief Key register. */
  };

  static const rw_reg32_t IWDGx_PR[3] = {
    [1] = (rw_reg32_t)0x58004804U,   /** @brief Prescaler register. */
    [2] = (rw_reg32_t)0x58004C04U,   /** @brief Prescaler register. */
  };

  static const rw_reg32_t IWDGx_RLR[3] = {
    [1] = (rw_reg32_t)0x58004808U,   /** @brief Reload register. */
    [2] = (rw_reg32_t)0x58004C08U,   /** @brief Reload register. */
  };

  static const ro_reg32_t IWDGx_SR[3] = {
    [1] = (ro_reg32_t)0x5800480CU,   /** @brief Status register. */
    [2] = (ro_reg32_t)0x58004C0CU,   /** @brief Status register. */
  };

  static const rw_reg32_t IWDGx_WINR[3] = {
    [1] = (rw_reg32_t)0x58004810U,   /** @brief Window register. */
    [2] = (rw_reg32_t)0x58004C10U,   /** @brief Window register. */
  };

  /**** IWDGx Register Field Definitions ****/

  static const field32_t IWDGx_KR_KEY   = {.msk = 0x0000FFFFU, .pos = 0};   /** @brief Key value (write only, read 0x0000) these bits must be written by software at regular intervals with the key value 0xaaaa, otherwise the watchdog generates a reset when the counter reaches 0. Writing the key value 0x5555 to enable access to the IWDG_PR, IWDG_RLR and IWDG_WINR registers (see section23.3.6: register access protection) writing the key value cccch starts the watchdog (except if the hardware watchdog option is selected). */
  static const field32_t IWDGx_PR_PR    = {.msk = 0x00000007U, .pos = 0};   /** @brief Prescaler divider these bits are write access protected see section23.3.6: register access protection. They are written by software to select the prescaler divider feeding the counter clock. PVU bit of IWDG_SR must be reset in order to be able to change the prescaler divider. Note: reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the IWDG_SR register is reset. */
  static const field32_t IWDGx_RLR_RL   = {.msk = 0x00000FFFU, .pos = 0};   /** @brief Watchdog counter reload value these bits are write access protected see section23.3.6. They are written by software to define the value to be loaded in the watchdog counter each time the value 0xaaaa is written in the IWDG_KR register. The watchdog counter counts down from this value. The timeout period is a function of this value and the clock prescaler. Refer to the datasheet for the timeout information. The RVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: reading this register returns the reload value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing on this register. For this reason the value read from this register is valid only when the RVU bit in the IWDG_SR register is reset. */
  static const field32_t IWDGx_SR_PVU   = {.msk = 0x00000001U, .pos = 0};   /** @brief Watchdog prescaler value update this bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Prescaler value can be updated only when PVU bit is reset. */
  static const field32_t IWDGx_SR_RVU   = {.msk = 0x00000002U, .pos = 1};   /** @brief Watchdog counter reload value update this bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Reload value can be updated only when RVU bit is reset. */
  static const field32_t IWDGx_SR_WVU   = {.msk = 0x00000004U, .pos = 2};   /** @brief Watchdog counter window value update this bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Window value can be updated only when WVU bit is reset. This bit is generated only if generic window = 1. */
  static const field32_t IWDGx_WINR_WIN = {.msk = 0x00000FFFU, .pos = 0};   /** @brief Watchdog counter window value these bits are write access protected see section23.3.6. These bits contain the high limit of the window value to be compared to the downcounter. To prevent a reset, the downcounter must be reloaded when its value is lower than the window register value and greater than 0x0 the WVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: reading this register returns the reload value from the VDD voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the IWDG_SR register is reset. */

  /************************************************************************************************
   * WWDGx Definitions
   ************************************************************************************************/

  /**** Enumerated WWDGx Register Definitions ****/

  static const rw_reg32_t WWDGx_CR[3] = {
    [1] = (rw_reg32_t)0x50003000U,   /** @brief Control register. */
    [2] = (rw_reg32_t)0x40002C00U,   /** @brief Control register. */
  };

  static const rw_reg32_t WWDGx_CFR[3] = {
    [1] = (rw_reg32_t)0x50003004U,   /** @brief Configuration register. */
    [2] = (rw_reg32_t)0x40002C04U,   /** @brief Configuration register. */
  };

  static const rw_reg32_t WWDGx_SR[3] = {
    [1] = (rw_reg32_t)0x50003008U,   /** @brief Status register. */
    [2] = (rw_reg32_t)0x40002C08U,   /** @brief Status register. */
  };

  /**** WWDGx Register Field Definitions ****/

  static const field32_t WWDGx_CR_T      = {.msk = 0x0000007FU, .pos = 0};    /** @brief 7-bit counter (MSB to LSB) these bits contain the value of the watchdog counter. It is decremented every (4096 x 2WDGTB[1:0]) PCLK cycles. A reset is produced when it is decremented from 0x40 to 0x3f (T6 becomes cleared). */
  static const field32_t WWDGx_CR_WDGA   = {.msk = 0x00000080U, .pos = 7};    /** @brief Activation bit this bit is set by software and only cleared by hardware after a reset. When WDGA=1, the watchdog can generate a reset. */
  static const field32_t WWDGx_CFR_W     = {.msk = 0x0000007FU, .pos = 0};    /** @brief 7-bit window value these bits contain the window value to be compared to the downcounter. */
  static const field32_t WWDGx_CFR_WDGTB = {.msk = 0x00001800U, .pos = 11};   /** @brief Timer base the time base of the prescaler can be modified as follows:. */
  static const field32_t WWDGx_CFR_EWI   = {.msk = 0x00000200U, .pos = 9};    /** @brief Early wakeup interrupt when set, an interrupt occurs whenever the counter reaches the value 0x40. This interrupt is only cleared by hardware after a reset. */
  static const field32_t WWDGx_SR_EWIF   = {.msk = 0x00000001U, .pos = 0};    /** @brief Early wakeup interrupt flag this bit is set by hardware when the counter has reached the value 0x40. It must be cleared by software by writing 0. A write of 1 has no effect. This bit is also set if the interrupt is not enabled. */

  /************************************************************************************************
   * PWR Definitions
   ************************************************************************************************/

  /**** PWR Register Definitions ****/

  static const ro_reg32_t PWR_CSR1    = (ro_reg32_t)0x58024804U;   /** @brief PWR control status register 1. */
  static const rw_reg32_t PWR_CPUCR   = (rw_reg32_t)0x58024810U;   /** @brief This register allows controlling CPU1 power. */
  static const rw_reg32_t PWR_D3CR    = (rw_reg32_t)0x58024818U;   /** @brief This register allows controlling D3 domain power.following reset VOSRDY will be read 1 by software. */
  static const rw_reg32_t PWR_WKUPCR  = (rw_reg32_t)0x58024820U;   /** @brief Reset only by system reset, not reset by wakeup from standby mode5 wait states are required when writing this register (when clearing a WKUPF bit in PWR_WKUPFR, the AHB write access will complete after the WKUPF has been cleared). */
  static const rw_reg32_t PWR_WKUPFR  = (rw_reg32_t)0x58024824U;   /** @brief Reset only by system reset, not reset by wakeup from standby mode. */
  static const rw_reg32_t PWR_WKUPEPR = (rw_reg32_t)0x58024828U;   /** @brief Reset only by system reset, not reset by wakeup from standby mode. */

  /**** Enumerated PWR Register Definitions ****/

  static const rw_reg32_t PWR_CRx[4] = {
    [1] = (rw_reg32_t)0x58024800U,   /** @brief PWR control register 1. */
    [2] = (rw_reg32_t)0x58024808U,   /** @brief This register is not reset by wakeup from standby mode, RESET signal and VDD POR. It is only reset by VSW POR and VSWRST reset. This register shall not be accessed when VSWRST bit in RCC_BDCR register resets the VSW domain.after reset, PWR_CR2 register is write-protected. Prior to modifying its content, the DBP bit in PWR_CR1 register must be set to disable the write protection. */
    [3] = (rw_reg32_t)0x5802480CU,   /** @brief Reset only by POR only, not reset by wakeup from standby mode and RESET pad. The lower byte of this register is written once after POR and shall be written before changing VOS level or ck_sys clock frequency. No limitation applies to the upper bytes.programming data corresponding to an invalid combination of SDLEVEL, SDEXTHP, SDEN, LDOEN and BYPASS bits (see table9) will be ignored: data will not be written, the written-once mechanism will lock the register and any further write access will be ignored. The default supply configuration will be kept and the ACTVOSRDY bit in PWR control status register 1 (PWR_CSR1) will go on indicating invalid voltage levels. The system shall be power cycled before writing a new value. */
  };

  /**** PWR Register Field Definitions ****/

  static const field32_t PWR_CRx_LPDS       = {.msk = 0x00000001U, .pos = 0};    /** @brief Low-power deepsleep with SVOS3 (SVOS4 and SVOS5 always use low-power, regardless of the setting of this bit). */
  static const field32_t PWR_CRx_PVDE       = {.msk = 0x00000010U, .pos = 4};    /** @brief Programmable voltage detector enable. */
  static const field32_t PWR_CRx_PLS        = {.msk = 0x000000E0U, .pos = 5};    /** @brief Programmable voltage detector level selection these bits select the voltage threshold detected by the PVD. Note: refer to section electrical characteristics of the product datasheet for more details. */
  static const field32_t PWR_CRx_DBP        = {.msk = 0x00000100U, .pos = 8};    /** @brief Disable backup domain write protection in reset state, the RCC_BDCR register, the RTC registers (including the backup registers), BREN and MOEN bits in PWR_CR2 register, are protected against parasitic write access. This bit must be set to enable write access to these registers. */
  static const field32_t PWR_CRx_FLPS       = {.msk = 0x00000200U, .pos = 9};    /** @brief Flash low-power mode in dstop mode this bit allows to obtain the best trade-off between low-power consumption and restart time when exiting from dstop mode. When it is set, the flash memory enters low-power mode when D1 domain is in dstop mode. */
  static const field32_t PWR_CRx_SVOS       = {.msk = 0x0000C000U, .pos = 14};   /** @brief System stop mode voltage scaling selection these bits control the VCORE voltage level in system stop mode, to obtain the best trade-off between power consumption and performance. */
  static const field32_t PWR_CRx_AVDEN      = {.msk = 0x00010000U, .pos = 16};   /** @brief Peripheral voltage monitor on VDDA enable. */
  static const field32_t PWR_CRx_ALS        = {.msk = 0x00060000U, .pos = 17};   /** @brief Analog voltage detector level selection these bits select the voltage threshold detected by the AVD. */
  static const field32_t PWR_CSR1_PVDO      = {.msk = 0x00000010U, .pos = 4};    /** @brief Programmable voltage detect output this bit is set and cleared by hardware. It is valid only if the PVD has been enabled by the PVDE bit. Note: since the PVD is disabled in standby mode, this bit is equal to 0 after standby or reset until the PVDE bit is set. */
  static const field32_t PWR_CSR1_ACTVOSRDY = {.msk = 0x00002000U, .pos = 13};   /** @brief Voltage levels ready bit for currently used VOS and SDLEVEL this bit is set to 1 by hardware when the voltage regulator and the SD converter are both disabled and bypass mode is selected in PWR control register 3 (PWR_CR3). */
  static const field32_t PWR_CSR1_ACTVOS    = {.msk = 0x0000C000U, .pos = 14};   /** @brief VOS currently applied for VCORE voltage scaling selection. These bits reflect the last VOS value applied to the PMU. */
  static const field32_t PWR_CSR1_AVDO      = {.msk = 0x00010000U, .pos = 16};   /** @brief Analog voltage detector output on VDDA this bit is set and cleared by hardware. It is valid only if AVD on VDDA is enabled by the AVDEN bit. Note: since the AVD is disabled in standby mode, this bit is equal to 0 after standby or reset until the AVDEN bit is set. */
  static const field32_t PWR_CPUCR_STOPF    = {.msk = 0x00000020U, .pos = 5};    /** @brief STOP flag this bit is set by hardware and cleared only by any reset or by setting the CPU1 CSSF bit. */
  static const field32_t PWR_CPUCR_SBF      = {.msk = 0x00000040U, .pos = 6};    /** @brief System standby flag this bit is set by hardware and cleared only by a POR (power-on reset) or by setting the CPU1 CSSF bit. */
  static const field32_t PWR_CPUCR_CSSF     = {.msk = 0x00000200U, .pos = 9};    /** @brief Clear D1 domain CPU1 standby, stop and HOLD flags (always read as 0) this bit is cleared to 0 by hardware. */
  static const field32_t PWR_CPUCR_RUN_D3   = {.msk = 0x00000800U, .pos = 11};   /** @brief Keep system D3 domain in run mode regardless of the CPU sub-systems modes. */
  static const field32_t PWR_D3CR_VOSRDY    = {.msk = 0x00002000U, .pos = 13};   /** @brief VOS ready bit for VCORE voltage scaling output selection. This bit is set to 1 by hardware when bypass mode is selected in PWR control register 3 (PWR_CR3). */
  static const field32_t PWR_D3CR_VOS       = {.msk = 0x0000C000U, .pos = 14};   /** @brief Voltage scaling selection according to performance these bits control the VCORE voltage level and allow to obtains the best trade-off between power consumption and performance: when increasing the performance, the voltage scaling shall be changed before increasing the system frequency. When decreasing performance, the system frequency shall first be decreased before changing the voltage scaling. */
  static const field32_t PWR_WKUPCR_WKUPC   = {.msk = 0x0000003FU, .pos = 0};    /** @brief Clear wakeup pin flag for WKUP. These bits are always read as 0. */

  /**** Enumerated PWR Register Field Definitions ****/

  static field32_t const PWR_CPUCR_PDDS_Dx[4] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief D1 domain power down deepsleep selection. This bit allows CPU1 to define the deepsleep mode for D1 domain. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief D2 domain power down deepsleep. This bit allows CPU1 to define the deepsleep mode for D2 domain. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief System D3 domain power down deepsleep. This bit allows CPU1 to define the deepsleep mode for system D3 domain. */
  };

  static field32_t const PWR_CPUCR_SBF_Dx[3] = {
    [1] = {.msk = 0x00000080U, .pos = 7},   /** @brief D1 domain dstandby flag this bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D1 domain is no longer in dstandby mode. */
    [2] = {.msk = 0x00000100U, .pos = 8},   /** @brief D2 domain dstandby flag this bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D2 domain is no longer in dstandby mode. */
  };

  static field32_t const PWR_WKUPFR_WKUPFx[7] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
    [5] = {.msk = 0x00000010U, .pos = 4},   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
    [6] = {.msk = 0x00000020U, .pos = 5},   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
  };

  static field32_t const PWR_WKUPEPR_WKUPENx[7] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
    [5] = {.msk = 0x00000010U, .pos = 4},   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
    [6] = {.msk = 0x00000020U, .pos = 5},   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
  };

  static field32_t const PWR_WKUPEPR_WKUPPx[7] = {
    [1] = {.msk = 0x00000100U, .pos = 8},    /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
    [2] = {.msk = 0x00000200U, .pos = 9},    /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
    [3] = {.msk = 0x00000400U, .pos = 10},   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
    [4] = {.msk = 0x00000800U, .pos = 11},   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
    [5] = {.msk = 0x00001000U, .pos = 12},   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
    [6] = {.msk = 0x00002000U, .pos = 13},   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
  };

  static field32_t const PWR_WKUPEPR_WKUPPUPDx[7] = {
    [1] = {.msk = 0x00030000U, .pos = 16},   /** @brief Wakeup pin pull configuration. */
    [2] = {.msk = 0x000C0000U, .pos = 18},   /** @brief Wakeup pin pull configuration. */
    [3] = {.msk = 0x00300000U, .pos = 20},   /** @brief Wakeup pin pull configuration. */
    [4] = {.msk = 0x00C00000U, .pos = 22},   /** @brief Wakeup pin pull configuration. */
    [5] = {.msk = 0x03000000U, .pos = 24},   /** @brief Wakeup pin pull configuration. */
    [6] = {.msk = 0x0C000000U, .pos = 26},   /** @brief Wakeup pin pull configuration for wkup(truncate(n/2)-7) these bits define the I/O pad pull configuration used when wkupen(truncate(n/2)-7) = 1. The associated GPIO port pull configuration shall be set to the same value or to 00. The wakeup pin pull configuration is kept in standby mode. */
  };

  /************************************************************************************************
   * SPIx Definitions
   ************************************************************************************************/

  /**** Enumerated SPIx Register Definitions ****/

  static const rw_reg32_t SPIx_CRx[7][3] = {
    [1] = {
      [1] = (rw_reg32_t)0x40013000U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40013004U,   /** @brief Control register 2. */
    },
    [2] = {
      [1] = (rw_reg32_t)0x40003800U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40003804U,   /** @brief Control register 2. */
    },
    [3] = {
      [1] = (rw_reg32_t)0x40003C00U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40003C04U,   /** @brief Control register 2. */
    },
    [4] = {
      [1] = (rw_reg32_t)0x40013400U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40013404U,   /** @brief Control register 2. */
    },
    [5] = {
      [1] = (rw_reg32_t)0x40015000U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40015004U,   /** @brief Control register 2. */
    },
    [6] = {
      [1] = (rw_reg32_t)0x58001400U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x58001404U,   /** @brief Control register 2. */
    },
  };

  static const rw_reg32_t SPIx_CFGx[7][3] = {
    [1] = {
      [1] = (rw_reg32_t)0x40013008U,   /** @brief Configuration register 1. */
      [2] = (rw_reg32_t)0x4001300CU,   /** @brief Configuration register 2. */
    },
    [2] = {
      [1] = (rw_reg32_t)0x40003808U,   /** @brief Configuration register 1. */
      [2] = (rw_reg32_t)0x4000380CU,   /** @brief Configuration register 2. */
    },
    [3] = {
      [1] = (rw_reg32_t)0x40003C08U,   /** @brief Configuration register 1. */
      [2] = (rw_reg32_t)0x40003C0CU,   /** @brief Configuration register 2. */
    },
    [4] = {
      [1] = (rw_reg32_t)0x40013408U,   /** @brief Configuration register 1. */
      [2] = (rw_reg32_t)0x4001340CU,   /** @brief Configuration register 2. */
    },
    [5] = {
      [1] = (rw_reg32_t)0x40015008U,   /** @brief Configuration register 1. */
      [2] = (rw_reg32_t)0x4001500CU,   /** @brief Configuration register 2. */
    },
    [6] = {
      [1] = (rw_reg32_t)0x58001408U,   /** @brief Configuration register 1. */
      [2] = (rw_reg32_t)0x5800140CU,   /** @brief Configuration register 2. */
    },
  };

  static const rw_reg32_t SPIx_IER[7] = {
    [1] = (rw_reg32_t)0x40013010U,   /** @brief Interrupt enable register. */
    [2] = (rw_reg32_t)0x40003810U,   /** @brief Interrupt enable register. */
    [3] = (rw_reg32_t)0x40003C10U,   /** @brief Interrupt enable register. */
    [4] = (rw_reg32_t)0x40013410U,   /** @brief Interrupt enable register. */
    [5] = (rw_reg32_t)0x40015010U,   /** @brief Interrupt enable register. */
    [6] = (rw_reg32_t)0x58001410U,   /** @brief Interrupt enable register. */
  };

  static const ro_reg32_t SPIx_SR[7] = {
    [1] = (ro_reg32_t)0x40013014U,   /** @brief Status register. */
    [2] = (ro_reg32_t)0x40003814U,   /** @brief Status register. */
    [3] = (ro_reg32_t)0x40003C14U,   /** @brief Status register. */
    [4] = (ro_reg32_t)0x40013414U,   /** @brief Status register. */
    [5] = (ro_reg32_t)0x40015014U,   /** @brief Status register. */
    [6] = (ro_reg32_t)0x58001414U,   /** @brief Status register. */
  };

  static const rw_reg32_t SPIx_IFCR[7] = {
    [1] = (rw_reg32_t)0x40013018U,   /** @brief Interrupt/Status flags clear register. */
    [2] = (rw_reg32_t)0x40003818U,   /** @brief Interrupt/Status flags clear register. */
    [3] = (rw_reg32_t)0x40003C18U,   /** @brief Interrupt/Status flags clear register. */
    [4] = (rw_reg32_t)0x40013418U,   /** @brief Interrupt/Status flags clear register. */
    [5] = (rw_reg32_t)0x40015018U,   /** @brief Interrupt/Status flags clear register. */
    [6] = (rw_reg32_t)0x58001418U,   /** @brief Interrupt/Status flags clear register. */
  };

  static const rw_reg32_t SPIx_TXDR[7] = {
    [1] = (rw_reg32_t)0x40013020U,   /** @brief Transmit data register. */
    [2] = (rw_reg32_t)0x40003820U,   /** @brief Transmit data register. */
    [3] = (rw_reg32_t)0x40003C20U,   /** @brief Transmit data register. */
    [4] = (rw_reg32_t)0x40013420U,   /** @brief Transmit data register. */
    [5] = (rw_reg32_t)0x40015020U,   /** @brief Transmit data register. */
    [6] = (rw_reg32_t)0x58001420U,   /** @brief Transmit data register. */
  };

  static const ro_reg32_t SPIx_RXDR[7] = {
    [1] = (ro_reg32_t)0x40013030U,   /** @brief Receive data register. */
    [2] = (ro_reg32_t)0x40003830U,   /** @brief Receive data register. */
    [3] = (ro_reg32_t)0x40003C30U,   /** @brief Receive data register. */
    [4] = (ro_reg32_t)0x40013430U,   /** @brief Receive data register. */
    [5] = (ro_reg32_t)0x40015030U,   /** @brief Receive data register. */
    [6] = (ro_reg32_t)0x58001430U,   /** @brief Receive data register. */
  };

  static const rw_reg32_t SPIx_CRCPOLY[7] = {
    [1] = (rw_reg32_t)0x40013040U,   /** @brief Polynomial register. */
    [2] = (rw_reg32_t)0x40003840U,   /** @brief Polynomial register. */
    [3] = (rw_reg32_t)0x40003C40U,   /** @brief Polynomial register. */
    [4] = (rw_reg32_t)0x40013440U,   /** @brief Polynomial register. */
    [5] = (rw_reg32_t)0x40015040U,   /** @brief Polynomial register. */
    [6] = (rw_reg32_t)0x58001440U,   /** @brief Polynomial register. */
  };

  static const rw_reg32_t SPIx_TXCRC[7] = {
    [1] = (rw_reg32_t)0x40013044U,   /** @brief Transmitter CRC register. */
    [2] = (rw_reg32_t)0x40003844U,   /** @brief Transmitter CRC register. */
    [3] = (rw_reg32_t)0x40003C44U,   /** @brief Transmitter CRC register. */
    [4] = (rw_reg32_t)0x40013444U,   /** @brief Transmitter CRC register. */
    [5] = (rw_reg32_t)0x40015044U,   /** @brief Transmitter CRC register. */
    [6] = (rw_reg32_t)0x58001444U,   /** @brief Transmitter CRC register. */
  };

  static const rw_reg32_t SPIx_RXCRC[7] = {
    [1] = (rw_reg32_t)0x40013048U,   /** @brief Receiver CRC register. */
    [2] = (rw_reg32_t)0x40003848U,   /** @brief Receiver CRC register. */
    [3] = (rw_reg32_t)0x40003C48U,   /** @brief Receiver CRC register. */
    [4] = (rw_reg32_t)0x40013448U,   /** @brief Receiver CRC register. */
    [5] = (rw_reg32_t)0x40015048U,   /** @brief Receiver CRC register. */
    [6] = (rw_reg32_t)0x58001448U,   /** @brief Receiver CRC register. */
  };

  static const rw_reg32_t SPIx_UDRDR[7] = {
    [1] = (rw_reg32_t)0x4001304CU,   /** @brief Underrun data register. */
    [2] = (rw_reg32_t)0x4000384CU,   /** @brief Underrun data register. */
    [3] = (rw_reg32_t)0x40003C4CU,   /** @brief Underrun data register. */
    [4] = (rw_reg32_t)0x4001344CU,   /** @brief Underrun data register. */
    [5] = (rw_reg32_t)0x4001504CU,   /** @brief Underrun data register. */
    [6] = (rw_reg32_t)0x5800144CU,   /** @brief Underrun data register. */
  };

  static const rw_reg32_t SPIx_CGFR[7] = {
    [1] = (rw_reg32_t)0x40013050U,   /** @brief Configuration register. */
    [2] = (rw_reg32_t)0x40003850U,   /** @brief Configuration register. */
    [3] = (rw_reg32_t)0x40003C50U,   /** @brief Configuration register. */
    [4] = (rw_reg32_t)0x40013450U,   /** @brief Configuration register. */
    [5] = (rw_reg32_t)0x40015050U,   /** @brief Configuration register. */
    [6] = (rw_reg32_t)0x58001450U,   /** @brief Configuration register. */
  };

  /**** SPIx Register Field Definitions ****/

  static const field32_t SPIx_CRx_IOLOCK   = {.msk = 0x00010000U, .pos = 16};   /** @brief Locking the AF configuration of associated ios. */
  static const field32_t SPIx_CRx_TCRCI    = {.msk = 0x00008000U, .pos = 15};   /** @brief CRC calculation initialization pattern control for transmitter. */
  static const field32_t SPIx_CRx_RCRCI    = {.msk = 0x00004000U, .pos = 14};   /** @brief CRC calculation initialization pattern control for receiver. */
  static const field32_t SPIx_CRx_CRC33_17 = {.msk = 0x00002000U, .pos = 13};   /** @brief 32-bit CRC polynomial configuration. */
  static const field32_t SPIx_CRx_SSI      = {.msk = 0x00001000U, .pos = 12};   /** @brief Internal SS signal input level. */
  static const field32_t SPIx_CRx_HDDIR    = {.msk = 0x00000800U, .pos = 11};   /** @brief Rx/Tx direction at half-duplex mode. */
  static const field32_t SPIx_CRx_CSUSP    = {.msk = 0x00000400U, .pos = 10};   /** @brief Master suspend request. */
  static const field32_t SPIx_CRx_CSTART   = {.msk = 0x00000200U, .pos = 9};    /** @brief Master transfer start. */
  static const field32_t SPIx_CRx_MASRX    = {.msk = 0x00000100U, .pos = 8};    /** @brief Master automatic SUSP in receive mode. */
  static const field32_t SPIx_CRx_SPE      = {.msk = 0x00000001U, .pos = 0};    /** @brief Serial peripheral enable. */
  static const field32_t SPIx_CFGx_MBR     = {.msk = 0x70000000U, .pos = 28};   /** @brief Master baud rate. */
  static const field32_t SPIx_CFGx_CRCEN   = {.msk = 0x00400000U, .pos = 22};   /** @brief Hardware CRC computation enable. */
  static const field32_t SPIx_CFGx_CRCSIZE = {.msk = 0x001F0000U, .pos = 16};   /** @brief Length of CRC frame to be transacted and compared. */
  static const field32_t SPIx_CFGx_TXDMAEN = {.msk = 0x00008000U, .pos = 15};   /** @brief Tx DMA stream enable. */
  static const field32_t SPIx_CFGx_RXDMAEN = {.msk = 0x00004000U, .pos = 14};   /** @brief Rx DMA stream enable. */
  static const field32_t SPIx_CFGx_UDRDET  = {.msk = 0x00001800U, .pos = 11};   /** @brief Detection of underrun condition at slave transmitter. */
  static const field32_t SPIx_CFGx_UDRCFG  = {.msk = 0x00000600U, .pos = 9};    /** @brief Behavior of slave transmitter at underrun condition. */
  static const field32_t SPIx_CFGx_FTHVL   = {.msk = 0x000001E0U, .pos = 5};    /** @brief Threshold level. */
  static const field32_t SPIx_CFGx_DSIZE   = {.msk = 0x0000001FU, .pos = 0};    /** @brief Number of bits in at single SPI data frame. */
  static const field32_t SPIx_IER_TSERFIE  = {.msk = 0x00000400U, .pos = 10};   /** @brief Additional number of transactions reload interrupt enable. */
  static const field32_t SPIx_IER_MODFIE   = {.msk = 0x00000200U, .pos = 9};    /** @brief Mode fault interrupt enable. */
  static const field32_t SPIx_IER_TIFREIE  = {.msk = 0x00000100U, .pos = 8};    /** @brief TIFRE interrupt enable. */
  static const field32_t SPIx_IER_CRCEIE   = {.msk = 0x00000080U, .pos = 7};    /** @brief CRC interrupt enable. */
  static const field32_t SPIx_IER_OVRIE    = {.msk = 0x00000040U, .pos = 6};    /** @brief OVR interrupt enable. */
  static const field32_t SPIx_IER_UDRIE    = {.msk = 0x00000020U, .pos = 5};    /** @brief UDR interrupt enable. */
  static const field32_t SPIx_IER_TXTFIE   = {.msk = 0x00000010U, .pos = 4};    /** @brief TXTFIE interrupt enable. */
  static const field32_t SPIx_IER_EOTIE    = {.msk = 0x00000008U, .pos = 3};    /** @brief EOT, SUSP and TXC interrupt enable. */
  static const field32_t SPIx_IER_DPXPIE   = {.msk = 0x00000004U, .pos = 2};    /** @brief DXP interrupt enabled. */
  static const field32_t SPIx_IER_TXPIE    = {.msk = 0x00000002U, .pos = 1};    /** @brief TXP interrupt enable. */
  static const field32_t SPIx_IER_RXPIE    = {.msk = 0x00000001U, .pos = 0};    /** @brief RXP interrupt enable. */
  static const field32_t SPIx_SR_CTSIZE    = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief Number of data frames remaining in current TSIZE session. */
  static const field32_t SPIx_SR_RXWNE     = {.msk = 0x00008000U, .pos = 15};   /** @brief RxFIFO word not empty. */
  static const field32_t SPIx_SR_RXPLVL    = {.msk = 0x00006000U, .pos = 13};   /** @brief RxFIFO packing level. */
  static const field32_t SPIx_SR_TXC       = {.msk = 0x00001000U, .pos = 12};   /** @brief TxFIFO transmission complete. */
  static const field32_t SPIx_SR_SUSP      = {.msk = 0x00000800U, .pos = 11};   /** @brief SUSPend. */
  static const field32_t SPIx_SR_TSERF     = {.msk = 0x00000400U, .pos = 10};   /** @brief Additional number of SPI data to be transacted was reload. */
  static const field32_t SPIx_SR_MODF      = {.msk = 0x00000200U, .pos = 9};    /** @brief Mode fault. */
  static const field32_t SPIx_SR_TIFRE     = {.msk = 0x00000100U, .pos = 8};    /** @brief TI frame format error. */
  static const field32_t SPIx_SR_CRCE      = {.msk = 0x00000080U, .pos = 7};    /** @brief CRC error. */
  static const field32_t SPIx_SR_OVR       = {.msk = 0x00000040U, .pos = 6};    /** @brief Overrun. */
  static const field32_t SPIx_SR_UDR       = {.msk = 0x00000020U, .pos = 5};    /** @brief Underrun at slave transmission mode. */
  static const field32_t SPIx_SR_TXTF      = {.msk = 0x00000010U, .pos = 4};    /** @brief Transmission transfer filled. */
  static const field32_t SPIx_SR_EOT       = {.msk = 0x00000008U, .pos = 3};    /** @brief End of transfer. */
  static const field32_t SPIx_SR_DXP       = {.msk = 0x00000004U, .pos = 2};    /** @brief Duplex packet. */
  static const field32_t SPIx_SR_TXP       = {.msk = 0x00000002U, .pos = 1};    /** @brief Tx-Packet space available. */
  static const field32_t SPIx_SR_RXP       = {.msk = 0x00000001U, .pos = 0};    /** @brief Rx-Packet available. */
  static const field32_t SPIx_IFCR_SUSPC   = {.msk = 0x00000800U, .pos = 11};   /** @brief SUSPend flag clear. */
  static const field32_t SPIx_IFCR_TSERFC  = {.msk = 0x00000400U, .pos = 10};   /** @brief TSERFC flag clear. */
  static const field32_t SPIx_IFCR_MODFC   = {.msk = 0x00000200U, .pos = 9};    /** @brief Mode fault flag clear. */
  static const field32_t SPIx_IFCR_TIFREC  = {.msk = 0x00000100U, .pos = 8};    /** @brief TI frame format error flag clear. */
  static const field32_t SPIx_IFCR_CRCEC   = {.msk = 0x00000080U, .pos = 7};    /** @brief CRC error flag clear. */
  static const field32_t SPIx_IFCR_OVRC    = {.msk = 0x00000040U, .pos = 6};    /** @brief Overrun flag clear. */
  static const field32_t SPIx_IFCR_UDRC    = {.msk = 0x00000020U, .pos = 5};    /** @brief Underrun flag clear. */
  static const field32_t SPIx_IFCR_TXTFC   = {.msk = 0x00000010U, .pos = 4};    /** @brief Transmission transfer filled flag clear. */
  static const field32_t SPIx_IFCR_EOTC    = {.msk = 0x00000008U, .pos = 3};    /** @brief End of transfer flag clear. */
  static const field32_t SPIx_CGFR_MCKOE   = {.msk = 0x02000000U, .pos = 25};   /** @brief Master clock output enable. */
  static const field32_t SPIx_CGFR_ODD     = {.msk = 0x01000000U, .pos = 24};   /** @brief Odd factor for the prescaler. */
  static const field32_t SPIx_CGFR_I2SDIV  = {.msk = 0x00FF0000U, .pos = 16};   /** @brief I2S linear prescaler. */
  static const field32_t SPIx_CGFR_DATFMT  = {.msk = 0x00004000U, .pos = 14};   /** @brief Data format. */
  static const field32_t SPIx_CGFR_WSINV   = {.msk = 0x00002000U, .pos = 13};   /** @brief Fixed channel length in SLAVE. */
  static const field32_t SPIx_CGFR_FIXCH   = {.msk = 0x00001000U, .pos = 12};   /** @brief Word select inversion. */
  static const field32_t SPIx_CGFR_CKPOL   = {.msk = 0x00000800U, .pos = 11};   /** @brief Serial audio clock polarity. */
  static const field32_t SPIx_CGFR_CHLEN   = {.msk = 0x00000400U, .pos = 10};   /** @brief Channel length (number of bits per audio channel). */
  static const field32_t SPIx_CGFR_DATLEN  = {.msk = 0x00000300U, .pos = 8};    /** @brief Data length to be transferred. */
  static const field32_t SPIx_CGFR_PCMSYNC = {.msk = 0x00000080U, .pos = 7};    /** @brief PCM frame synchronization. */
  static const field32_t SPIx_CGFR_I2SSTD  = {.msk = 0x00000030U, .pos = 4};    /** @brief I2S standard selection. */
  static const field32_t SPIx_CGFR_I2SCFG  = {.msk = 0x0000000EU, .pos = 1};    /** @brief I2S configuration mode. */
  static const field32_t SPIx_CGFR_I2SMOD  = {.msk = 0x00000001U, .pos = 0};    /** @brief I2S mode selection. */

  /************************************************************************************************
   * LTDC Definitions
   ************************************************************************************************/

  /**** LTDC Register Definitions ****/

  static const rw_reg32_t LTDC_SSCR  = (rw_reg32_t)0x50001008U;   /** @brief Synchronization size configuration register. */
  static const rw_reg32_t LTDC_BPCR  = (rw_reg32_t)0x5000100CU;   /** @brief Back porch configuration register. */
  static const rw_reg32_t LTDC_AWCR  = (rw_reg32_t)0x50001010U;   /** @brief Active width configuration register. */
  static const rw_reg32_t LTDC_TWCR  = (rw_reg32_t)0x50001014U;   /** @brief Total width configuration register. */
  static const rw_reg32_t LTDC_GCR   = (rw_reg32_t)0x50001018U;   /** @brief Global control register. */
  static const rw_reg32_t LTDC_SRCR  = (rw_reg32_t)0x50001024U;   /** @brief Shadow reload configuration register. */
  static const rw_reg32_t LTDC_BCCR  = (rw_reg32_t)0x5000102CU;   /** @brief Background color configuration register. */
  static const rw_reg32_t LTDC_IER   = (rw_reg32_t)0x50001034U;   /** @brief Interrupt enable register. */
  static const ro_reg32_t LTDC_ISR   = (ro_reg32_t)0x50001038U;   /** @brief Interrupt status register. */
  static const rw_reg32_t LTDC_ICR   = (rw_reg32_t)0x5000103CU;   /** @brief Interrupt clear register. */
  static const rw_reg32_t LTDC_LIPCR = (rw_reg32_t)0x50001040U;   /** @brief Line interrupt position configuration register. */
  static const ro_reg32_t LTDC_CPSR  = (ro_reg32_t)0x50001044U;   /** @brief Current position status register. */
  static const ro_reg32_t LTDC_CDSR  = (ro_reg32_t)0x50001048U;   /** @brief Current display status register. */

  /**** Enumerated LTDC Register Definitions ****/

  static const rw_reg32_t LTDC_LxCR[3] = {
    [1] = (rw_reg32_t)0x50001084U,   /** @brief Layerx control register. */
    [2] = (rw_reg32_t)0x50001104U,   /** @brief Layerx control register. */
  };

  static const rw_reg32_t LTDC_LxWHPCR[3] = {
    [1] = (rw_reg32_t)0x50001088U,   /** @brief Layerx window horizontal position configuration register. */
    [2] = (rw_reg32_t)0x50001108U,   /** @brief Layerx window horizontal position configuration register. */
  };

  static const rw_reg32_t LTDC_LxWVPCR[3] = {
    [1] = (rw_reg32_t)0x5000108CU,   /** @brief Layerx window vertical position configuration register. */
    [2] = (rw_reg32_t)0x5000110CU,   /** @brief Layerx window vertical position configuration register. */
  };

  static const rw_reg32_t LTDC_LxCKCR[3] = {
    [1] = (rw_reg32_t)0x50001090U,   /** @brief Layerx color keying configuration register. */
    [2] = (rw_reg32_t)0x50001110U,   /** @brief Layerx color keying configuration register. */
  };

  static const rw_reg32_t LTDC_LxPFCR[3] = {
    [1] = (rw_reg32_t)0x50001094U,   /** @brief Layerx pixel format configuration register. */
    [2] = (rw_reg32_t)0x50001114U,   /** @brief Layerx pixel format configuration register. */
  };

  static const rw_reg32_t LTDC_LxCACR[3] = {
    [1] = (rw_reg32_t)0x50001098U,   /** @brief Layerx constant alpha configuration register. */
    [2] = (rw_reg32_t)0x50001118U,   /** @brief Layerx constant alpha configuration register. */
  };

  static const rw_reg32_t LTDC_LxDCCR[3] = {
    [1] = (rw_reg32_t)0x5000109CU,   /** @brief Layerx default color configuration register. */
    [2] = (rw_reg32_t)0x5000111CU,   /** @brief Layerx default color configuration register. */
  };

  static const rw_reg32_t LTDC_LxBFCR[3] = {
    [1] = (rw_reg32_t)0x500010A0U,   /** @brief Layerx blending factors configuration register. */
    [2] = (rw_reg32_t)0x50001120U,   /** @brief Layerx blending factors configuration register. */
  };

  static const rw_reg32_t LTDC_LxCFBAR[3] = {
    [1] = (rw_reg32_t)0x500010ACU,   /** @brief Layerx color frame buffer address register. */
    [2] = (rw_reg32_t)0x5000112CU,   /** @brief Layerx color frame buffer address register. */
  };

  static const rw_reg32_t LTDC_LxCFBLR[3] = {
    [1] = (rw_reg32_t)0x500010B0U,   /** @brief Layerx color frame buffer length register. */
    [2] = (rw_reg32_t)0x50001130U,   /** @brief Layerx color frame buffer length register. */
  };

  static const rw_reg32_t LTDC_LxCFBLNR[3] = {
    [1] = (rw_reg32_t)0x500010B4U,   /** @brief Layerx colorframe buffer line number register. */
    [2] = (rw_reg32_t)0x50001134U,   /** @brief Layerx colorframe buffer line number register. */
  };

  static const rw_reg32_t LTDC_LxCLUTWR[3] = {
    [1] = (rw_reg32_t)0x500010C4U,   /** @brief Layerx CLUT write register. */
    [2] = (rw_reg32_t)0x50001144U,   /** @brief Layerx CLUT write register. */
  };

  /**** LTDC Register Field Definitions ****/

  static const field32_t LTDC_SSCR_HSW         = {.msk = 0x03FF0000U, .pos = 16};   /** @brief Horizontal synchronization width (in units of pixel clock period). */
  static const field32_t LTDC_SSCR_VSH         = {.msk = 0x000007FFU, .pos = 0};    /** @brief Vertical synchronization height (in units of horizontal scan line). */
  static const field32_t LTDC_BPCR_AHBP        = {.msk = 0x0FFF0000U, .pos = 16};   /** @brief Accumulated horizontal back porch (in units of pixel clock period). */
  static const field32_t LTDC_BPCR_AVBP        = {.msk = 0x000007FFU, .pos = 0};    /** @brief Accumulated vertical back porch (in units of horizontal scan line). */
  static const field32_t LTDC_AWCR_AAV         = {.msk = 0x0FFF0000U, .pos = 16};   /** @brief AAV. */
  static const field32_t LTDC_AWCR_AAH         = {.msk = 0x000007FFU, .pos = 0};    /** @brief Accumulated active height (in units of horizontal scan line). */
  static const field32_t LTDC_TWCR_TOTALW      = {.msk = 0x0FFF0000U, .pos = 16};   /** @brief Total width (in units of pixel clock period). */
  static const field32_t LTDC_TWCR_TOTALH      = {.msk = 0x000007FFU, .pos = 0};    /** @brief Total height (in units of horizontal scan line). */
  static const field32_t LTDC_GCR_HSPOL        = {.msk = 0x80000000U, .pos = 31};   /** @brief Horizontal synchronization polarity. */
  static const field32_t LTDC_GCR_VSPOL        = {.msk = 0x40000000U, .pos = 30};   /** @brief Vertical synchronization polarity. */
  static const field32_t LTDC_GCR_DEPOL        = {.msk = 0x20000000U, .pos = 29};   /** @brief Data enable polarity. */
  static const field32_t LTDC_GCR_PCPOL        = {.msk = 0x10000000U, .pos = 28};   /** @brief Pixel clock polarity. */
  static const field32_t LTDC_GCR_DEN          = {.msk = 0x00010000U, .pos = 16};   /** @brief Dither enable. */
  static const field32_t LTDC_GCR_DRW          = {.msk = 0x00007000U, .pos = 12};   /** @brief Dither red width. */
  static const field32_t LTDC_GCR_DGW          = {.msk = 0x00000700U, .pos = 8};    /** @brief Dither green width. */
  static const field32_t LTDC_GCR_DBW          = {.msk = 0x00000070U, .pos = 4};    /** @brief Dither blue width. */
  static const field32_t LTDC_GCR_LTDCEN       = {.msk = 0x00000001U, .pos = 0};    /** @brief LCD-TFT controller enable bit. */
  static const field32_t LTDC_SRCR_VBR         = {.msk = 0x00000002U, .pos = 1};    /** @brief Vertical blanking reload. */
  static const field32_t LTDC_SRCR_IMR         = {.msk = 0x00000001U, .pos = 0};    /** @brief Immediate reload. */
  static const field32_t LTDC_BCCR_BCBLUE      = {.msk = 0x000000FFU, .pos = 0};    /** @brief Background color blue value. */
  static const field32_t LTDC_BCCR_BCGREEN     = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Background color green value. */
  static const field32_t LTDC_BCCR_BCRED       = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Background color red value. */
  static const field32_t LTDC_IER_RRIE         = {.msk = 0x00000008U, .pos = 3};    /** @brief Register reload interrupt enable. */
  static const field32_t LTDC_IER_TERRIE       = {.msk = 0x00000004U, .pos = 2};    /** @brief Transfer error interrupt enable. */
  static const field32_t LTDC_IER_FUIE         = {.msk = 0x00000002U, .pos = 1};    /** @brief FIFO underrun interrupt enable. */
  static const field32_t LTDC_IER_LIE          = {.msk = 0x00000001U, .pos = 0};    /** @brief Line interrupt enable. */
  static const field32_t LTDC_ISR_RRIF         = {.msk = 0x00000008U, .pos = 3};    /** @brief Register reload interrupt flag. */
  static const field32_t LTDC_ISR_TERRIF       = {.msk = 0x00000004U, .pos = 2};    /** @brief Transfer error interrupt flag. */
  static const field32_t LTDC_ISR_FUIF         = {.msk = 0x00000002U, .pos = 1};    /** @brief FIFO underrun interrupt flag. */
  static const field32_t LTDC_ISR_LIF          = {.msk = 0x00000001U, .pos = 0};    /** @brief Line interrupt flag. */
  static const field32_t LTDC_ICR_CRRIF        = {.msk = 0x00000008U, .pos = 3};    /** @brief Clears register reload interrupt flag. */
  static const field32_t LTDC_ICR_CTERRIF      = {.msk = 0x00000004U, .pos = 2};    /** @brief Clears the transfer error interrupt flag. */
  static const field32_t LTDC_ICR_CFUIF        = {.msk = 0x00000002U, .pos = 1};    /** @brief Clears the FIFO underrun interrupt flag. */
  static const field32_t LTDC_ICR_CLIF         = {.msk = 0x00000001U, .pos = 0};    /** @brief Clears the line interrupt flag. */
  static const field32_t LTDC_LIPCR_LIPOS      = {.msk = 0x000007FFU, .pos = 0};    /** @brief Line interrupt position. */
  static const field32_t LTDC_CPSR_CXPOS       = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief Current X position. */
  static const field32_t LTDC_CPSR_CYPOS       = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Current Y position. */
  static const field32_t LTDC_CDSR_HSYNCS      = {.msk = 0x00000008U, .pos = 3};    /** @brief Horizontal synchronization display status. */
  static const field32_t LTDC_CDSR_VSYNCS      = {.msk = 0x00000004U, .pos = 2};    /** @brief Vertical synchronization display status. */
  static const field32_t LTDC_CDSR_HDES        = {.msk = 0x00000002U, .pos = 1};    /** @brief Horizontal data enable display status. */
  static const field32_t LTDC_CDSR_VDES        = {.msk = 0x00000001U, .pos = 0};    /** @brief Vertical data enable display status. */
  static const field32_t LTDC_LxCR_CLUTEN      = {.msk = 0x00000010U, .pos = 4};    /** @brief Color look-up table enable. */
  static const field32_t LTDC_LxCR_COLKEN      = {.msk = 0x00000002U, .pos = 1};    /** @brief Color keying enable. */
  static const field32_t LTDC_LxCR_LEN         = {.msk = 0x00000001U, .pos = 0};    /** @brief Layer enable. */
  static const field32_t LTDC_LxWHPCR_WHSPPOS  = {.msk = 0x0FFF0000U, .pos = 16};   /** @brief Window horizontal stop position. */
  static const field32_t LTDC_LxWHPCR_WHSTPOS  = {.msk = 0x00000FFFU, .pos = 0};    /** @brief Window horizontal start position. */
  static const field32_t LTDC_LxWVPCR_WVSPPOS  = {.msk = 0x07FF0000U, .pos = 16};   /** @brief Window vertical stop position. */
  static const field32_t LTDC_LxWVPCR_WVSTPOS  = {.msk = 0x000007FFU, .pos = 0};    /** @brief Window vertical start position. */
  static const field32_t LTDC_LxCKCR_CKRED     = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Color key red value. */
  static const field32_t LTDC_LxCKCR_CKGREEN   = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Color key green value. */
  static const field32_t LTDC_LxCKCR_CKBLUE    = {.msk = 0x000000FFU, .pos = 0};    /** @brief Color key blue value. */
  static const field32_t LTDC_LxPFCR_PF        = {.msk = 0x00000007U, .pos = 0};    /** @brief Pixel format. */
  static const field32_t LTDC_LxCACR_CONSTA    = {.msk = 0x000000FFU, .pos = 0};    /** @brief Constant alpha. */
  static const field32_t LTDC_LxDCCR_DCALPHA   = {.msk = 0xFF000000U, .pos = 24};   /** @brief Default color alpha. */
  static const field32_t LTDC_LxDCCR_DCRED     = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Default color red. */
  static const field32_t LTDC_LxDCCR_DCGREEN   = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Default color green. */
  static const field32_t LTDC_LxDCCR_DCBLUE    = {.msk = 0x000000FFU, .pos = 0};    /** @brief Default color blue. */
  static const field32_t LTDC_LxCFBLR_CFBP     = {.msk = 0x1FFF0000U, .pos = 16};   /** @brief Color frame buffer pitch in bytes. */
  static const field32_t LTDC_LxCFBLR_CFBLL    = {.msk = 0x00001FFFU, .pos = 0};    /** @brief Color frame buffer line length. */
  static const field32_t LTDC_LxCFBLNR_CFBLNBR = {.msk = 0x000007FFU, .pos = 0};    /** @brief Frame buffer line number. */
  static const field32_t LTDC_LxCLUTWR_CLUTADD = {.msk = 0xFF000000U, .pos = 24};   /** @brief CLUT address. */
  static const field32_t LTDC_LxCLUTWR_RED     = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Red value. */
  static const field32_t LTDC_LxCLUTWR_GREEN   = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Green value. */
  static const field32_t LTDC_LxCLUTWR_BLUE    = {.msk = 0x000000FFU, .pos = 0};    /** @brief Blue value. */

  /**** Enumerated LTDC Register Field Definitions ****/

  static field32_t const LTDC_LxBFCR_BFx[3] = {
    [1] = {.msk = 0x00000700U, .pos = 8},   /** @brief Blending factor 1. */
    [2] = {.msk = 0x00000007U, .pos = 0},   /** @brief Blending factor 2. */
  };

  /************************************************************************************************
   * SPDIFRX Definitions
   ************************************************************************************************/

  /**** SPDIFRX Register Definitions ****/

  static const rw_reg32_t SPDIFRX_CR   = (rw_reg32_t)0x40004000U;   /** @brief Control register. */
  static const rw_reg32_t SPDIFRX_IMR  = (rw_reg32_t)0x40004004U;   /** @brief Interrupt mask register. */
  static const ro_reg32_t SPDIFRX_SR   = (ro_reg32_t)0x40004008U;   /** @brief Status register. */
  static const rw_reg32_t SPDIFRX_IFCR = (rw_reg32_t)0x4000400CU;   /** @brief Interrupt flag clear register. */
  static const ro_reg32_t SPDIFRX_CSR  = (ro_reg32_t)0x40004014U;   /** @brief Channel status register. */
  static const ro_reg32_t SPDIFRX_DIR  = (ro_reg32_t)0x40004018U;   /** @brief Debug information register. */
  static const ro_reg32_t SPDIFRX_VERR = (ro_reg32_t)0x400043F4U;   /** @brief SPDIFRX version register. */
  static const ro_reg32_t SPDIFRX_IDR  = (ro_reg32_t)0x400043F8U;   /** @brief SPDIFRX identification register. */
  static const ro_reg32_t SPDIFRX_SIDR = (ro_reg32_t)0x400043FCU;   /** @brief SPDIFRX size identification register. */

  /**** Enumerated SPDIFRX Register Definitions ****/

  static const ro_reg32_t SPDIFRX_DR_x[11] = {
    [0]  = (ro_reg32_t)0x40004010U,   /** @brief Data input register. */
    [10] = (ro_reg32_t)0x40004010U,   /** @brief Data input register. */
  };

  static const ro_reg32_t SPDIFRX_DR_0x[2] = {
    [1] = (ro_reg32_t)0x40004010U,   /** @brief Data input register. */
  };

  /**** SPDIFRX Register Field Definitions ****/

  static const field32_t SPDIFRX_CR_SPDIFRXEN = {.msk = 0x00000003U, .pos = 0};    /** @brief Peripheral block enable. */
  static const field32_t SPDIFRX_CR_RXDMAEN   = {.msk = 0x00000004U, .pos = 2};    /** @brief Receiver DMA enable for data flow. */
  static const field32_t SPDIFRX_CR_RXSTEO    = {.msk = 0x00000008U, .pos = 3};    /** @brief STerEO mode. */
  static const field32_t SPDIFRX_CR_DRFMT     = {.msk = 0x00000030U, .pos = 4};    /** @brief RX data format. */
  static const field32_t SPDIFRX_CR_PMSK      = {.msk = 0x00000040U, .pos = 6};    /** @brief Mask parity error bit. */
  static const field32_t SPDIFRX_CR_VMSK      = {.msk = 0x00000080U, .pos = 7};    /** @brief Mask of validity bit. */
  static const field32_t SPDIFRX_CR_CUMSK     = {.msk = 0x00000100U, .pos = 8};    /** @brief Mask of channel status and user bits. */
  static const field32_t SPDIFRX_CR_PTMSK     = {.msk = 0x00000200U, .pos = 9};    /** @brief Mask of preamble type bits. */
  static const field32_t SPDIFRX_CR_CBDMAEN   = {.msk = 0x00000400U, .pos = 10};   /** @brief Control buffer DMA enable for control flow. */
  static const field32_t SPDIFRX_CR_CHSEL     = {.msk = 0x00000800U, .pos = 11};   /** @brief Channel selection. */
  static const field32_t SPDIFRX_CR_NBTR      = {.msk = 0x00003000U, .pos = 12};   /** @brief Maximum allowed re-tries during synchronization phase. */
  static const field32_t SPDIFRX_CR_WFA       = {.msk = 0x00004000U, .pos = 14};   /** @brief Wait for activity. */
  static const field32_t SPDIFRX_CR_INSEL     = {.msk = 0x00070000U, .pos = 16};   /** @brief Input selection. */
  static const field32_t SPDIFRX_CR_CKSEN     = {.msk = 0x00100000U, .pos = 20};   /** @brief Symbol clock enable. */
  static const field32_t SPDIFRX_CR_CKSBKPEN  = {.msk = 0x00200000U, .pos = 21};   /** @brief Backup symbol clock enable. */
  static const field32_t SPDIFRX_IMR_RXNEIE   = {.msk = 0x00000001U, .pos = 0};    /** @brief RXNE interrupt enable. */
  static const field32_t SPDIFRX_IMR_CSRNEIE  = {.msk = 0x00000002U, .pos = 1};    /** @brief Control buffer ready interrupt enable. */
  static const field32_t SPDIFRX_IMR_PERRIE   = {.msk = 0x00000004U, .pos = 2};    /** @brief Parity error interrupt enable. */
  static const field32_t SPDIFRX_IMR_OVRIE    = {.msk = 0x00000008U, .pos = 3};    /** @brief Overrun error interrupt enable. */
  static const field32_t SPDIFRX_IMR_SBLKIE   = {.msk = 0x00000010U, .pos = 4};    /** @brief Synchronization block detected interrupt enable. */
  static const field32_t SPDIFRX_IMR_SYNCDIE  = {.msk = 0x00000020U, .pos = 5};    /** @brief Synchronization done. */
  static const field32_t SPDIFRX_IMR_IFEIE    = {.msk = 0x00000040U, .pos = 6};    /** @brief Serial interface error interrupt enable. */
  static const field32_t SPDIFRX_SR_RXNE      = {.msk = 0x00000001U, .pos = 0};    /** @brief Read data register not empty. */
  static const field32_t SPDIFRX_SR_CSRNE     = {.msk = 0x00000002U, .pos = 1};    /** @brief Control buffer register is not empty. */
  static const field32_t SPDIFRX_SR_PERR      = {.msk = 0x00000004U, .pos = 2};    /** @brief Parity error. */
  static const field32_t SPDIFRX_SR_OVR       = {.msk = 0x00000008U, .pos = 3};    /** @brief Overrun error. */
  static const field32_t SPDIFRX_SR_SBD       = {.msk = 0x00000010U, .pos = 4};    /** @brief Synchronization block detected. */
  static const field32_t SPDIFRX_SR_SYNCD     = {.msk = 0x00000020U, .pos = 5};    /** @brief Synchronization done. */
  static const field32_t SPDIFRX_SR_FERR      = {.msk = 0x00000040U, .pos = 6};    /** @brief Framing error. */
  static const field32_t SPDIFRX_SR_SERR      = {.msk = 0x00000080U, .pos = 7};    /** @brief Synchronization error. */
  static const field32_t SPDIFRX_SR_TERR      = {.msk = 0x00000100U, .pos = 8};    /** @brief Time-out error. */
  static const field32_t SPDIFRX_SR_WIDTH5    = {.msk = 0x7FFF0000U, .pos = 16};   /** @brief Duration of 5 symbols counted with SPDIF_CLK. */
  static const field32_t SPDIFRX_IFCR_PERRCF  = {.msk = 0x00000004U, .pos = 2};    /** @brief Clears the parity error flag. */
  static const field32_t SPDIFRX_IFCR_OVRCF   = {.msk = 0x00000008U, .pos = 3};    /** @brief Clears the overrun error flag. */
  static const field32_t SPDIFRX_IFCR_SBDCF   = {.msk = 0x00000010U, .pos = 4};    /** @brief Clears the synchronization block detected flag. */
  static const field32_t SPDIFRX_IFCR_SYNCDCF = {.msk = 0x00000020U, .pos = 5};    /** @brief Clears the synchronization done flag. */
  static const field32_t SPDIFRX_DR_x_DR      = {.msk = 0x00FFFFFFU, .pos = 0};    /** @brief Parity error bit. */
  static const field32_t SPDIFRX_DR_x_PE      = {.msk = 0x01000000U, .pos = 24};   /** @brief Parity error bit. */
  static const field32_t SPDIFRX_DR_x_V       = {.msk = 0x02000000U, .pos = 25};   /** @brief Validity bit. */
  static const field32_t SPDIFRX_DR_x_U       = {.msk = 0x04000000U, .pos = 26};   /** @brief User bit. */
  static const field32_t SPDIFRX_DR_x_C       = {.msk = 0x08000000U, .pos = 27};   /** @brief Channel status bit. */
  static const field32_t SPDIFRX_DR_x_PT      = {.msk = 0x30000000U, .pos = 28};   /** @brief Preamble type. */
  static const field32_t SPDIFRX_CSR_USR      = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief User data information. */
  static const field32_t SPDIFRX_CSR_CS       = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Channel A status information. */
  static const field32_t SPDIFRX_CSR_SOB      = {.msk = 0x01000000U, .pos = 24};   /** @brief Start of block. */
  static const field32_t SPDIFRX_DIR_THI      = {.msk = 0x00001FFFU, .pos = 0};    /** @brief Threshold HIGH. */
  static const field32_t SPDIFRX_DIR_TLO      = {.msk = 0x1FFF0000U, .pos = 16};   /** @brief Threshold LOW. */
  static const field32_t SPDIFRX_VERR_MINREV  = {.msk = 0x0000000FU, .pos = 0};    /** @brief Minor revision. */
  static const field32_t SPDIFRX_VERR_MAJREV  = {.msk = 0x000000F0U, .pos = 4};    /** @brief Major revision. */
  static const field32_t SPDIFRX_DR_0x_PE     = {.msk = 0x00000001U, .pos = 0};    /** @brief Parity error bit. */
  static const field32_t SPDIFRX_DR_0x_V      = {.msk = 0x00000002U, .pos = 1};    /** @brief Validity bit. */
  static const field32_t SPDIFRX_DR_0x_U      = {.msk = 0x00000004U, .pos = 2};    /** @brief User bit. */
  static const field32_t SPDIFRX_DR_0x_C      = {.msk = 0x00000008U, .pos = 3};    /** @brief Channel status bit. */
  static const field32_t SPDIFRX_DR_0x_PT     = {.msk = 0x00000030U, .pos = 4};    /** @brief Preamble type. */
  static const field32_t SPDIFRX_DR_0x_DR     = {.msk = 0xFFFFFF00U, .pos = 8};    /** @brief Data value. */

  /************************************************************************************************
   * ADCx Definitions
   ************************************************************************************************/

  /**** Enumerated ADCx Register Definitions ****/

  static const rw_reg32_t ADCx_ISR[4] = {
    [1] = (rw_reg32_t)0x40022000U,   /** @brief ADC interrupt and status register. */
    [2] = (rw_reg32_t)0x40022100U,   /** @brief ADC interrupt and status register. */
    [3] = (rw_reg32_t)0x58026000U,   /** @brief ADC interrupt and status register. */
  };

  static const rw_reg32_t ADCx_IER[4] = {
    [1] = (rw_reg32_t)0x40022004U,   /** @brief ADC interrupt enable register. */
    [2] = (rw_reg32_t)0x40022104U,   /** @brief ADC interrupt enable register. */
    [3] = (rw_reg32_t)0x58026004U,   /** @brief ADC interrupt enable register. */
  };

  static const rw_reg32_t ADCx_CR[4] = {
    [1] = (rw_reg32_t)0x40022008U,   /** @brief ADC control register. */
    [2] = (rw_reg32_t)0x40022108U,   /** @brief ADC control register. */
    [3] = (rw_reg32_t)0x58026008U,   /** @brief ADC control register. */
  };

  static const rw_reg32_t ADCx_CFGR[4] = {
    [1] = (rw_reg32_t)0x4002200CU,   /** @brief ADC configuration register 1. */
    [2] = (rw_reg32_t)0x4002210CU,   /** @brief ADC configuration register 1. */
    [3] = (rw_reg32_t)0x5802600CU,   /** @brief ADC configuration register 1. */
  };

  static const rw_reg32_t ADCx_CFGR2[4] = {
    [1] = (rw_reg32_t)0x40022010U,   /** @brief ADC configuration register 2. */
    [2] = (rw_reg32_t)0x40022110U,   /** @brief ADC configuration register 2. */
    [3] = (rw_reg32_t)0x58026010U,   /** @brief ADC configuration register 2. */
  };

  static const rw_reg32_t ADCx_SMPRx[4][3] = {
    [1] = {
      [1] = (rw_reg32_t)0x40022014U,   /** @brief ADC sampling time register 1. */
      [2] = (rw_reg32_t)0x40022018U,   /** @brief ADC sampling time register 2. */
    },
    [2] = {
      [1] = (rw_reg32_t)0x40022114U,   /** @brief ADC sampling time register 1. */
      [2] = (rw_reg32_t)0x40022118U,   /** @brief ADC sampling time register 2. */
    },
    [3] = {
      [1] = (rw_reg32_t)0x58026014U,   /** @brief ADC sampling time register 1. */
      [2] = (rw_reg32_t)0x58026018U,   /** @brief ADC sampling time register 2. */
    },
  };

  static const rw_reg32_t ADCx_LTRx[4][4] = {
    [1] = {
      [1] = (rw_reg32_t)0x40022020U,   /** @brief ADC analog watchdog 1 threshold register. */
      [2] = (rw_reg32_t)0x400220B0U,   /** @brief ADC watchdog lower threshold register 2. */
      [3] = (rw_reg32_t)0x400220B8U,   /** @brief ADC watchdog lower threshold register 3. */
    },
    [2] = {
      [1] = (rw_reg32_t)0x40022120U,   /** @brief ADC analog watchdog 1 threshold register. */
      [2] = (rw_reg32_t)0x400221B0U,   /** @brief ADC watchdog lower threshold register 2. */
      [3] = (rw_reg32_t)0x400221B8U,   /** @brief ADC watchdog lower threshold register 3. */
    },
    [3] = {
      [1] = (rw_reg32_t)0x58026020U,   /** @brief ADC analog watchdog 1 threshold register. */
      [2] = (rw_reg32_t)0x580260B0U,   /** @brief ADC watchdog lower threshold register 2. */
      [3] = (rw_reg32_t)0x580260B8U,   /** @brief ADC watchdog lower threshold register 3. */
    },
  };

  static const rw_reg32_t ADCx_LHTR1[4] = {
    [1] = (rw_reg32_t)0x40022024U,   /** @brief ADC analog watchdog 2 threshold register. */
    [2] = (rw_reg32_t)0x40022124U,   /** @brief ADC analog watchdog 2 threshold register. */
    [3] = (rw_reg32_t)0x58026024U,   /** @brief ADC analog watchdog 2 threshold register. */
  };

  static const rw_reg32_t ADCx_SQRx[4][5] = {
    [1] = {
      [1] = (rw_reg32_t)0x40022030U,   /** @brief ADC group regular sequencer ranks register 1. */
      [2] = (rw_reg32_t)0x40022034U,   /** @brief ADC group regular sequencer ranks register 2. */
      [3] = (rw_reg32_t)0x40022038U,   /** @brief ADC group regular sequencer ranks register 3. */
      [4] = (rw_reg32_t)0x4002203CU,   /** @brief ADC group regular sequencer ranks register 4. */
    },
    [2] = {
      [1] = (rw_reg32_t)0x40022130U,   /** @brief ADC group regular sequencer ranks register 1. */
      [2] = (rw_reg32_t)0x40022134U,   /** @brief ADC group regular sequencer ranks register 2. */
      [3] = (rw_reg32_t)0x40022138U,   /** @brief ADC group regular sequencer ranks register 3. */
      [4] = (rw_reg32_t)0x4002213CU,   /** @brief ADC group regular sequencer ranks register 4. */
    },
    [3] = {
      [1] = (rw_reg32_t)0x58026030U,   /** @brief ADC group regular sequencer ranks register 1. */
      [2] = (rw_reg32_t)0x58026034U,   /** @brief ADC group regular sequencer ranks register 2. */
      [3] = (rw_reg32_t)0x58026038U,   /** @brief ADC group regular sequencer ranks register 3. */
      [4] = (rw_reg32_t)0x5802603CU,   /** @brief ADC group regular sequencer ranks register 4. */
    },
  };

  static const ro_reg32_t ADCx_DR[4] = {
    [1] = (ro_reg32_t)0x40022040U,   /** @brief ADC group regular conversion data register. */
    [2] = (ro_reg32_t)0x40022140U,   /** @brief ADC group regular conversion data register. */
    [3] = (ro_reg32_t)0x58026040U,   /** @brief ADC group regular conversion data register. */
  };

  static const rw_reg32_t ADCx_JSQR[4] = {
    [1] = (rw_reg32_t)0x4002204CU,   /** @brief ADC group injected sequencer register. */
    [2] = (rw_reg32_t)0x4002214CU,   /** @brief ADC group injected sequencer register. */
    [3] = (rw_reg32_t)0x5802604CU,   /** @brief ADC group injected sequencer register. */
  };

  static const rw_reg32_t ADCx_OFRx[4][5] = {
    [1] = {
      [1] = (rw_reg32_t)0x40022060U,   /** @brief ADC offset number 1 register. */
      [2] = (rw_reg32_t)0x40022064U,   /** @brief ADC offset number 2 register. */
      [3] = (rw_reg32_t)0x40022068U,   /** @brief ADC offset number 3 register. */
      [4] = (rw_reg32_t)0x4002206CU,   /** @brief ADC offset number 4 register. */
    },
    [2] = {
      [1] = (rw_reg32_t)0x40022160U,   /** @brief ADC offset number 1 register. */
      [2] = (rw_reg32_t)0x40022164U,   /** @brief ADC offset number 2 register. */
      [3] = (rw_reg32_t)0x40022168U,   /** @brief ADC offset number 3 register. */
      [4] = (rw_reg32_t)0x4002216CU,   /** @brief ADC offset number 4 register. */
    },
    [3] = {
      [1] = (rw_reg32_t)0x58026060U,   /** @brief ADC offset number 1 register. */
      [2] = (rw_reg32_t)0x58026064U,   /** @brief ADC offset number 2 register. */
      [3] = (rw_reg32_t)0x58026068U,   /** @brief ADC offset number 3 register. */
      [4] = (rw_reg32_t)0x5802606CU,   /** @brief ADC offset number 4 register. */
    },
  };

  static const ro_reg32_t ADCx_JDRx[4][5] = {
    [1] = {
      [1] = (ro_reg32_t)0x40022080U,   /** @brief ADC group injected sequencer rank 1 register. */
      [2] = (ro_reg32_t)0x40022084U,   /** @brief ADC group injected sequencer rank 2 register. */
      [3] = (ro_reg32_t)0x40022088U,   /** @brief ADC group injected sequencer rank 3 register. */
      [4] = (ro_reg32_t)0x4002208CU,   /** @brief ADC group injected sequencer rank 4 register. */
    },
    [2] = {
      [1] = (ro_reg32_t)0x40022180U,   /** @brief ADC group injected sequencer rank 1 register. */
      [2] = (ro_reg32_t)0x40022184U,   /** @brief ADC group injected sequencer rank 2 register. */
      [3] = (ro_reg32_t)0x40022188U,   /** @brief ADC group injected sequencer rank 3 register. */
      [4] = (ro_reg32_t)0x4002218CU,   /** @brief ADC group injected sequencer rank 4 register. */
    },
    [3] = {
      [1] = (ro_reg32_t)0x58026080U,   /** @brief ADC group injected sequencer rank 1 register. */
      [2] = (ro_reg32_t)0x58026084U,   /** @brief ADC group injected sequencer rank 2 register. */
      [3] = (ro_reg32_t)0x58026088U,   /** @brief ADC group injected sequencer rank 3 register. */
      [4] = (ro_reg32_t)0x5802608CU,   /** @brief ADC group injected sequencer rank 4 register. */
    },
  };

  static const rw_reg32_t ADCx_AWDxCR[4][4] = {
    [1] = {
      [2] = (rw_reg32_t)0x400220A0U,   /** @brief ADC analog watchdog 2 configuration register. */
      [3] = (rw_reg32_t)0x400220A4U,   /** @brief ADC analog watchdog 3 configuration register. */
    },
    [2] = {
      [2] = (rw_reg32_t)0x400221A0U,   /** @brief ADC analog watchdog 2 configuration register. */
      [3] = (rw_reg32_t)0x400221A4U,   /** @brief ADC analog watchdog 3 configuration register. */
    },
    [3] = {
      [2] = (rw_reg32_t)0x580260A0U,   /** @brief ADC analog watchdog 2 configuration register. */
      [3] = (rw_reg32_t)0x580260A4U,   /** @brief ADC analog watchdog 3 configuration register. */
    },
  };

  static const rw_reg32_t ADCx_DIFSEL[4] = {
    [1] = (rw_reg32_t)0x400220C0U,   /** @brief ADC channel differential or single-ended mode selection register. */
    [2] = (rw_reg32_t)0x400221C0U,   /** @brief ADC channel differential or single-ended mode selection register. */
    [3] = (rw_reg32_t)0x580260C0U,   /** @brief ADC channel differential or single-ended mode selection register. */
  };

  static const rw_reg32_t ADCx_CALFACT[4] = {
    [1] = (rw_reg32_t)0x400220C4U,   /** @brief ADC calibration factors register. */
    [2] = (rw_reg32_t)0x400221C4U,   /** @brief ADC calibration factors register. */
    [3] = (rw_reg32_t)0x580260C4U,   /** @brief ADC calibration factors register. */
  };

  static const rw_reg32_t ADCx_PCSEL[4] = {
    [1] = (rw_reg32_t)0x4002201CU,   /** @brief ADC pre channel selection register. */
    [2] = (rw_reg32_t)0x4002211CU,   /** @brief ADC pre channel selection register. */
    [3] = (rw_reg32_t)0x5802601CU,   /** @brief ADC pre channel selection register. */
  };

  static const rw_reg32_t ADCx_HTRx[4][4] = {
    [1] = {
      [2] = (rw_reg32_t)0x400220B4U,   /** @brief ADC watchdog higher threshold register 2. */
      [3] = (rw_reg32_t)0x400220BCU,   /** @brief ADC watchdog higher threshold register 3. */
    },
    [2] = {
      [2] = (rw_reg32_t)0x400221B4U,   /** @brief ADC watchdog higher threshold register 2. */
      [3] = (rw_reg32_t)0x400221BCU,   /** @brief ADC watchdog higher threshold register 3. */
    },
    [3] = {
      [2] = (rw_reg32_t)0x580260B4U,   /** @brief ADC watchdog higher threshold register 2. */
      [3] = (rw_reg32_t)0x580260BCU,   /** @brief ADC watchdog higher threshold register 3. */
    },
  };

  static const rw_reg32_t ADCx_CALFACT2[4] = {
    [1] = (rw_reg32_t)0x400220C8U,   /** @brief ADC calibration factor register 2. */
    [2] = (rw_reg32_t)0x400221C8U,   /** @brief ADC calibration factor register 2. */
    [3] = (rw_reg32_t)0x580260C8U,   /** @brief ADC calibration factor register 2. */
  };

  /**** ADCx Register Field Definitions ****/

  static const field32_t ADCx_ISR_JQOVF           = {.msk = 0x00000400U, .pos = 10};   /** @brief ADC group injected contexts queue overflow flag. */
  static const field32_t ADCx_ISR_JEOS            = {.msk = 0x00000040U, .pos = 6};    /** @brief ADC group injected end of sequence conversions flag. */
  static const field32_t ADCx_ISR_JEOC            = {.msk = 0x00000020U, .pos = 5};    /** @brief ADC group injected end of unitary conversion flag. */
  static const field32_t ADCx_ISR_OVR             = {.msk = 0x00000010U, .pos = 4};    /** @brief ADC group regular overrun flag. */
  static const field32_t ADCx_ISR_EOS             = {.msk = 0x00000008U, .pos = 3};    /** @brief ADC group regular end of sequence conversions flag. */
  static const field32_t ADCx_ISR_EOC             = {.msk = 0x00000004U, .pos = 2};    /** @brief ADC group regular end of unitary conversion flag. */
  static const field32_t ADCx_ISR_EOSMP           = {.msk = 0x00000002U, .pos = 1};    /** @brief ADC group regular end of sampling flag. */
  static const field32_t ADCx_ISR_ADRDY           = {.msk = 0x00000001U, .pos = 0};    /** @brief ADC ready flag. */
  static const field32_t ADCx_IER_JQOVFIE         = {.msk = 0x00000400U, .pos = 10};   /** @brief ADC group injected contexts queue overflow interrupt. */
  static const field32_t ADCx_IER_JEOSIE          = {.msk = 0x00000040U, .pos = 6};    /** @brief ADC group injected end of sequence conversions interrupt. */
  static const field32_t ADCx_IER_JEOCIE          = {.msk = 0x00000020U, .pos = 5};    /** @brief ADC group injected end of unitary conversion interrupt. */
  static const field32_t ADCx_IER_OVRIE           = {.msk = 0x00000010U, .pos = 4};    /** @brief ADC group regular overrun interrupt. */
  static const field32_t ADCx_IER_EOSIE           = {.msk = 0x00000008U, .pos = 3};    /** @brief ADC group regular end of sequence conversions interrupt. */
  static const field32_t ADCx_IER_EOCIE           = {.msk = 0x00000004U, .pos = 2};    /** @brief ADC group regular end of unitary conversion interrupt. */
  static const field32_t ADCx_IER_EOSMPIE         = {.msk = 0x00000002U, .pos = 1};    /** @brief ADC group regular end of sampling interrupt. */
  static const field32_t ADCx_IER_ADRDYIE         = {.msk = 0x00000001U, .pos = 0};    /** @brief ADC ready interrupt. */
  static const field32_t ADCx_CR_ADCAL            = {.msk = 0x80000000U, .pos = 31};   /** @brief ADC calibration. */
  static const field32_t ADCx_CR_ADCALDIF         = {.msk = 0x40000000U, .pos = 30};   /** @brief ADC differential mode for calibration. */
  static const field32_t ADCx_CR_DEEPPWD          = {.msk = 0x20000000U, .pos = 29};   /** @brief ADC deep power down enable. */
  static const field32_t ADCx_CR_ADVREGEN         = {.msk = 0x10000000U, .pos = 28};   /** @brief ADC voltage regulator enable. */
  static const field32_t ADCx_CR_ADCALLIN         = {.msk = 0x00010000U, .pos = 16};   /** @brief Linearity calibration. */
  static const field32_t ADCx_CR_BOOST            = {.msk = 0x00000300U, .pos = 8};    /** @brief Boost mode control. */
  static const field32_t ADCx_CR_JADSTP           = {.msk = 0x00000020U, .pos = 5};    /** @brief ADC group injected conversion stop. */
  static const field32_t ADCx_CR_ADSTP            = {.msk = 0x00000010U, .pos = 4};    /** @brief ADC group regular conversion stop. */
  static const field32_t ADCx_CR_JADSTART         = {.msk = 0x00000008U, .pos = 3};    /** @brief ADC group injected conversion start. */
  static const field32_t ADCx_CR_ADSTART          = {.msk = 0x00000004U, .pos = 2};    /** @brief ADC group regular conversion start. */
  static const field32_t ADCx_CR_ADDIS            = {.msk = 0x00000002U, .pos = 1};    /** @brief ADC disable. */
  static const field32_t ADCx_CR_ADEN             = {.msk = 0x00000001U, .pos = 0};    /** @brief ADC enable. */
  static const field32_t ADCx_CFGR_JQDIS          = {.msk = 0x80000000U, .pos = 31};   /** @brief ADC group injected contexts queue disable. */
  static const field32_t ADCx_CFGR_AWDCH1CH       = {.msk = 0x7C000000U, .pos = 26};   /** @brief ADC analog watchdog 1 monitored channel selection. */
  static const field32_t ADCx_CFGR_JAUTO          = {.msk = 0x02000000U, .pos = 25};   /** @brief ADC group injected automatic trigger mode. */
  static const field32_t ADCx_CFGR_JAWD1EN        = {.msk = 0x01000000U, .pos = 24};   /** @brief ADC analog watchdog 1 enable on scope ADC group injected. */
  static const field32_t ADCx_CFGR_AWD1EN         = {.msk = 0x00800000U, .pos = 23};   /** @brief ADC analog watchdog 1 enable on scope ADC group regular. */
  static const field32_t ADCx_CFGR_AWD1SGL        = {.msk = 0x00400000U, .pos = 22};   /** @brief ADC analog watchdog 1 monitoring a single channel or all channels. */
  static const field32_t ADCx_CFGR_JQM            = {.msk = 0x00200000U, .pos = 21};   /** @brief ADC group injected contexts queue mode. */
  static const field32_t ADCx_CFGR_JDISCEN        = {.msk = 0x00100000U, .pos = 20};   /** @brief ADC group injected sequencer discontinuous mode. */
  static const field32_t ADCx_CFGR_DISCNUM        = {.msk = 0x000E0000U, .pos = 17};   /** @brief ADC group regular sequencer discontinuous number of ranks. */
  static const field32_t ADCx_CFGR_DISCEN         = {.msk = 0x00010000U, .pos = 16};   /** @brief ADC group regular sequencer discontinuous mode. */
  static const field32_t ADCx_CFGR_AUTDLY         = {.msk = 0x00004000U, .pos = 14};   /** @brief ADC low power auto wait. */
  static const field32_t ADCx_CFGR_CONT           = {.msk = 0x00002000U, .pos = 13};   /** @brief ADC group regular continuous conversion mode. */
  static const field32_t ADCx_CFGR_OVRMOD         = {.msk = 0x00001000U, .pos = 12};   /** @brief ADC group regular overrun configuration. */
  static const field32_t ADCx_CFGR_EXTEN          = {.msk = 0x00000C00U, .pos = 10};   /** @brief ADC group regular external trigger polarity. */
  static const field32_t ADCx_CFGR_EXTSEL         = {.msk = 0x000003E0U, .pos = 5};    /** @brief ADC group regular external trigger source. */
  static const field32_t ADCx_CFGR_RES            = {.msk = 0x0000001CU, .pos = 2};    /** @brief ADC data resolution. */
  static const field32_t ADCx_CFGR_DMNGT          = {.msk = 0x00000003U, .pos = 0};    /** @brief ADC DMA transfer enable. */
  static const field32_t ADCx_CFGR2_ROVSE         = {.msk = 0x00000001U, .pos = 0};    /** @brief ADC oversampler enable on scope ADC group regular. */
  static const field32_t ADCx_CFGR2_JOVSE         = {.msk = 0x00000002U, .pos = 1};    /** @brief ADC oversampler enable on scope ADC group injected. */
  static const field32_t ADCx_CFGR2_OVSS          = {.msk = 0x000001E0U, .pos = 5};    /** @brief ADC oversampling shift. */
  static const field32_t ADCx_CFGR2_TROVS         = {.msk = 0x00000200U, .pos = 9};    /** @brief ADC oversampling discontinuous mode (triggered mode) for ADC group regular. */
  static const field32_t ADCx_CFGR2_ROVSM         = {.msk = 0x00000400U, .pos = 10};   /** @brief Regular oversampling mode. */
  static const field32_t ADCx_CFGR2_OSR           = {.msk = 0x03FF0000U, .pos = 16};   /** @brief Oversampling ratio. */
  static const field32_t ADCx_CFGR2_LSHIFT        = {.msk = 0xF0000000U, .pos = 28};   /** @brief Left shift factor. */
  static const field32_t ADCx_LTRx_LTR1           = {.msk = 0x03FFFFFFU, .pos = 0};    /** @brief ADC analog watchdog 1 threshold low. */
  static const field32_t ADCx_LHTR1_LHTR1         = {.msk = 0x03FFFFFFU, .pos = 0};    /** @brief ADC analog watchdog 2 threshold low. */
  static const field32_t ADCx_SQRx_L3             = {.msk = 0x0000000FU, .pos = 0};    /** @brief L3. */
  static const field32_t ADCx_DR_RDATA            = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief ADC group regular conversion data. */
  static const field32_t ADCx_JSQR_JEXTEN         = {.msk = 0x00000180U, .pos = 7};    /** @brief ADC group injected external trigger polarity. */
  static const field32_t ADCx_JSQR_JEXTSEL        = {.msk = 0x0000007CU, .pos = 2};    /** @brief ADC group injected external trigger source. */
  static const field32_t ADCx_JSQR_JL             = {.msk = 0x00000003U, .pos = 0};    /** @brief ADC group injected sequencer scan length. */
  static const field32_t ADCx_OFRx_SSATE          = {.msk = 0x80000000U, .pos = 31};   /** @brief ADC offset number 1 enable. */
  static const field32_t ADCx_OFRx_OFFSET1_CH     = {.msk = 0x7C000000U, .pos = 26};   /** @brief ADC offset number 1 channel selection. */
  static const field32_t ADCx_OFRx_OFFSET1        = {.msk = 0x03FFFFFFU, .pos = 0};    /** @brief ADC offset number 1 offset level. */
  static const field32_t ADCx_AWDxCR_AWD2CH       = {.msk = 0x000FFFFFU, .pos = 0};    /** @brief ADC analog watchdog 2 monitored channel selection. */
  static const field32_t ADCx_DIFSEL_DIFSEL       = {.msk = 0x000FFFFFU, .pos = 0};    /** @brief ADC channel differential or single-ended mode for channel. */
  static const field32_t ADCx_CALFACT_CALFACT_D   = {.msk = 0x07FF0000U, .pos = 16};   /** @brief ADC calibration factor in differential mode. */
  static const field32_t ADCx_CALFACT_CALFACT_S   = {.msk = 0x000007FFU, .pos = 0};    /** @brief ADC calibration factor in single-ended mode. */
  static const field32_t ADCx_PCSEL_PCSEL         = {.msk = 0x000FFFFFU, .pos = 0};    /** @brief Channel x (vinp[i]) pre selection. */
  static const field32_t ADCx_HTRx_HTR2           = {.msk = 0x03FFFFFFU, .pos = 0};    /** @brief Analog watchdog 2 higher threshold. */
  static const field32_t ADCx_CALFACT2_LINCALFACT = {.msk = 0x3FFFFFFFU, .pos = 0};    /** @brief Linearity calibration factor. */

  /**** Enumerated ADCx Register Field Definitions ****/

  static field32_t const ADCx_ISR_AWDx[4] = {
    [1] = {.msk = 0x00000080U, .pos = 7},   /** @brief ADC analog watchdog 1 flag. */
    [2] = {.msk = 0x00000100U, .pos = 8},   /** @brief ADC analog watchdog 2 flag. */
    [3] = {.msk = 0x00000200U, .pos = 9},   /** @brief ADC analog watchdog 3 flag. */
  };

  static field32_t const ADCx_IER_AWDxIE[4] = {
    [1] = {.msk = 0x00000080U, .pos = 7},   /** @brief ADC analog watchdog 1 interrupt. */
    [2] = {.msk = 0x00000100U, .pos = 8},   /** @brief ADC analog watchdog 2 interrupt. */
    [3] = {.msk = 0x00000200U, .pos = 9},   /** @brief ADC analog watchdog 3 interrupt. */
  };

  static field32_t const ADCx_CR_LINCALRDYWx[7] = {
    [1] = {.msk = 0x00400000U, .pos = 22},   /** @brief Linearity calibration ready word 1. */
    [2] = {.msk = 0x00800000U, .pos = 23},   /** @brief Linearity calibration ready word 2. */
    [3] = {.msk = 0x01000000U, .pos = 24},   /** @brief Linearity calibration ready word 3. */
    [4] = {.msk = 0x02000000U, .pos = 25},   /** @brief Linearity calibration ready word 4. */
    [5] = {.msk = 0x04000000U, .pos = 26},   /** @brief Linearity calibration ready word 5. */
    [6] = {.msk = 0x08000000U, .pos = 27},   /** @brief Linearity calibration ready word 6. */
  };

  static field32_t const ADCx_CFGR2_RSHIFTx[5] = {
    [1] = {.msk = 0x00000800U, .pos = 11},   /** @brief Right-shift data after offset 1 correction. */
    [2] = {.msk = 0x00001000U, .pos = 12},   /** @brief Right-shift data after offset 2 correction. */
    [3] = {.msk = 0x00002000U, .pos = 13},   /** @brief Right-shift data after offset 3 correction. */
    [4] = {.msk = 0x00004000U, .pos = 14},   /** @brief Right-shift data after offset 4 correction. */
  };

  static field32_t const ADCx_SMPRx_SMPx[10] = {
    [1]  = {.msk = 0x00000038U, .pos = 3},    /** @brief ADC channel 1 sampling time selection. */
    [2]  = {.msk = 0x000001C0U, .pos = 6},    /** @brief ADC channel 2 sampling time selection. */
    [3]  = {.msk = 0x00000E00U, .pos = 9},    /** @brief ADC channel 3 sampling time selection. */
    [4]  = {.msk = 0x00007000U, .pos = 12},   /** @brief ADC channel 4 sampling time selection. */
    [5]  = {.msk = 0x00038000U, .pos = 15},   /** @brief ADC channel 5 sampling time selection. */
    [6]  = {.msk = 0x001C0000U, .pos = 18},   /** @brief ADC channel 6 sampling time selection. */
    [7]  = {.msk = 0x00E00000U, .pos = 21},   /** @brief ADC channel 7 sampling time selection. */
    [8]  = {.msk = 0x07000000U, .pos = 24},   /** @brief ADC channel 8 sampling time selection. */
    [9]  = {.msk = 0x38000000U, .pos = 27},   /** @brief ADC channel 9 sampling time selection. */
  };

  static field32_t const ADCx_SQRx_SQx[5] = {
    [1] = {.msk = 0x000007C0U, .pos = 6},    /** @brief ADC group regular sequencer rank 1. */
    [2] = {.msk = 0x0001F000U, .pos = 12},   /** @brief ADC group regular sequencer rank 2. */
    [3] = {.msk = 0x007C0000U, .pos = 18},   /** @brief ADC group regular sequencer rank 3. */
    [4] = {.msk = 0x1F000000U, .pos = 24},   /** @brief ADC group regular sequencer rank 4. */
  };

  static field32_t const ADCx_JSQR_JSQx[5] = {
    [1] = {.msk = 0x00003E00U, .pos = 9},    /** @brief ADC group injected sequencer rank 1. */
    [2] = {.msk = 0x000F8000U, .pos = 15},   /** @brief ADC group injected sequencer rank 2. */
    [3] = {.msk = 0x03E00000U, .pos = 21},   /** @brief ADC group injected sequencer rank 3. */
    [4] = {.msk = 0xF8000000U, .pos = 27},   /** @brief ADC group injected sequencer rank 4. */
  };

  /************************************************************************************************
   * ADCx_COMMON Definitions
   ************************************************************************************************/

  /**** Enumerated ADCx_COMMON Register Definitions ****/

  static const ro_reg32_t ADCx_COMMON_CSR[13] = {
    [3]  = (ro_reg32_t)0x58026300U,   /** @brief ADC common status register. */
    [12] = (ro_reg32_t)0x40022300U,   /** @brief ADC common status register. */
  };

  static const rw_reg32_t ADCx_COMMON_CCR[13] = {
    [3]  = (rw_reg32_t)0x58026308U,   /** @brief ADC common control register. */
    [12] = (rw_reg32_t)0x40022308U,   /** @brief ADC common control register. */
  };

  static const ro_reg32_t ADCx_COMMON_CDR[13] = {
    [3]  = (ro_reg32_t)0x5802630CU,   /** @brief ADC common regular data register for dual and triple modes. */
    [12] = (ro_reg32_t)0x4002230CU,   /** @brief ADC common regular data register for dual and triple modes. */
  };

  static const ro_reg32_t ADCx_COMMON_CDR2[13] = {
    [3]  = (ro_reg32_t)0x58026310U,   /** @brief ADC x common regular data register for 32-bit dual mode. */
    [12] = (ro_reg32_t)0x40022310U,   /** @brief ADC x common regular data register for 32-bit dual mode. */
  };

  /**** ADCx_COMMON Register Field Definitions ****/

  static const field32_t ADCx_COMMON_CSR_ADRDY_MST = {.msk = 0x00000001U, .pos = 0};    /** @brief Master ADC ready. */
  static const field32_t ADCx_COMMON_CSR_EOSMP_MST = {.msk = 0x00000002U, .pos = 1};    /** @brief End of sampling phase flag of the master ADC. */
  static const field32_t ADCx_COMMON_CSR_EOC_MST   = {.msk = 0x00000004U, .pos = 2};    /** @brief End of regular conversion of the master ADC. */
  static const field32_t ADCx_COMMON_CSR_EOS_MST   = {.msk = 0x00000008U, .pos = 3};    /** @brief End of regular sequence flag of the master ADC. */
  static const field32_t ADCx_COMMON_CSR_OVR_MST   = {.msk = 0x00000010U, .pos = 4};    /** @brief Overrun flag of the master ADC. */
  static const field32_t ADCx_COMMON_CSR_JEOC_MST  = {.msk = 0x00000020U, .pos = 5};    /** @brief End of injected conversion flag of the master ADC. */
  static const field32_t ADCx_COMMON_CSR_JEOS_MST  = {.msk = 0x00000040U, .pos = 6};    /** @brief End of injected sequence flag of the master ADC. */
  static const field32_t ADCx_COMMON_CSR_JQOVF_MST = {.msk = 0x00000400U, .pos = 10};   /** @brief Injected context queue overflow flag of the master ADC. */
  static const field32_t ADCx_COMMON_CSR_ADRDY_SLV = {.msk = 0x00010000U, .pos = 16};   /** @brief Slave ADC ready. */
  static const field32_t ADCx_COMMON_CSR_EOSMP_SLV = {.msk = 0x00020000U, .pos = 17};   /** @brief End of sampling phase flag of the slave ADC. */
  static const field32_t ADCx_COMMON_CSR_EOC_SLV   = {.msk = 0x00040000U, .pos = 18};   /** @brief End of regular conversion of the slave ADC. */
  static const field32_t ADCx_COMMON_CSR_EOS_SLV   = {.msk = 0x00080000U, .pos = 19};   /** @brief End of regular sequence flag of the slave ADC. */
  static const field32_t ADCx_COMMON_CSR_OVR_SLV   = {.msk = 0x00100000U, .pos = 20};   /** @brief Overrun flag of the slave ADC. */
  static const field32_t ADCx_COMMON_CSR_JEOC_SLV  = {.msk = 0x00200000U, .pos = 21};   /** @brief End of injected conversion flag of the slave ADC. */
  static const field32_t ADCx_COMMON_CSR_JEOS_SLV  = {.msk = 0x00400000U, .pos = 22};   /** @brief End of injected sequence flag of the slave ADC. */
  static const field32_t ADCx_COMMON_CSR_JQOVF_SLV = {.msk = 0x04000000U, .pos = 26};   /** @brief Injected context queue overflow flag of the slave ADC. */
  static const field32_t ADCx_COMMON_CCR_DUAL      = {.msk = 0x0000001FU, .pos = 0};    /** @brief Dual ADC mode selection. */
  static const field32_t ADCx_COMMON_CCR_DELAY     = {.msk = 0x00000F00U, .pos = 8};    /** @brief Delay between 2 sampling phases. */
  static const field32_t ADCx_COMMON_CCR_DAMDF     = {.msk = 0x0000C000U, .pos = 14};   /** @brief Dual ADC mode data format. */
  static const field32_t ADCx_COMMON_CCR_CKMODE    = {.msk = 0x00030000U, .pos = 16};   /** @brief ADC clock mode. */
  static const field32_t ADCx_COMMON_CCR_PRESC     = {.msk = 0x003C0000U, .pos = 18};   /** @brief ADC prescaler. */
  static const field32_t ADCx_COMMON_CCR_VREFEN    = {.msk = 0x00400000U, .pos = 22};   /** @brief VREFINT enable. */
  static const field32_t ADCx_COMMON_CCR_TSEN      = {.msk = 0x00800000U, .pos = 23};   /** @brief Temperature sensor enable. */
  static const field32_t ADCx_COMMON_CCR_VBATEN    = {.msk = 0x01000000U, .pos = 24};   /** @brief VBAT enable. */
  static const field32_t ADCx_COMMON_CDR_RDATA_SLV = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief Regular data of the slave ADC. */
  static const field32_t ADCx_COMMON_CDR_RDATA_MST = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Regular data of the master ADC. */

  /**** Enumerated ADCx_COMMON Register Field Definitions ****/

  static field32_t const ADCx_COMMON_CSR_AWDx_MST[4] = {
    [1] = {.msk = 0x00000080U, .pos = 7},   /** @brief Analog watchdog 1 flag of the master ADC. */
    [2] = {.msk = 0x00000100U, .pos = 8},   /** @brief Analog watchdog 2 flag of the master ADC. */
    [3] = {.msk = 0x00000200U, .pos = 9},   /** @brief Analog watchdog 3 flag of the master ADC. */
  };

  static field32_t const ADCx_COMMON_CSR_AWDx_SLV[4] = {
    [1] = {.msk = 0x00800000U, .pos = 23},   /** @brief Analog watchdog 1 flag of the slave ADC. */
    [2] = {.msk = 0x01000000U, .pos = 24},   /** @brief Analog watchdog 2 flag of the slave ADC. */
    [3] = {.msk = 0x02000000U, .pos = 25},   /** @brief Analog watchdog 3 flag of the slave ADC. */
  };

  /************************************************************************************************
   * CRC Definitions
   ************************************************************************************************/

  /**** CRC Register Definitions ****/

  static const rw_reg32_t CRC_DR   = (rw_reg32_t)0x58024C00U;   /** @brief Data register. */
  static const rw_reg32_t CRC_IDR  = (rw_reg32_t)0x58024C04U;   /** @brief Independent data register. */
  static const rw_reg32_t CRC_CR   = (rw_reg32_t)0x58024C08U;   /** @brief Control register. */
  static const rw_reg32_t CRC_INIT = (rw_reg32_t)0x58024C0CU;   /** @brief Initial CRC value. */
  static const rw_reg32_t CRC_POL  = (rw_reg32_t)0x58024C10U;   /** @brief CRC polynomial. */

  /**** CRC Register Field Definitions ****/

  static const field32_t CRC_CR_RESET    = {.msk = 0x00000001U, .pos = 0};   /** @brief RESET bit. */
  static const field32_t CRC_CR_POLYSIZE = {.msk = 0x00000018U, .pos = 3};   /** @brief Polynomial size. */
  static const field32_t CRC_CR_REV_IN   = {.msk = 0x00000060U, .pos = 5};   /** @brief Reverse input data. */
  static const field32_t CRC_CR_REV_OUT  = {.msk = 0x00000080U, .pos = 7};   /** @brief Reverse output data. */

  /************************************************************************************************
   * RCC Definitions
   ************************************************************************************************/

  /**** RCC Register Definitions ****/

  static const rw_reg32_t RCC_CR            = (rw_reg32_t)0x58024400U;   /** @brief Clock control register. */
  static const rw_reg32_t RCC_ICSCR         = (rw_reg32_t)0x58024404U;   /** @brief RCC internal clock source calibration register. */
  static const ro_reg32_t RCC_CRRCR         = (ro_reg32_t)0x58024408U;   /** @brief RCC clock recovery RC register. */
  static const rw_reg32_t RCC_CFGR          = (rw_reg32_t)0x58024410U;   /** @brief RCC clock configuration register. */
  static const rw_reg32_t RCC_PLLCKSELR     = (rw_reg32_t)0x58024428U;   /** @brief RCC plls clock source selection register. */
  static const rw_reg32_t RCC_PLLCFGR       = (rw_reg32_t)0x5802442CU;   /** @brief RCC plls configuration register. */
  static const rw_reg32_t RCC_CIER          = (rw_reg32_t)0x58024460U;   /** @brief RCC clock source interrupt enable register. */
  static const rw_reg32_t RCC_CIFR          = (rw_reg32_t)0x58024464U;   /** @brief RCC clock source interrupt flag register. */
  static const rw_reg32_t RCC_CICR          = (rw_reg32_t)0x58024468U;   /** @brief RCC clock source interrupt clear register. */
  static const rw_reg32_t RCC_BDCR          = (rw_reg32_t)0x58024470U;   /** @brief RCC backup domain control register. */
  static const rw_reg32_t RCC_CSR           = (rw_reg32_t)0x58024474U;   /** @brief RCC clock control and status register. */
  static const rw_reg32_t RCC_APB1LRSTR     = (rw_reg32_t)0x58024490U;   /** @brief RCC APB1 peripheral reset register. */
  static const rw_reg32_t RCC_APB1HRSTR     = (rw_reg32_t)0x58024494U;   /** @brief RCC APB1 peripheral reset register. */
  static const rw_reg32_t RCC_GCR           = (rw_reg32_t)0x580244A0U;   /** @brief RCC global control register. */
  static const rw_reg32_t RCC_D3AMR         = (rw_reg32_t)0x580244A8U;   /** @brief RCC D3 autonomous mode register. */
  static const rw_reg32_t RCC_RSR           = (rw_reg32_t)0x580244D0U;   /** @brief RCC reset status register. */
  static const rw_reg32_t RCC_C1_RSR        = (rw_reg32_t)0x58024530U;   /** @brief RCC reset status register. */
  static const rw_reg32_t RCC_APB1LENR      = (rw_reg32_t)0x580244E8U;   /** @brief RCC APB1 clock register. */
  static const rw_reg32_t RCC_C1_APB1LENR   = (rw_reg32_t)0x58024548U;   /** @brief RCC APB1 clock register. */
  static const rw_reg32_t RCC_APB1HENR      = (rw_reg32_t)0x580244ECU;   /** @brief RCC APB1 clock register. */
  static const rw_reg32_t RCC_C1_APB1HENR   = (rw_reg32_t)0x5802454CU;   /** @brief RCC APB1 clock register. */
  static const rw_reg32_t RCC_APB1LLPENR    = (rw_reg32_t)0x58024510U;   /** @brief RCC APB1 low sleep clock register. */
  static const rw_reg32_t RCC_C1_APB1LLPENR = (rw_reg32_t)0x58024570U;   /** @brief RCC APB1 low sleep clock register. */
  static const rw_reg32_t RCC_C1_APB1HLPENR = (rw_reg32_t)0x58024574U;   /** @brief RCC APB1 high sleep clock register. */
  static const rw_reg32_t RCC_APB1HLPENR    = (rw_reg32_t)0x58024514U;   /** @brief RCC APB1 high sleep clock register. */

  /**** Enumerated RCC Register Definitions ****/

  static const rw_reg32_t RCC_DxCFGR[4] = {
    [1] = (rw_reg32_t)0x58024418U,   /** @brief RCC domain 1 clock configuration register. */
    [2] = (rw_reg32_t)0x5802441CU,   /** @brief RCC domain 2 clock configuration register. */
    [3] = (rw_reg32_t)0x58024420U,   /** @brief RCC domain 3 clock configuration register. */
  };

  static const rw_reg32_t RCC_PLLxDIVR[4] = {
    [1] = (rw_reg32_t)0x58024430U,   /** @brief RCC PLL1 dividers configuration register. */
    [2] = (rw_reg32_t)0x58024438U,   /** @brief RCC PLL2 dividers configuration register. */
    [3] = (rw_reg32_t)0x58024440U,   /** @brief RCC PLL3 dividers configuration register. */
  };

  static const rw_reg32_t RCC_PLLxFRACR[4] = {
    [1] = (rw_reg32_t)0x58024434U,   /** @brief RCC PLL1 fractional divider register. */
    [2] = (rw_reg32_t)0x5802443CU,   /** @brief RCC PLL2 fractional divider register. */
    [3] = (rw_reg32_t)0x58024444U,   /** @brief RCC PLL3 fractional divider register. */
  };

  static const rw_reg32_t RCC_DxCCIPR[4] = {
    [1] = (rw_reg32_t)0x5802444CU,   /** @brief RCC domain 1 kernel clock configuration register. */
    [3] = (rw_reg32_t)0x58024458U,   /** @brief RCC domain 3 kernel clock configuration register. */
  };

  static const rw_reg32_t RCC_D2CCIPxR[3] = {
    [1] = (rw_reg32_t)0x58024450U,   /** @brief RCC domain 2 kernel clock configuration register. */
    [2] = (rw_reg32_t)0x58024454U,   /** @brief RCC domain 2 kernel clock configuration register. */
  };

  static const rw_reg32_t RCC_AHBxRSTR[5] = {
    [1] = (rw_reg32_t)0x58024480U,   /** @brief RCC AHB1 peripheral reset register. */
    [2] = (rw_reg32_t)0x58024484U,   /** @brief RCC AHB2 peripheral reset register. */
    [3] = (rw_reg32_t)0x5802447CU,   /** @brief RCC AHB3 reset register. */
    [4] = (rw_reg32_t)0x58024488U,   /** @brief RCC AHB4 peripheral reset register. */
  };

  static const rw_reg32_t RCC_APBxRSTR[5] = {
    [2] = (rw_reg32_t)0x58024498U,   /** @brief RCC APB2 peripheral reset register. */
    [3] = (rw_reg32_t)0x5802448CU,   /** @brief RCC APB3 peripheral reset register. */
    [4] = (rw_reg32_t)0x5802449CU,   /** @brief RCC APB4 peripheral reset register. */
  };

  static const rw_reg32_t RCC_C1_AHBxENR[5] = {
    [1] = (rw_reg32_t)0x58024538U,   /** @brief RCC AHB1 clock register. */
    [2] = (rw_reg32_t)0x5802453CU,   /** @brief RCC AHB2 clock register. */
    [3] = (rw_reg32_t)0x58024534U,   /** @brief RCC AHB3 clock register. */
    [4] = (rw_reg32_t)0x58024540U,   /** @brief RCC AHB4 clock register. */
  };

  static const rw_reg32_t RCC_AHBxENR[5] = {
    [1] = (rw_reg32_t)0x580244D8U,   /** @brief RCC AHB1 clock register. */
    [2] = (rw_reg32_t)0x580244DCU,   /** @brief RCC AHB2 clock register. */
    [3] = (rw_reg32_t)0x580244D4U,   /** @brief RCC AHB3 clock register. */
    [4] = (rw_reg32_t)0x580244E0U,   /** @brief RCC AHB4 clock register. */
  };

  static const rw_reg32_t RCC_C1_APBxENR[5] = {
    [2] = (rw_reg32_t)0x58024550U,   /** @brief RCC APB2 clock register. */
    [3] = (rw_reg32_t)0x58024544U,   /** @brief RCC APB3 clock register. */
    [4] = (rw_reg32_t)0x58024554U,   /** @brief RCC APB4 clock register. */
  };

  static const rw_reg32_t RCC_APBxENR[5] = {
    [2] = (rw_reg32_t)0x580244F0U,   /** @brief RCC APB2 clock register. */
    [3] = (rw_reg32_t)0x580244E4U,   /** @brief RCC APB3 clock register. */
    [4] = (rw_reg32_t)0x580244F4U,   /** @brief RCC APB4 clock register. */
  };

  static const rw_reg32_t RCC_C1_AHBxLPENR[5] = {
    [1] = (rw_reg32_t)0x58024560U,   /** @brief RCC AHB1 sleep clock register. */
    [2] = (rw_reg32_t)0x58024564U,   /** @brief RCC AHB2 sleep clock register. */
    [3] = (rw_reg32_t)0x5802455CU,   /** @brief RCC AHB3 sleep clock register. */
    [4] = (rw_reg32_t)0x58024568U,   /** @brief RCC AHB4 sleep clock register. */
  };

  static const rw_reg32_t RCC_AHBxLPENR[5] = {
    [1] = (rw_reg32_t)0x58024500U,   /** @brief RCC AHB1 sleep clock register. */
    [2] = (rw_reg32_t)0x58024504U,   /** @brief RCC AHB2 sleep clock register. */
    [3] = (rw_reg32_t)0x580244FCU,   /** @brief RCC AHB3 sleep clock register. */
    [4] = (rw_reg32_t)0x58024508U,   /** @brief RCC AHB4 sleep clock register. */
  };

  static const rw_reg32_t RCC_C1_APBxLPENR[5] = {
    [2] = (rw_reg32_t)0x58024578U,   /** @brief RCC APB2 sleep clock register. */
    [3] = (rw_reg32_t)0x5802456CU,   /** @brief RCC APB3 sleep clock register. */
    [4] = (rw_reg32_t)0x5802457CU,   /** @brief RCC APB4 sleep clock register. */
  };

  static const rw_reg32_t RCC_APBxLPENR[5] = {
    [2] = (rw_reg32_t)0x58024518U,   /** @brief RCC APB2 sleep clock register. */
    [3] = (rw_reg32_t)0x5802450CU,   /** @brief RCC APB3 sleep clock register. */
    [4] = (rw_reg32_t)0x5802451CU,   /** @brief RCC APB4 sleep clock register. */
  };

  /**** RCC Register Field Definitions ****/

  static const field32_t RCC_CR_HSION                       = {.msk = 0x00000001U, .pos = 0};    /** @brief Internal high-speed clock enable. */
  static const field32_t RCC_CR_HSIKERON                    = {.msk = 0x00000002U, .pos = 1};    /** @brief High speed internal clock enable in stop mode. */
  static const field32_t RCC_CR_HSIRDY                      = {.msk = 0x00000004U, .pos = 2};    /** @brief HSI clock ready flag. */
  static const field32_t RCC_CR_HSIDIV                      = {.msk = 0x00000018U, .pos = 3};    /** @brief HSI clock divider. */
  static const field32_t RCC_CR_HSIDIVF                     = {.msk = 0x00000020U, .pos = 5};    /** @brief HSI divider flag. */
  static const field32_t RCC_CR_CSION                       = {.msk = 0x00000080U, .pos = 7};    /** @brief CSI clock enable. */
  static const field32_t RCC_CR_CSIRDY                      = {.msk = 0x00000100U, .pos = 8};    /** @brief CSI clock ready flag. */
  static const field32_t RCC_CR_CSIKERON                    = {.msk = 0x00000200U, .pos = 9};    /** @brief CSI clock enable in stop mode. */
  static const field32_t RCC_CR_RC48ON                      = {.msk = 0x00001000U, .pos = 12};   /** @brief RC48 clock enable. */
  static const field32_t RCC_CR_RC48RDY                     = {.msk = 0x00002000U, .pos = 13};   /** @brief RC48 clock ready flag. */
  static const field32_t RCC_CR_HSEON                       = {.msk = 0x00010000U, .pos = 16};   /** @brief HSE clock enable. */
  static const field32_t RCC_CR_HSERDY                      = {.msk = 0x00020000U, .pos = 17};   /** @brief HSE clock ready flag. */
  static const field32_t RCC_CR_HSEBYP                      = {.msk = 0x00040000U, .pos = 18};   /** @brief HSE clock bypass. */
  static const field32_t RCC_CR_HSECSSON                    = {.msk = 0x00080000U, .pos = 19};   /** @brief HSE clock security system enable. */
  static const field32_t RCC_ICSCR_HSICAL                   = {.msk = 0x00000FFFU, .pos = 0};    /** @brief HSI clock calibration. */
  static const field32_t RCC_ICSCR_HSITRIM                  = {.msk = 0x0003F000U, .pos = 12};   /** @brief HSI clock trimming. */
  static const field32_t RCC_ICSCR_CSICAL                   = {.msk = 0x03FC0000U, .pos = 18};   /** @brief CSI clock calibration. */
  static const field32_t RCC_ICSCR_CSITRIM                  = {.msk = 0x7C000000U, .pos = 26};   /** @brief CSI clock trimming. */
  static const field32_t RCC_CRRCR_RC48CAL                  = {.msk = 0x000003FFU, .pos = 0};    /** @brief Internal RC 48 mhz clock calibration. */
  static const field32_t RCC_CFGR_SW                        = {.msk = 0x00000007U, .pos = 0};    /** @brief System clock switch. */
  static const field32_t RCC_CFGR_SWS                       = {.msk = 0x00000038U, .pos = 3};    /** @brief System clock switch status. */
  static const field32_t RCC_CFGR_STOPWUCK                  = {.msk = 0x00000040U, .pos = 6};    /** @brief System clock selection after a wake up from system stop. */
  static const field32_t RCC_CFGR_STOPKERWUCK               = {.msk = 0x00000080U, .pos = 7};    /** @brief Kernel clock selection after a wake up from system stop. */
  static const field32_t RCC_CFGR_RTCPRE                    = {.msk = 0x00003F00U, .pos = 8};    /** @brief HSE division factor for RTC clock. */
  static const field32_t RCC_CFGR_HRTIMSEL                  = {.msk = 0x00004000U, .pos = 14};   /** @brief High resolution timer clock prescaler selection. */
  static const field32_t RCC_CFGR_TIMPRE                    = {.msk = 0x00008000U, .pos = 15};   /** @brief Timers clocks prescaler selection. */
  static const field32_t RCC_DxCFGR_HPRE                    = {.msk = 0x0000000FU, .pos = 0};    /** @brief D1 domain AHB prescaler. */
  static const field32_t RCC_DxCFGR_D1PPRE                  = {.msk = 0x00000070U, .pos = 4};    /** @brief D1 domain APB3 prescaler. */
  static const field32_t RCC_DxCFGR_D1CPRE                  = {.msk = 0x00000F00U, .pos = 8};    /** @brief D1 domain core prescaler. */
  static const field32_t RCC_PLLCKSELR_PLLSRC               = {.msk = 0x00000003U, .pos = 0};    /** @brief DIVMx and plls clock source selection. */
  static const field32_t RCC_PLLxDIVR_DIVN1                 = {.msk = 0x000001FFU, .pos = 0};    /** @brief Multiplication factor for PLL1 VCO. */
  static const field32_t RCC_PLLxDIVR_DIVP1                 = {.msk = 0x0000FE00U, .pos = 9};    /** @brief PLL1 DIVP division factor. */
  static const field32_t RCC_PLLxDIVR_DIVQ1                 = {.msk = 0x007F0000U, .pos = 16};   /** @brief PLL1 DIVQ division factor. */
  static const field32_t RCC_PLLxDIVR_DIVR1                 = {.msk = 0x7F000000U, .pos = 24};   /** @brief PLL1 DIVR division factor. */
  static const field32_t RCC_PLLxFRACR_FRACN1               = {.msk = 0x0000FFF8U, .pos = 3};    /** @brief Fractional part of the multiplication factor for PLL1 VCO. */
  static const field32_t RCC_DxCCIPR_FMCSRC                 = {.msk = 0x00000003U, .pos = 0};    /** @brief FMC kernel clock source selection. */
  static const field32_t RCC_DxCCIPR_QSPISRC                = {.msk = 0x00000030U, .pos = 4};    /** @brief QUADSPI kernel clock source selection. */
  static const field32_t RCC_DxCCIPR_SDMMCSRC               = {.msk = 0x00010000U, .pos = 16};   /** @brief SDMMC kernel clock source selection. */
  static const field32_t RCC_DxCCIPR_CKPERSRC               = {.msk = 0x30000000U, .pos = 28};   /** @brief Per_ck clock source selection. */
  static const field32_t RCC_D2CCIPxR_SAI1SRC               = {.msk = 0x00000007U, .pos = 0};    /** @brief SAI1 and DFSDM1 kernel aclk clock source selection. */
  static const field32_t RCC_D2CCIPxR_SAI23SRC              = {.msk = 0x000001C0U, .pos = 6};    /** @brief SAI2 and SAI3 kernel clock source selection. */
  static const field32_t RCC_D2CCIPxR_SPI123SRC             = {.msk = 0x00007000U, .pos = 12};   /** @brief SPI/I2S1,2 and 3 kernel clock source selection. */
  static const field32_t RCC_D2CCIPxR_SPI45SRC              = {.msk = 0x00070000U, .pos = 16};   /** @brief SPI4 and 5 kernel clock source selection. */
  static const field32_t RCC_D2CCIPxR_SPDIFSRC              = {.msk = 0x00300000U, .pos = 20};   /** @brief SPDIFRX kernel clock source selection. */
  static const field32_t RCC_D2CCIPxR_DFSDM1SRC             = {.msk = 0x01000000U, .pos = 24};   /** @brief DFSDM1 kernel clk clock source selection. */
  static const field32_t RCC_D2CCIPxR_FDCANSRC              = {.msk = 0x30000000U, .pos = 28};   /** @brief FDCAN kernel clock source selection. */
  static const field32_t RCC_D2CCIPxR_SWPSRC                = {.msk = 0x80000000U, .pos = 31};   /** @brief SWPMI kernel clock source selection. */
  static const field32_t RCC_CIER_LSIRDYIE                  = {.msk = 0x00000001U, .pos = 0};    /** @brief LSI ready interrupt enable. */
  static const field32_t RCC_CIER_LSERDYIE                  = {.msk = 0x00000002U, .pos = 1};    /** @brief LSE ready interrupt enable. */
  static const field32_t RCC_CIER_HSIRDYIE                  = {.msk = 0x00000004U, .pos = 2};    /** @brief HSI ready interrupt enable. */
  static const field32_t RCC_CIER_HSERDYIE                  = {.msk = 0x00000008U, .pos = 3};    /** @brief HSE ready interrupt enable. */
  static const field32_t RCC_CIER_CSIRDYIE                  = {.msk = 0x00000010U, .pos = 4};    /** @brief CSI ready interrupt enable. */
  static const field32_t RCC_CIER_RC48RDYIE                 = {.msk = 0x00000020U, .pos = 5};    /** @brief RC48 ready interrupt enable. */
  static const field32_t RCC_CIER_LSECSSIE                  = {.msk = 0x00000200U, .pos = 9};    /** @brief LSE clock security system interrupt enable. */
  static const field32_t RCC_CIFR_LSIRDYF                   = {.msk = 0x00000001U, .pos = 0};    /** @brief LSI ready interrupt flag. */
  static const field32_t RCC_CIFR_LSERDYF                   = {.msk = 0x00000002U, .pos = 1};    /** @brief LSE ready interrupt flag. */
  static const field32_t RCC_CIFR_HSIRDYF                   = {.msk = 0x00000004U, .pos = 2};    /** @brief HSI ready interrupt flag. */
  static const field32_t RCC_CIFR_HSERDYF                   = {.msk = 0x00000008U, .pos = 3};    /** @brief HSE ready interrupt flag. */
  static const field32_t RCC_CIFR_CSIRDY                    = {.msk = 0x00000010U, .pos = 4};    /** @brief CSI ready interrupt flag. */
  static const field32_t RCC_CIFR_RC48RDYF                  = {.msk = 0x00000020U, .pos = 5};    /** @brief RC48 ready interrupt flag. */
  static const field32_t RCC_CIFR_LSECSSF                   = {.msk = 0x00000200U, .pos = 9};    /** @brief LSE clock security system interrupt flag. */
  static const field32_t RCC_CIFR_HSECSSF                   = {.msk = 0x00000400U, .pos = 10};   /** @brief HSE clock security system interrupt flag. */
  static const field32_t RCC_CICR_LSIRDYC                   = {.msk = 0x00000001U, .pos = 0};    /** @brief LSI ready interrupt clear. */
  static const field32_t RCC_CICR_LSERDYC                   = {.msk = 0x00000002U, .pos = 1};    /** @brief LSE ready interrupt clear. */
  static const field32_t RCC_CICR_HSIRDYC                   = {.msk = 0x00000004U, .pos = 2};    /** @brief HSI ready interrupt clear. */
  static const field32_t RCC_CICR_HSERDYC                   = {.msk = 0x00000008U, .pos = 3};    /** @brief HSE ready interrupt clear. */
  static const field32_t RCC_CICR_HSE_READY_INTERRUPT_CLEAR = {.msk = 0x00000010U, .pos = 4};    /** @brief CSI ready interrupt clear. */
  static const field32_t RCC_CICR_RC48RDYC                  = {.msk = 0x00000020U, .pos = 5};    /** @brief RC48 ready interrupt clear. */
  static const field32_t RCC_CICR_LSECSSC                   = {.msk = 0x00000200U, .pos = 9};    /** @brief LSE clock security system interrupt clear. */
  static const field32_t RCC_CICR_HSECSSC                   = {.msk = 0x00000400U, .pos = 10};   /** @brief HSE clock security system interrupt clear. */
  static const field32_t RCC_BDCR_LSEON                     = {.msk = 0x00000001U, .pos = 0};    /** @brief LSE oscillator enabled. */
  static const field32_t RCC_BDCR_LSERDY                    = {.msk = 0x00000002U, .pos = 1};    /** @brief LSE oscillator ready. */
  static const field32_t RCC_BDCR_LSEBYP                    = {.msk = 0x00000004U, .pos = 2};    /** @brief LSE oscillator bypass. */
  static const field32_t RCC_BDCR_LSEDRV                    = {.msk = 0x00000018U, .pos = 3};    /** @brief LSE oscillator driving capability. */
  static const field32_t RCC_BDCR_LSECSSON                  = {.msk = 0x00000020U, .pos = 5};    /** @brief LSE clock security system enable. */
  static const field32_t RCC_BDCR_LSECSSD                   = {.msk = 0x00000040U, .pos = 6};    /** @brief LSE clock security system failure detection. */
  static const field32_t RCC_BDCR_RTCSRC                    = {.msk = 0x00000300U, .pos = 8};    /** @brief RTC clock source selection. */
  static const field32_t RCC_BDCR_RTCEN                     = {.msk = 0x00008000U, .pos = 15};   /** @brief RTC clock enable. */
  static const field32_t RCC_BDCR_VSWRST                    = {.msk = 0x00010000U, .pos = 16};   /** @brief VSwitch domain software reset. */
  static const field32_t RCC_CSR_LSION                      = {.msk = 0x00000001U, .pos = 0};    /** @brief LSI oscillator enable. */
  static const field32_t RCC_CSR_LSIRDY                     = {.msk = 0x00000002U, .pos = 1};    /** @brief LSI oscillator ready. */
  static const field32_t RCC_AHBxRSTR_MDMARST               = {.msk = 0x00000001U, .pos = 0};    /** @brief MDMA block reset. */
  static const field32_t RCC_AHBxRSTR_DMA2DRST              = {.msk = 0x00000010U, .pos = 4};    /** @brief DMA2D block reset. */
  static const field32_t RCC_AHBxRSTR_JPGDECRST             = {.msk = 0x00000020U, .pos = 5};    /** @brief JPGDEC block reset. */
  static const field32_t RCC_AHBxRSTR_FMCRST                = {.msk = 0x00001000U, .pos = 12};   /** @brief FMC block reset. */
  static const field32_t RCC_AHBxRSTR_QSPIRST               = {.msk = 0x00004000U, .pos = 14};   /** @brief QUADSPI and QUADSPI delay block reset. */
  static const field32_t RCC_AHBxRSTR_SDMMC1RST             = {.msk = 0x00010000U, .pos = 16};   /** @brief SDMMC1 and SDMMC1 delay block reset. */
  static const field32_t RCC_AHBxRSTR_CPURST                = {.msk = 0x80000000U, .pos = 31};   /** @brief CPU reset. */
  static const field32_t RCC_APBxRSTR_LTDCRST               = {.msk = 0x00000008U, .pos = 3};    /** @brief LTDC block reset. */
  static const field32_t RCC_APB1LRSTR_LPTIM1RST            = {.msk = 0x00000200U, .pos = 9};    /** @brief TIM block reset. */
  static const field32_t RCC_APB1LRSTR_SPDIFRXRST           = {.msk = 0x00010000U, .pos = 16};   /** @brief SPDIFRX block reset. */
  static const field32_t RCC_APB1LRSTR_HDMICECRST           = {.msk = 0x08000000U, .pos = 27};   /** @brief HDMI-CEC block reset. */
  static const field32_t RCC_APB1LRSTR_DAC12RST             = {.msk = 0x20000000U, .pos = 29};   /** @brief DAC1 and 2 blocks reset. */
  static const field32_t RCC_APB1HRSTR_CRSRST               = {.msk = 0x00000002U, .pos = 1};    /** @brief Clock recovery system reset. */
  static const field32_t RCC_APB1HRSTR_SWPRST               = {.msk = 0x00000004U, .pos = 2};    /** @brief SWPMI block reset. */
  static const field32_t RCC_APB1HRSTR_OPAMPRST             = {.msk = 0x00000010U, .pos = 4};    /** @brief OPAMP block reset. */
  static const field32_t RCC_APB1HRSTR_MDIOSRST             = {.msk = 0x00000020U, .pos = 5};    /** @brief MDIOS block reset. */
  static const field32_t RCC_APB1HRSTR_FDCANRST             = {.msk = 0x00000100U, .pos = 8};    /** @brief FDCAN block reset. */
  static const field32_t RCC_GCR_WW1RSC                     = {.msk = 0x00000001U, .pos = 0};    /** @brief WWDG1 reset scope control. */
  static const field32_t RCC_D3AMR_BDMAAMEN                 = {.msk = 0x00000001U, .pos = 0};    /** @brief BDMA and DMAMUX autonomous mode enable. */
  static const field32_t RCC_D3AMR_LPUART1AMEN              = {.msk = 0x00000008U, .pos = 3};    /** @brief LPUART1 autonomous mode enable. */
  static const field32_t RCC_D3AMR_SPI6AMEN                 = {.msk = 0x00000020U, .pos = 5};    /** @brief SPI6 autonomous mode enable. */
  static const field32_t RCC_D3AMR_I2C4AMEN                 = {.msk = 0x00000080U, .pos = 7};    /** @brief I2C4 autonomous mode enable. */
  static const field32_t RCC_D3AMR_COMP12AMEN               = {.msk = 0x00004000U, .pos = 14};   /** @brief COMP12 autonomous mode enable. */
  static const field32_t RCC_D3AMR_VREFAMEN                 = {.msk = 0x00008000U, .pos = 15};   /** @brief VREF autonomous mode enable. */
  static const field32_t RCC_D3AMR_RTCAMEN                  = {.msk = 0x00010000U, .pos = 16};   /** @brief RTC autonomous mode enable. */
  static const field32_t RCC_D3AMR_CRCAMEN                  = {.msk = 0x00080000U, .pos = 19};   /** @brief CRC autonomous mode enable. */
  static const field32_t RCC_D3AMR_SAI4AMEN                 = {.msk = 0x00200000U, .pos = 21};   /** @brief SAI4 autonomous mode enable. */
  static const field32_t RCC_D3AMR_ADC3AMEN                 = {.msk = 0x01000000U, .pos = 24};   /** @brief ADC3 autonomous mode enable. */
  static const field32_t RCC_D3AMR_BKPSRAMAMEN              = {.msk = 0x10000000U, .pos = 28};   /** @brief Backup RAM autonomous mode enable. */
  static const field32_t RCC_D3AMR_SRAM4AMEN                = {.msk = 0x20000000U, .pos = 29};   /** @brief SRAM4 autonomous mode enable. */
  static const field32_t RCC_RSR_RMVF                       = {.msk = 0x00010000U, .pos = 16};   /** @brief Remove reset flag. */
  static const field32_t RCC_RSR_CPURSTF                    = {.msk = 0x00020000U, .pos = 17};   /** @brief CPU reset flag. */
  static const field32_t RCC_RSR_BORRSTF                    = {.msk = 0x00200000U, .pos = 21};   /** @brief BOR reset flag. */
  static const field32_t RCC_RSR_PINRSTF                    = {.msk = 0x00400000U, .pos = 22};   /** @brief Pin reset flag (NRST). */
  static const field32_t RCC_RSR_PORRSTF                    = {.msk = 0x00800000U, .pos = 23};   /** @brief POR/PDR reset flag. */
  static const field32_t RCC_RSR_SFTRSTF                    = {.msk = 0x01000000U, .pos = 24};   /** @brief System reset from CPU reset flag. */
  static const field32_t RCC_RSR_IWDG1RSTF                  = {.msk = 0x04000000U, .pos = 26};   /** @brief Independent watchdog reset flag. */
  static const field32_t RCC_RSR_WWDG1RSTF                  = {.msk = 0x10000000U, .pos = 28};   /** @brief Window watchdog reset flag. */
  static const field32_t RCC_RSR_LPWRRSTF                   = {.msk = 0x40000000U, .pos = 30};   /** @brief Reset due to illegal D1 dstandby or CPU cstop flag. */
  static const field32_t RCC_C1_RSR_RMVF                    = {.msk = 0x00010000U, .pos = 16};   /** @brief Remove reset flag. */
  static const field32_t RCC_C1_RSR_CPURSTF                 = {.msk = 0x00020000U, .pos = 17};   /** @brief CPU reset flag. */
  static const field32_t RCC_C1_RSR_BORRSTF                 = {.msk = 0x00200000U, .pos = 21};   /** @brief BOR reset flag. */
  static const field32_t RCC_C1_RSR_PINRSTF                 = {.msk = 0x00400000U, .pos = 22};   /** @brief Pin reset flag (NRST). */
  static const field32_t RCC_C1_RSR_PORRSTF                 = {.msk = 0x00800000U, .pos = 23};   /** @brief POR/PDR reset flag. */
  static const field32_t RCC_C1_RSR_SFTRSTF                 = {.msk = 0x01000000U, .pos = 24};   /** @brief System reset from CPU reset flag. */
  static const field32_t RCC_C1_RSR_IWDG1RSTF               = {.msk = 0x04000000U, .pos = 26};   /** @brief Independent watchdog reset flag. */
  static const field32_t RCC_C1_RSR_WWDG1RSTF               = {.msk = 0x10000000U, .pos = 28};   /** @brief Window watchdog reset flag. */
  static const field32_t RCC_C1_RSR_LPWRRSTF                = {.msk = 0x40000000U, .pos = 30};   /** @brief Reset due to illegal D1 dstandby or CPU cstop flag. */
  static const field32_t RCC_C1_AHBxENR_MDMAEN              = {.msk = 0x00000001U, .pos = 0};    /** @brief MDMA peripheral clock enable. */
  static const field32_t RCC_C1_AHBxENR_DMA2DEN             = {.msk = 0x00000010U, .pos = 4};    /** @brief DMA2D peripheral clock enable. */
  static const field32_t RCC_C1_AHBxENR_JPGDECEN            = {.msk = 0x00000020U, .pos = 5};    /** @brief JPGDEC peripheral clock enable. */
  static const field32_t RCC_C1_AHBxENR_FMCEN               = {.msk = 0x00001000U, .pos = 12};   /** @brief FMC peripheral clocks enable. */
  static const field32_t RCC_C1_AHBxENR_QSPIEN              = {.msk = 0x00004000U, .pos = 14};   /** @brief QUADSPI and QUADSPI delay clock enable. */
  static const field32_t RCC_C1_AHBxENR_SDMMC1EN            = {.msk = 0x00010000U, .pos = 16};   /** @brief SDMMC1 and SDMMC1 delay clock enable. */
  static const field32_t RCC_AHBxENR_MDMAEN                 = {.msk = 0x00000001U, .pos = 0};    /** @brief MDMA peripheral clock enable. */
  static const field32_t RCC_AHBxENR_DMA2DEN                = {.msk = 0x00000010U, .pos = 4};    /** @brief DMA2D peripheral clock enable. */
  static const field32_t RCC_AHBxENR_JPGDECEN               = {.msk = 0x00000020U, .pos = 5};    /** @brief JPGDEC peripheral clock enable. */
  static const field32_t RCC_AHBxENR_FMCEN                  = {.msk = 0x00001000U, .pos = 12};   /** @brief FMC peripheral clocks enable. */
  static const field32_t RCC_AHBxENR_QSPIEN                 = {.msk = 0x00004000U, .pos = 14};   /** @brief QUADSPI and QUADSPI delay clock enable. */
  static const field32_t RCC_AHBxENR_SDMMC1EN               = {.msk = 0x00010000U, .pos = 16};   /** @brief SDMMC1 and SDMMC1 delay clock enable. */
  static const field32_t RCC_C1_APBxENR_LTDCEN              = {.msk = 0x00000008U, .pos = 3};    /** @brief LTDC peripheral clock enable. */
  static const field32_t RCC_C1_APBxENR_WWDG1EN             = {.msk = 0x00000040U, .pos = 6};    /** @brief WWDG1 clock enable. */
  static const field32_t RCC_APBxENR_LTDCEN                 = {.msk = 0x00000008U, .pos = 3};    /** @brief LTDC peripheral clock enable. */
  static const field32_t RCC_APBxENR_WWDG1EN                = {.msk = 0x00000040U, .pos = 6};    /** @brief WWDG1 clock enable. */
  static const field32_t RCC_APB1LENR_LPTIM1EN              = {.msk = 0x00000200U, .pos = 9};    /** @brief LPTIM1 peripheral clocks enable. */
  static const field32_t RCC_APB1LENR_SPDIFRXEN             = {.msk = 0x00010000U, .pos = 16};   /** @brief SPDIFRX peripheral clocks enable. */
  static const field32_t RCC_APB1LENR_HDMICECEN             = {.msk = 0x08000000U, .pos = 27};   /** @brief HDMI-CEC peripheral clock enable. */
  static const field32_t RCC_APB1LENR_DAC12EN               = {.msk = 0x20000000U, .pos = 29};   /** @brief DAC1&2 peripheral clock enable. */
  static const field32_t RCC_C1_APB1LENR_LPTIM1EN           = {.msk = 0x00000200U, .pos = 9};    /** @brief LPTIM1 peripheral clocks enable. */
  static const field32_t RCC_C1_APB1LENR_SPDIFRXEN          = {.msk = 0x00010000U, .pos = 16};   /** @brief SPDIFRX peripheral clocks enable. */
  static const field32_t RCC_C1_APB1LENR_HDMICECEN          = {.msk = 0x08000000U, .pos = 27};   /** @brief HDMI-CEC peripheral clock enable. */
  static const field32_t RCC_C1_APB1LENR_DAC12EN            = {.msk = 0x20000000U, .pos = 29};   /** @brief DAC1&2 peripheral clock enable. */
  static const field32_t RCC_APB1HENR_CRSEN                 = {.msk = 0x00000002U, .pos = 1};    /** @brief Clock recovery system peripheral clock enable. */
  static const field32_t RCC_APB1HENR_SWPEN                 = {.msk = 0x00000004U, .pos = 2};    /** @brief SWPMI peripheral clocks enable. */
  static const field32_t RCC_APB1HENR_OPAMPEN               = {.msk = 0x00000010U, .pos = 4};    /** @brief OPAMP peripheral clock enable. */
  static const field32_t RCC_APB1HENR_MDIOSEN               = {.msk = 0x00000020U, .pos = 5};    /** @brief MDIOS peripheral clock enable. */
  static const field32_t RCC_APB1HENR_FDCANEN               = {.msk = 0x00000100U, .pos = 8};    /** @brief FDCAN peripheral clocks enable. */
  static const field32_t RCC_GCR_WW2RSC                     = {.msk = 0x00000002U, .pos = 1};    /** @brief WWDG1 reset scope control. */
  static const field32_t RCC_GCR_BOOT_C1                    = {.msk = 0x00000004U, .pos = 2};    /** @brief WWDG1 reset scope control. */
  static const field32_t RCC_GCR_BOOT_C2                    = {.msk = 0x00000008U, .pos = 3};    /** @brief WWDG1 reset scope control. */
  static const field32_t RCC_C1_APB1HENR_CRSEN              = {.msk = 0x00000002U, .pos = 1};    /** @brief Clock recovery system peripheral clock enable. */
  static const field32_t RCC_C1_APB1HENR_SWPEN              = {.msk = 0x00000004U, .pos = 2};    /** @brief SWPMI peripheral clocks enable. */
  static const field32_t RCC_C1_APB1HENR_OPAMPEN            = {.msk = 0x00000010U, .pos = 4};    /** @brief OPAMP peripheral clock enable. */
  static const field32_t RCC_C1_APB1HENR_MDIOSEN            = {.msk = 0x00000020U, .pos = 5};    /** @brief MDIOS peripheral clock enable. */
  static const field32_t RCC_C1_APB1HENR_FDCANEN            = {.msk = 0x00000100U, .pos = 8};    /** @brief FDCAN peripheral clocks enable. */
  static const field32_t RCC_C1_AHBxLPENR_MDMALPEN          = {.msk = 0x00000001U, .pos = 0};    /** @brief MDMA clock enable during csleep mode. */
  static const field32_t RCC_C1_AHBxLPENR_DMA2DLPEN         = {.msk = 0x00000010U, .pos = 4};    /** @brief DMA2D clock enable during csleep mode. */
  static const field32_t RCC_C1_AHBxLPENR_JPGDECLPEN        = {.msk = 0x00000020U, .pos = 5};    /** @brief JPGDEC clock enable during csleep mode. */
  static const field32_t RCC_C1_AHBxLPENR_FLITFLPEN         = {.msk = 0x00000100U, .pos = 8};    /** @brief FLITF clock enable during csleep mode. */
  static const field32_t RCC_C1_AHBxLPENR_FMCLPEN           = {.msk = 0x00001000U, .pos = 12};   /** @brief FMC peripheral clocks enable during csleep mode. */
  static const field32_t RCC_C1_AHBxLPENR_QSPILPEN          = {.msk = 0x00004000U, .pos = 14};   /** @brief QUADSPI and QUADSPI delay clock enable during csleep mode. */
  static const field32_t RCC_C1_AHBxLPENR_SDMMC1LPEN        = {.msk = 0x00010000U, .pos = 16};   /** @brief SDMMC1 and SDMMC1 delay clock enable during csleep mode. */
  static const field32_t RCC_C1_AHBxLPENR_D1DTCM1LPEN       = {.msk = 0x10000000U, .pos = 28};   /** @brief D1DTCM1 block clock enable during csleep mode. */
  static const field32_t RCC_C1_AHBxLPENR_DTCM2LPEN         = {.msk = 0x20000000U, .pos = 29};   /** @brief D1 DTCM2 block clock enable during csleep mode. */
  static const field32_t RCC_C1_AHBxLPENR_ITCMLPEN          = {.msk = 0x40000000U, .pos = 30};   /** @brief D1ITCM block clock enable during csleep mode. */
  static const field32_t RCC_C1_AHBxLPENR_AXISRAMLPEN       = {.msk = 0x80000000U, .pos = 31};   /** @brief AXISRAM block clock enable during csleep mode. */
  static const field32_t RCC_AHBxLPENR_MDMALPEN             = {.msk = 0x00000001U, .pos = 0};    /** @brief MDMA clock enable during csleep mode. */
  static const field32_t RCC_AHBxLPENR_DMA2DLPEN            = {.msk = 0x00000010U, .pos = 4};    /** @brief DMA2D clock enable during csleep mode. */
  static const field32_t RCC_AHBxLPENR_JPGDECLPEN           = {.msk = 0x00000020U, .pos = 5};    /** @brief JPGDEC clock enable during csleep mode. */
  static const field32_t RCC_AHBxLPENR_FLITFLPEN            = {.msk = 0x00000100U, .pos = 8};    /** @brief FLITF clock enable during csleep mode. */
  static const field32_t RCC_AHBxLPENR_FMCLPEN              = {.msk = 0x00001000U, .pos = 12};   /** @brief FMC peripheral clocks enable during csleep mode. */
  static const field32_t RCC_AHBxLPENR_QSPILPEN             = {.msk = 0x00004000U, .pos = 14};   /** @brief QUADSPI and QUADSPI delay clock enable during csleep mode. */
  static const field32_t RCC_AHBxLPENR_SDMMC1LPEN           = {.msk = 0x00010000U, .pos = 16};   /** @brief SDMMC1 and SDMMC1 delay clock enable during csleep mode. */
  static const field32_t RCC_AHBxLPENR_D1DTCM1LPEN          = {.msk = 0x10000000U, .pos = 28};   /** @brief D1DTCM1 block clock enable during csleep mode. */
  static const field32_t RCC_AHBxLPENR_DTCM2LPEN            = {.msk = 0x20000000U, .pos = 29};   /** @brief D1 DTCM2 block clock enable during csleep mode. */
  static const field32_t RCC_AHBxLPENR_ITCMLPEN             = {.msk = 0x40000000U, .pos = 30};   /** @brief D1ITCM block clock enable during csleep mode. */
  static const field32_t RCC_AHBxLPENR_AXISRAMLPEN          = {.msk = 0x80000000U, .pos = 31};   /** @brief AXISRAM block clock enable during csleep mode. */
  static const field32_t RCC_C1_APBxLPENR_LTDCLPEN          = {.msk = 0x00000008U, .pos = 3};    /** @brief LTDC peripheral clock enable during csleep mode. */
  static const field32_t RCC_C1_APBxLPENR_WWDG1LPEN         = {.msk = 0x00000040U, .pos = 6};    /** @brief WWDG1 clock enable during csleep mode. */
  static const field32_t RCC_APBxLPENR_LTDCLPEN             = {.msk = 0x00000008U, .pos = 3};    /** @brief LTDC peripheral clock enable during csleep mode. */
  static const field32_t RCC_APBxLPENR_WWDG1LPEN            = {.msk = 0x00000040U, .pos = 6};    /** @brief WWDG1 clock enable during csleep mode. */
  static const field32_t RCC_APB1LLPENR_LPTIM1LPEN          = {.msk = 0x00000200U, .pos = 9};    /** @brief LPTIM1 peripheral clocks enable during csleep mode. */
  static const field32_t RCC_APB1LLPENR_SPDIFRXLPEN         = {.msk = 0x00010000U, .pos = 16};   /** @brief SPDIFRX peripheral clocks enable during csleep mode. */
  static const field32_t RCC_APB1LLPENR_HDMICECLPEN         = {.msk = 0x08000000U, .pos = 27};   /** @brief HDMI-CEC peripheral clocks enable during csleep mode. */
  static const field32_t RCC_APB1LLPENR_DAC12LPEN           = {.msk = 0x20000000U, .pos = 29};   /** @brief DAC1/2 peripheral clock enable during csleep mode. */
  static const field32_t RCC_C1_APB1LLPENR_LPTIM1LPEN       = {.msk = 0x00000200U, .pos = 9};    /** @brief LPTIM1 peripheral clocks enable during csleep mode. */
  static const field32_t RCC_C1_APB1LLPENR_SPDIFRXLPEN      = {.msk = 0x00010000U, .pos = 16};   /** @brief SPDIFRX peripheral clocks enable during csleep mode. */
  static const field32_t RCC_C1_APB1LLPENR_HDMICECLPEN      = {.msk = 0x08000000U, .pos = 27};   /** @brief HDMI-CEC peripheral clocks enable during csleep mode. */
  static const field32_t RCC_C1_APB1LLPENR_DAC12LPEN        = {.msk = 0x20000000U, .pos = 29};   /** @brief DAC1/2 peripheral clock enable during csleep mode. */
  static const field32_t RCC_C1_APB1HLPENR_CRSLPEN          = {.msk = 0x00000002U, .pos = 1};    /** @brief Clock recovery system peripheral clock enable during csleep mode. */
  static const field32_t RCC_C1_APB1HLPENR_SWPLPEN          = {.msk = 0x00000004U, .pos = 2};    /** @brief SWPMI peripheral clocks enable during csleep mode. */
  static const field32_t RCC_C1_APB1HLPENR_OPAMPLPEN        = {.msk = 0x00000010U, .pos = 4};    /** @brief OPAMP peripheral clock enable during csleep mode. */
  static const field32_t RCC_C1_APB1HLPENR_MDIOSLPEN        = {.msk = 0x00000020U, .pos = 5};    /** @brief MDIOS peripheral clock enable during csleep mode. */
  static const field32_t RCC_C1_APB1HLPENR_FDCANLPEN        = {.msk = 0x00000100U, .pos = 8};    /** @brief FDCAN peripheral clocks enable during csleep mode. */
  static const field32_t RCC_APB1HLPENR_CRSLPEN             = {.msk = 0x00000002U, .pos = 1};    /** @brief Clock recovery system peripheral clock enable during csleep mode. */
  static const field32_t RCC_APB1HLPENR_SWPLPEN             = {.msk = 0x00000004U, .pos = 2};    /** @brief SWPMI peripheral clocks enable during csleep mode. */
  static const field32_t RCC_APB1HLPENR_OPAMPLPEN           = {.msk = 0x00000010U, .pos = 4};    /** @brief OPAMP peripheral clock enable during csleep mode. */
  static const field32_t RCC_APB1HLPENR_MDIOSLPEN           = {.msk = 0x00000020U, .pos = 5};    /** @brief MDIOS peripheral clock enable during csleep mode. */
  static const field32_t RCC_APB1HLPENR_FDCANLPEN           = {.msk = 0x00000100U, .pos = 8};    /** @brief FDCAN peripheral clocks enable during csleep mode. */

  /**** Enumerated RCC Register Field Definitions ****/

  static field32_t const RCC_CR_DxCKRDY[3] = {
    [1] = {.msk = 0x00004000U, .pos = 14},   /** @brief D1 domain clocks ready flag. */
    [2] = {.msk = 0x00008000U, .pos = 15},   /** @brief D2 domain clocks ready flag. */
  };

  static field32_t const RCC_CR_PLLxON[4] = {
    [1] = {.msk = 0x01000000U, .pos = 24},   /** @brief PLL1 enable. */
    [2] = {.msk = 0x04000000U, .pos = 26},   /** @brief PLL2 enable. */
    [3] = {.msk = 0x10000000U, .pos = 28},   /** @brief PLL3 enable. */
  };

  static field32_t const RCC_CR_PLLxRDY[4] = {
    [1] = {.msk = 0x02000000U, .pos = 25},   /** @brief PLL1 clock ready flag. */
    [2] = {.msk = 0x08000000U, .pos = 27},   /** @brief PLL2 clock ready flag. */
    [3] = {.msk = 0x20000000U, .pos = 29},   /** @brief PLL3 clock ready flag. */
  };

  static field32_t const RCC_CFGR_MCOxPRE[3] = {
    [1] = {.msk = 0x003C0000U, .pos = 18},   /** @brief MCO1 prescaler. */
    [2] = {.msk = 0x1E000000U, .pos = 25},   /** @brief MCO2 prescaler. */
  };

  static field32_t const RCC_CFGR_MCOxSEL[3] = {
    [1] = {.msk = 0x01C00000U, .pos = 22},   /** @brief Micro-controller clock output 1. */
    [2] = {.msk = 0xE0000000U, .pos = 29},   /** @brief Micro-controller clock output 2. */
  };

  static field32_t const RCC_PLLCKSELR_DIVMx[4] = {
    [1] = {.msk = 0x000003F0U, .pos = 4},    /** @brief Prescaler for PLL1. */
    [2] = {.msk = 0x0003F000U, .pos = 12},   /** @brief Prescaler for PLL2. */
    [3] = {.msk = 0x03F00000U, .pos = 20},   /** @brief Prescaler for PLL3. */
  };

  static field32_t const RCC_PLLCFGR_PLLxFRACEN[4] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief PLL1 fractional latch enable. */
    [2] = {.msk = 0x00000010U, .pos = 4},   /** @brief PLL2 fractional latch enable. */
    [3] = {.msk = 0x00000100U, .pos = 8},   /** @brief PLL3 fractional latch enable. */
  };

  static field32_t const RCC_PLLCFGR_PLLxVCOSEL[4] = {
    [1] = {.msk = 0x00000002U, .pos = 1},   /** @brief PLL1 VCO selection. */
    [2] = {.msk = 0x00000020U, .pos = 5},   /** @brief PLL2 VCO selection. */
    [3] = {.msk = 0x00000200U, .pos = 9},   /** @brief PLL3 VCO selection. */
  };

  static field32_t const RCC_PLLCFGR_PLLxRGE[4] = {
    [1] = {.msk = 0x0000000CU, .pos = 2},    /** @brief PLL1 input frequency range. */
    [2] = {.msk = 0x000000C0U, .pos = 6},    /** @brief PLL2 input frequency range. */
    [3] = {.msk = 0x00000C00U, .pos = 10},   /** @brief PLL3 input frequency range. */
  };

  static field32_t const RCC_PLLCFGR_DIVPxEN[4] = {
    [1] = {.msk = 0x00010000U, .pos = 16},   /** @brief PLL1 DIVP divider output enable. */
    [2] = {.msk = 0x00080000U, .pos = 19},   /** @brief PLL2 DIVP divider output enable. */
    [3] = {.msk = 0x00400000U, .pos = 22},   /** @brief PLL3 DIVP divider output enable. */
  };

  static field32_t const RCC_PLLCFGR_DIVQxEN[4] = {
    [1] = {.msk = 0x00020000U, .pos = 17},   /** @brief PLL1 DIVQ divider output enable. */
    [2] = {.msk = 0x00100000U, .pos = 20},   /** @brief PLL2 DIVQ divider output enable. */
    [3] = {.msk = 0x00800000U, .pos = 23},   /** @brief PLL3 DIVQ divider output enable. */
  };

  static field32_t const RCC_PLLCFGR_DIVRxEN[4] = {
    [1] = {.msk = 0x00040000U, .pos = 18},   /** @brief PLL1 DIVR divider output enable. */
    [2] = {.msk = 0x00200000U, .pos = 21},   /** @brief PLL2 DIVR divider output enable. */
    [3] = {.msk = 0x01000000U, .pos = 24},   /** @brief PLL3 DIVR divider output enable. */
  };

  static field32_t const RCC_CIER_PLLxRDYIE[4] = {
    [1] = {.msk = 0x00000040U, .pos = 6},   /** @brief PLL1 ready interrupt enable. */
    [2] = {.msk = 0x00000080U, .pos = 7},   /** @brief PLL2 ready interrupt enable. */
    [3] = {.msk = 0x00000100U, .pos = 8},   /** @brief PLL3 ready interrupt enable. */
  };

  static field32_t const RCC_CIFR_PLLxRDYF[4] = {
    [1] = {.msk = 0x00000040U, .pos = 6},   /** @brief PLL1 ready interrupt flag. */
    [2] = {.msk = 0x00000080U, .pos = 7},   /** @brief PLL2 ready interrupt flag. */
    [3] = {.msk = 0x00000100U, .pos = 8},   /** @brief PLL3 ready interrupt flag. */
  };

  static field32_t const RCC_CICR_PLLxRDYC[4] = {
    [1] = {.msk = 0x00000040U, .pos = 6},   /** @brief PLL1 ready interrupt clear. */
    [2] = {.msk = 0x00000080U, .pos = 7},   /** @brief PLL2 ready interrupt clear. */
    [3] = {.msk = 0x00000100U, .pos = 8},   /** @brief PLL3 ready interrupt clear. */
  };

  static field32_t const RCC_APB1LRSTR_TIMxRST[15] = {
    [2]  = {.msk = 0x00000001U, .pos = 0},   /** @brief TIM block reset. */
    [3]  = {.msk = 0x00000002U, .pos = 1},   /** @brief TIM block reset. */
    [4]  = {.msk = 0x00000004U, .pos = 2},   /** @brief TIM block reset. */
    [5]  = {.msk = 0x00000008U, .pos = 3},   /** @brief TIM block reset. */
    [6]  = {.msk = 0x00000010U, .pos = 4},   /** @brief TIM block reset. */
    [7]  = {.msk = 0x00000020U, .pos = 5},   /** @brief TIM block reset. */
    [12] = {.msk = 0x00000040U, .pos = 6},   /** @brief TIM block reset. */
    [13] = {.msk = 0x00000080U, .pos = 7},   /** @brief TIM block reset. */
    [14] = {.msk = 0x00000100U, .pos = 8},   /** @brief TIM block reset. */
  };

  static field32_t const RCC_APB1LRSTR_SPIxRST[4] = {
    [2] = {.msk = 0x00004000U, .pos = 14},   /** @brief SPI2 block reset. */
    [3] = {.msk = 0x00008000U, .pos = 15},   /** @brief SPI3 block reset. */
  };

  static field32_t const RCC_APB1LRSTR_USARTxRST[9] = {
    [2] = {.msk = 0x00020000U, .pos = 17},   /** @brief USART2 block reset. */
    [3] = {.msk = 0x00040000U, .pos = 18},   /** @brief USART3 block reset. */
    [7] = {.msk = 0x40000000U, .pos = 30},   /** @brief USART7 block reset. */
    [8] = {.msk = 0x80000000U, .pos = 31},   /** @brief USART8 block reset. */
  };

  static field32_t const RCC_APB1LRSTR_UARTxRST[6] = {
    [4] = {.msk = 0x00080000U, .pos = 19},   /** @brief UART4 block reset. */
    [5] = {.msk = 0x00100000U, .pos = 20},   /** @brief UART5 block reset. */
  };

  static field32_t const RCC_APB1LRSTR_I2CxRST[4] = {
    [1] = {.msk = 0x00200000U, .pos = 21},   /** @brief I2C1 block reset. */
    [2] = {.msk = 0x00400000U, .pos = 22},   /** @brief I2C2 block reset. */
    [3] = {.msk = 0x00800000U, .pos = 23},   /** @brief I2C3 block reset. */
  };

  static field32_t const RCC_D3AMR_LPTIMxAMEN[6] = {
    [2] = {.msk = 0x00000200U, .pos = 9},    /** @brief LPTIM2 autonomous mode enable. */
    [3] = {.msk = 0x00000400U, .pos = 10},   /** @brief LPTIM3 autonomous mode enable. */
    [4] = {.msk = 0x00000800U, .pos = 11},   /** @brief LPTIM4 autonomous mode enable. */
    [5] = {.msk = 0x00001000U, .pos = 12},   /** @brief LPTIM5 autonomous mode enable. */
  };

  static field32_t const RCC_RSR_DxRSTF[3] = {
    [1] = {.msk = 0x00080000U, .pos = 19},   /** @brief D1 domain power switch reset flag. */
    [2] = {.msk = 0x00100000U, .pos = 20},   /** @brief D2 domain power switch reset flag. */
  };

  static field32_t const RCC_APB1LENR_TIMxEN[15] = {
    [2]  = {.msk = 0x00000001U, .pos = 0},   /** @brief TIM peripheral clock enable. */
    [3]  = {.msk = 0x00000002U, .pos = 1},   /** @brief TIM peripheral clock enable. */
    [4]  = {.msk = 0x00000004U, .pos = 2},   /** @brief TIM peripheral clock enable. */
    [5]  = {.msk = 0x00000008U, .pos = 3},   /** @brief TIM peripheral clock enable. */
    [6]  = {.msk = 0x00000010U, .pos = 4},   /** @brief TIM peripheral clock enable. */
    [7]  = {.msk = 0x00000020U, .pos = 5},   /** @brief TIM peripheral clock enable. */
    [12] = {.msk = 0x00000040U, .pos = 6},   /** @brief TIM peripheral clock enable. */
    [13] = {.msk = 0x00000080U, .pos = 7},   /** @brief TIM peripheral clock enable. */
    [14] = {.msk = 0x00000100U, .pos = 8},   /** @brief TIM peripheral clock enable. */
  };

  static field32_t const RCC_APB1LENR_SPIxEN[4] = {
    [2] = {.msk = 0x00004000U, .pos = 14},   /** @brief SPI2 peripheral clocks enable. */
    [3] = {.msk = 0x00008000U, .pos = 15},   /** @brief SPI3 peripheral clocks enable. */
  };

  static field32_t const RCC_APB1LENR_USARTxEN[9] = {
    [2] = {.msk = 0x00020000U, .pos = 17},   /** @brief USART2 peripheral clocks enable. */
    [3] = {.msk = 0x00040000U, .pos = 18},   /** @brief USART3 peripheral clocks enable. */
    [7] = {.msk = 0x40000000U, .pos = 30},   /** @brief USART7 peripheral clocks enable. */
    [8] = {.msk = 0x80000000U, .pos = 31},   /** @brief USART8 peripheral clocks enable. */
  };

  static field32_t const RCC_APB1LENR_UARTxEN[6] = {
    [4] = {.msk = 0x00080000U, .pos = 19},   /** @brief UART4 peripheral clocks enable. */
    [5] = {.msk = 0x00100000U, .pos = 20},   /** @brief UART5 peripheral clocks enable. */
  };

  static field32_t const RCC_APB1LENR_I2CxEN[4] = {
    [1] = {.msk = 0x00200000U, .pos = 21},   /** @brief I2C1 peripheral clocks enable. */
    [2] = {.msk = 0x00400000U, .pos = 22},   /** @brief I2C2 peripheral clocks enable. */
    [3] = {.msk = 0x00800000U, .pos = 23},   /** @brief I2C3 peripheral clocks enable. */
  };

  static field32_t const RCC_APB1LLPENR_TIMxLPEN[15] = {
    [2]  = {.msk = 0x00000001U, .pos = 0},   /** @brief TIM2 peripheral clock enable during csleep mode. */
    [3]  = {.msk = 0x00000002U, .pos = 1},   /** @brief TIM3 peripheral clock enable during csleep mode. */
    [4]  = {.msk = 0x00000004U, .pos = 2},   /** @brief TIM4 peripheral clock enable during csleep mode. */
    [5]  = {.msk = 0x00000008U, .pos = 3},   /** @brief TIM5 peripheral clock enable during csleep mode. */
    [6]  = {.msk = 0x00000010U, .pos = 4},   /** @brief TIM6 peripheral clock enable during csleep mode. */
    [7]  = {.msk = 0x00000020U, .pos = 5},   /** @brief TIM7 peripheral clock enable during csleep mode. */
    [12] = {.msk = 0x00000040U, .pos = 6},   /** @brief TIM12 peripheral clock enable during csleep mode. */
    [13] = {.msk = 0x00000080U, .pos = 7},   /** @brief TIM13 peripheral clock enable during csleep mode. */
    [14] = {.msk = 0x00000100U, .pos = 8},   /** @brief TIM14 peripheral clock enable during csleep mode. */
  };

  static field32_t const RCC_APB1LLPENR_SPIxLPEN[4] = {
    [2] = {.msk = 0x00004000U, .pos = 14},   /** @brief SPI2 peripheral clocks enable during csleep mode. */
    [3] = {.msk = 0x00008000U, .pos = 15},   /** @brief SPI3 peripheral clocks enable during csleep mode. */
  };

  static field32_t const RCC_APB1LLPENR_USARTxLPEN[9] = {
    [2] = {.msk = 0x00020000U, .pos = 17},   /** @brief USART2 peripheral clocks enable during csleep mode. */
    [3] = {.msk = 0x00040000U, .pos = 18},   /** @brief USART3 peripheral clocks enable during csleep mode. */
    [7] = {.msk = 0x40000000U, .pos = 30},   /** @brief USART7 peripheral clocks enable during csleep mode. */
    [8] = {.msk = 0x80000000U, .pos = 31},   /** @brief USART8 peripheral clocks enable during csleep mode. */
  };

  static field32_t const RCC_APB1LLPENR_UARTxLPEN[6] = {
    [4] = {.msk = 0x00080000U, .pos = 19},   /** @brief UART4 peripheral clocks enable during csleep mode. */
    [5] = {.msk = 0x00100000U, .pos = 20},   /** @brief UART5 peripheral clocks enable during csleep mode. */
  };

  static field32_t const RCC_APB1LLPENR_I2CxLPEN[4] = {
    [1] = {.msk = 0x00200000U, .pos = 21},   /** @brief I2C1 peripheral clocks enable during csleep mode. */
    [2] = {.msk = 0x00400000U, .pos = 22},   /** @brief I2C2 peripheral clocks enable during csleep mode. */
    [3] = {.msk = 0x00800000U, .pos = 23},   /** @brief I2C3 peripheral clocks enable during csleep mode. */
  };

  /************************************************************************************************
   * LPTIMx Definitions
   ************************************************************************************************/

  /**** Enumerated LPTIMx Register Definitions ****/

  static const ro_reg32_t LPTIMx_ISR[6] = {
    [1] = (ro_reg32_t)0x40002400U,   /** @brief Interrupt and status register. */
    [2] = (ro_reg32_t)0x58002400U,   /** @brief Interrupt and status register. */
    [3] = (ro_reg32_t)0x58002800U,   /** @brief Interrupt and status register. */
    [4] = (ro_reg32_t)0x58002C00U,   /** @brief Interrupt and status register. */
    [5] = (ro_reg32_t)0x58003000U,   /** @brief Interrupt and status register. */
  };

  static const rw_reg32_t LPTIMx_ICR[6] = {
    [1] = (rw_reg32_t)0x40002404U,   /** @brief Interrupt clear register. */
    [2] = (rw_reg32_t)0x58002404U,   /** @brief Interrupt clear register. */
    [3] = (rw_reg32_t)0x58002804U,   /** @brief Interrupt clear register. */
    [4] = (rw_reg32_t)0x58002C04U,   /** @brief Interrupt clear register. */
    [5] = (rw_reg32_t)0x58003004U,   /** @brief Interrupt clear register. */
  };

  static const rw_reg32_t LPTIMx_IER[6] = {
    [1] = (rw_reg32_t)0x40002408U,   /** @brief Interrupt enable register. */
    [2] = (rw_reg32_t)0x58002408U,   /** @brief Interrupt enable register. */
    [3] = (rw_reg32_t)0x58002808U,   /** @brief Interrupt enable register. */
    [4] = (rw_reg32_t)0x58002C08U,   /** @brief Interrupt enable register. */
    [5] = (rw_reg32_t)0x58003008U,   /** @brief Interrupt enable register. */
  };

  static const rw_reg32_t LPTIMx_CFGR[6] = {
    [1] = (rw_reg32_t)0x4000240CU,   /** @brief Configuration register. */
    [2] = (rw_reg32_t)0x5800240CU,   /** @brief Configuration register. */
    [3] = (rw_reg32_t)0x5800280CU,   /** @brief Configuration register. */
    [4] = (rw_reg32_t)0x58002C0CU,   /** @brief Configuration register. */
    [5] = (rw_reg32_t)0x5800300CU,   /** @brief Configuration register. */
  };

  static const rw_reg32_t LPTIMx_CR[6] = {
    [1] = (rw_reg32_t)0x40002410U,   /** @brief Control register. */
    [2] = (rw_reg32_t)0x58002410U,   /** @brief Control register. */
    [3] = (rw_reg32_t)0x58002810U,   /** @brief Control register. */
    [4] = (rw_reg32_t)0x58002C10U,   /** @brief Control register. */
    [5] = (rw_reg32_t)0x58003010U,   /** @brief Control register. */
  };

  static const rw_reg32_t LPTIMx_CMP[6] = {
    [1] = (rw_reg32_t)0x40002414U,   /** @brief Compare register. */
    [2] = (rw_reg32_t)0x58002414U,   /** @brief Compare register. */
    [3] = (rw_reg32_t)0x58002814U,   /** @brief Compare register. */
    [4] = (rw_reg32_t)0x58002C14U,   /** @brief Compare register. */
    [5] = (rw_reg32_t)0x58003014U,   /** @brief Compare register. */
  };

  static const rw_reg32_t LPTIMx_ARR[6] = {
    [1] = (rw_reg32_t)0x40002418U,   /** @brief Autoreload register. */
    [2] = (rw_reg32_t)0x58002418U,   /** @brief Autoreload register. */
    [3] = (rw_reg32_t)0x58002818U,   /** @brief Autoreload register. */
    [4] = (rw_reg32_t)0x58002C18U,   /** @brief Autoreload register. */
    [5] = (rw_reg32_t)0x58003018U,   /** @brief Autoreload register. */
  };

  static const ro_reg32_t LPTIMx_CNT[6] = {
    [1] = (ro_reg32_t)0x4000241CU,   /** @brief Counter register. */
    [2] = (ro_reg32_t)0x5800241CU,   /** @brief Counter register. */
    [3] = (ro_reg32_t)0x5800281CU,   /** @brief Counter register. */
    [4] = (ro_reg32_t)0x58002C1CU,   /** @brief Counter register. */
    [5] = (ro_reg32_t)0x5800301CU,   /** @brief Counter register. */
  };

  static const rw_reg32_t LPTIMx_CFGR2[6] = {
    [1] = (rw_reg32_t)0x40002424U,   /** @brief LPTIM configuration register 2. */
    [2] = (rw_reg32_t)0x58002424U,   /** @brief LPTIM configuration register 2. */
    [3] = (rw_reg32_t)0x58002824U,   /** @brief LPTIM configuration register 2. */
    [4] = (rw_reg32_t)0x58002C24U,   /** @brief LPTIM configuration register 2. */
    [5] = (rw_reg32_t)0x58003024U,   /** @brief LPTIM configuration register 2. */
  };

  /**** LPTIMx Register Field Definitions ****/

  static const field32_t LPTIMx_ISR_DOWN       = {.msk = 0x00000040U, .pos = 6};    /** @brief Counter direction change up to down. */
  static const field32_t LPTIMx_ISR_UP         = {.msk = 0x00000020U, .pos = 5};    /** @brief Counter direction change down to up. */
  static const field32_t LPTIMx_ISR_ARROK      = {.msk = 0x00000010U, .pos = 4};    /** @brief Autoreload register update OK. */
  static const field32_t LPTIMx_ISR_CMPOK      = {.msk = 0x00000008U, .pos = 3};    /** @brief Compare register update OK. */
  static const field32_t LPTIMx_ISR_EXTTRIG    = {.msk = 0x00000004U, .pos = 2};    /** @brief External trigger edge event. */
  static const field32_t LPTIMx_ISR_ARRM       = {.msk = 0x00000002U, .pos = 1};    /** @brief Autoreload match. */
  static const field32_t LPTIMx_ISR_CMPM       = {.msk = 0x00000001U, .pos = 0};    /** @brief Compare match. */
  static const field32_t LPTIMx_ICR_DOWNCF     = {.msk = 0x00000040U, .pos = 6};    /** @brief Direction change to down clear flag. */
  static const field32_t LPTIMx_ICR_UPCF       = {.msk = 0x00000020U, .pos = 5};    /** @brief Direction change to UP clear flag. */
  static const field32_t LPTIMx_ICR_ARROKCF    = {.msk = 0x00000010U, .pos = 4};    /** @brief Autoreload register update OK clear flag. */
  static const field32_t LPTIMx_ICR_CMPOKCF    = {.msk = 0x00000008U, .pos = 3};    /** @brief Compare register update OK clear flag. */
  static const field32_t LPTIMx_ICR_EXTTRIGCF  = {.msk = 0x00000004U, .pos = 2};    /** @brief External trigger valid edge clear flag. */
  static const field32_t LPTIMx_ICR_ARRMCF     = {.msk = 0x00000002U, .pos = 1};    /** @brief Autoreload match clear flag. */
  static const field32_t LPTIMx_ICR_CMPMCF     = {.msk = 0x00000001U, .pos = 0};    /** @brief Compare match clear flag. */
  static const field32_t LPTIMx_IER_DOWNIE     = {.msk = 0x00000040U, .pos = 6};    /** @brief Direction change to down interrupt enable. */
  static const field32_t LPTIMx_IER_UPIE       = {.msk = 0x00000020U, .pos = 5};    /** @brief Direction change to UP interrupt enable. */
  static const field32_t LPTIMx_IER_ARROKIE    = {.msk = 0x00000010U, .pos = 4};    /** @brief Autoreload register update OK interrupt enable. */
  static const field32_t LPTIMx_IER_CMPOKIE    = {.msk = 0x00000008U, .pos = 3};    /** @brief Compare register update OK interrupt enable. */
  static const field32_t LPTIMx_IER_EXTTRIGIE  = {.msk = 0x00000004U, .pos = 2};    /** @brief External trigger valid edge interrupt enable. */
  static const field32_t LPTIMx_IER_ARRMIE     = {.msk = 0x00000002U, .pos = 1};    /** @brief Autoreload match interrupt enable. */
  static const field32_t LPTIMx_IER_CMPMIE     = {.msk = 0x00000001U, .pos = 0};    /** @brief Compare match interrupt enable. */
  static const field32_t LPTIMx_CFGR_ENC       = {.msk = 0x01000000U, .pos = 24};   /** @brief Encoder mode enable. */
  static const field32_t LPTIMx_CFGR_COUNTMODE = {.msk = 0x00800000U, .pos = 23};   /** @brief Counter mode enabled. */
  static const field32_t LPTIMx_CFGR_PRELOAD   = {.msk = 0x00400000U, .pos = 22};   /** @brief Registers update mode. */
  static const field32_t LPTIMx_CFGR_WAVPOL    = {.msk = 0x00200000U, .pos = 21};   /** @brief Waveform shape polarity. */
  static const field32_t LPTIMx_CFGR_WAVE      = {.msk = 0x00100000U, .pos = 20};   /** @brief Waveform shape. */
  static const field32_t LPTIMx_CFGR_TIMOUT    = {.msk = 0x00080000U, .pos = 19};   /** @brief Timeout enable. */
  static const field32_t LPTIMx_CFGR_TRIGEN    = {.msk = 0x00060000U, .pos = 17};   /** @brief Trigger enable and polarity. */
  static const field32_t LPTIMx_CFGR_TRIGSEL   = {.msk = 0x0000E000U, .pos = 13};   /** @brief Trigger selector. */
  static const field32_t LPTIMx_CFGR_PRESC     = {.msk = 0x00000E00U, .pos = 9};    /** @brief Clock prescaler. */
  static const field32_t LPTIMx_CFGR_TRGFLT    = {.msk = 0x000000C0U, .pos = 6};    /** @brief Configurable digital filter for trigger. */
  static const field32_t LPTIMx_CFGR_CKFLT     = {.msk = 0x00000018U, .pos = 3};    /** @brief Configurable digital filter for external clock. */
  static const field32_t LPTIMx_CFGR_CKPOL     = {.msk = 0x00000006U, .pos = 1};    /** @brief Clock polarity. */
  static const field32_t LPTIMx_CFGR_CKSEL     = {.msk = 0x00000001U, .pos = 0};    /** @brief Clock selector. */
  static const field32_t LPTIMx_CR_ENABLE      = {.msk = 0x00000001U, .pos = 0};    /** @brief LPTIM enable. */
  static const field32_t LPTIMx_CR_SNGSTRT     = {.msk = 0x00000002U, .pos = 1};    /** @brief LPTIM start in single mode. */
  static const field32_t LPTIMx_CR_CNTSTRT     = {.msk = 0x00000004U, .pos = 2};    /** @brief Timer start in continuous mode. */
  static const field32_t LPTIMx_CR_COUNTRST    = {.msk = 0x00000008U, .pos = 3};    /** @brief Counter reset. */
  static const field32_t LPTIMx_CR_RSTARE      = {.msk = 0x00000010U, .pos = 4};    /** @brief Reset after read enable. */
  static const field32_t LPTIMx_CMP_CMP        = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Compare value. */
  static const field32_t LPTIMx_ARR_ARR        = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Auto reload value. */
  static const field32_t LPTIMx_CNT_CNT        = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Counter value. */

  /**** Enumerated LPTIMx Register Field Definitions ****/

  static field32_t const LPTIMx_CFGR2_INxSEL[3] = {
    [1] = {.msk = 0x00000003U, .pos = 0},   /** @brief LPTIM input 1 selection. */
    [2] = {.msk = 0x00000030U, .pos = 4},   /** @brief LPTIM input 2 selection. */
  };

  /************************************************************************************************
   * LPUART1 Definitions
   ************************************************************************************************/

  /**** LPUART1 Register Definitions ****/

  static const rw_reg32_t LPUART1_BRR   = (rw_reg32_t)0x58000C0CU;   /** @brief Baud rate register. */
  static const rw_reg32_t LPUART1_GTPR  = (rw_reg32_t)0x58000C10U;   /** @brief Guard time and prescaler register. */
  static const rw_reg32_t LPUART1_RTOR  = (rw_reg32_t)0x58000C14U;   /** @brief Receiver timeout register. */
  static const rw_reg32_t LPUART1_RQR   = (rw_reg32_t)0x58000C18U;   /** @brief Request register. */
  static const ro_reg32_t LPUART1_ISR   = (ro_reg32_t)0x58000C1CU;   /** @brief Interrupt & status register. */
  static const rw_reg32_t LPUART1_ICR   = (rw_reg32_t)0x58000C20U;   /** @brief Interrupt flag clear register. */
  static const ro_reg32_t LPUART1_RDR   = (ro_reg32_t)0x58000C24U;   /** @brief Receive data register. */
  static const rw_reg32_t LPUART1_TDR   = (rw_reg32_t)0x58000C28U;   /** @brief Transmit data register. */
  static const rw_reg32_t LPUART1_PRESC = (rw_reg32_t)0x58000C2CU;   /** @brief Prescaler register. */

  /**** Enumerated LPUART1 Register Definitions ****/

  static const rw_reg32_t LPUART1_CRx[4] = {
    [1] = (rw_reg32_t)0x58000C00U,   /** @brief Control register 1. */
    [2] = (rw_reg32_t)0x58000C04U,   /** @brief Control register 2. */
    [3] = (rw_reg32_t)0x58000C08U,   /** @brief Control register 3. */
  };

  /**** LPUART1 Register Field Definitions ****/

  static const field32_t LPUART1_CRx_RXFFIE      = {.msk = 0x80000000U, .pos = 31};   /** @brief RXFIFO full interrupt enable. */
  static const field32_t LPUART1_CRx_TXFEIE      = {.msk = 0x40000000U, .pos = 30};   /** @brief TXFIFO empty interrupt enable. */
  static const field32_t LPUART1_CRx_FIFOEN      = {.msk = 0x20000000U, .pos = 29};   /** @brief FIFO mode enable. */
  static const field32_t LPUART1_CRx_DEAT        = {.msk = 0x03E00000U, .pos = 21};   /** @brief Driver enable assertion time. */
  static const field32_t LPUART1_CRx_DEDT        = {.msk = 0x001F0000U, .pos = 16};   /** @brief Driver enable deassertion time. */
  static const field32_t LPUART1_CRx_CMIE        = {.msk = 0x00004000U, .pos = 14};   /** @brief Character match interrupt enable. */
  static const field32_t LPUART1_CRx_MME         = {.msk = 0x00002000U, .pos = 13};   /** @brief Mute mode enable. */
  static const field32_t LPUART1_CRx_WAKE        = {.msk = 0x00000800U, .pos = 11};   /** @brief Receiver wakeup method. */
  static const field32_t LPUART1_CRx_PCE         = {.msk = 0x00000400U, .pos = 10};   /** @brief Parity control enable. */
  static const field32_t LPUART1_CRx_PS          = {.msk = 0x00000200U, .pos = 9};    /** @brief Parity selection. */
  static const field32_t LPUART1_CRx_PEIE        = {.msk = 0x00000100U, .pos = 8};    /** @brief PE interrupt enable. */
  static const field32_t LPUART1_CRx_TXEIE       = {.msk = 0x00000080U, .pos = 7};    /** @brief Interrupt enable. */
  static const field32_t LPUART1_CRx_TCIE        = {.msk = 0x00000040U, .pos = 6};    /** @brief Transmission complete interrupt enable. */
  static const field32_t LPUART1_CRx_RXNEIE      = {.msk = 0x00000020U, .pos = 5};    /** @brief RXNE interrupt enable. */
  static const field32_t LPUART1_CRx_IDLEIE      = {.msk = 0x00000010U, .pos = 4};    /** @brief IDLE interrupt enable. */
  static const field32_t LPUART1_CRx_TE          = {.msk = 0x00000008U, .pos = 3};    /** @brief Transmitter enable. */
  static const field32_t LPUART1_CRx_RE          = {.msk = 0x00000004U, .pos = 2};    /** @brief Receiver enable. */
  static const field32_t LPUART1_CRx_UESM        = {.msk = 0x00000002U, .pos = 1};    /** @brief USART enable in stop mode. */
  static const field32_t LPUART1_CRx_UE          = {.msk = 0x00000001U, .pos = 0};    /** @brief USART enable. */
  static const field32_t LPUART1_BRR_BRR         = {.msk = 0x000FFFFFU, .pos = 0};    /** @brief BRR. */
  static const field32_t LPUART1_GTPR_GT         = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Guard time value. */
  static const field32_t LPUART1_GTPR_PSC        = {.msk = 0x000000FFU, .pos = 0};    /** @brief Prescaler value. */
  static const field32_t LPUART1_RTOR_BLEN       = {.msk = 0xFF000000U, .pos = 24};   /** @brief Block length. */
  static const field32_t LPUART1_RTOR_RTO        = {.msk = 0x00FFFFFFU, .pos = 0};    /** @brief Receiver timeout value. */
  static const field32_t LPUART1_RQR_TXFRQ       = {.msk = 0x00000010U, .pos = 4};    /** @brief Transmit data flush request. */
  static const field32_t LPUART1_RQR_RXFRQ       = {.msk = 0x00000008U, .pos = 3};    /** @brief Receive data flush request. */
  static const field32_t LPUART1_RQR_MMRQ        = {.msk = 0x00000004U, .pos = 2};    /** @brief Mute mode request. */
  static const field32_t LPUART1_RQR_SBKRQ       = {.msk = 0x00000002U, .pos = 1};    /** @brief Send break request. */
  static const field32_t LPUART1_RQR_ABRRQ       = {.msk = 0x00000001U, .pos = 0};    /** @brief Auto baud rate request. */
  static const field32_t LPUART1_ISR_TXFT        = {.msk = 0x08000000U, .pos = 27};   /** @brief TXFIFO threshold flag. */
  static const field32_t LPUART1_ISR_RXFT        = {.msk = 0x04000000U, .pos = 26};   /** @brief RXFIFO threshold flag. */
  static const field32_t LPUART1_ISR_RXFF        = {.msk = 0x01000000U, .pos = 24};   /** @brief RXFIFO full. */
  static const field32_t LPUART1_ISR_TXFE        = {.msk = 0x00800000U, .pos = 23};   /** @brief TXFIFO empty. */
  static const field32_t LPUART1_ISR_REACK       = {.msk = 0x00400000U, .pos = 22};   /** @brief REACK. */
  static const field32_t LPUART1_ISR_TEACK       = {.msk = 0x00200000U, .pos = 21};   /** @brief TEACK. */
  static const field32_t LPUART1_ISR_WUF         = {.msk = 0x00100000U, .pos = 20};   /** @brief WUF. */
  static const field32_t LPUART1_ISR_RWU         = {.msk = 0x00080000U, .pos = 19};   /** @brief RWU. */
  static const field32_t LPUART1_ISR_SBKF        = {.msk = 0x00040000U, .pos = 18};   /** @brief SBKF. */
  static const field32_t LPUART1_ISR_CMF         = {.msk = 0x00020000U, .pos = 17};   /** @brief CMF. */
  static const field32_t LPUART1_ISR_BUSY        = {.msk = 0x00010000U, .pos = 16};   /** @brief BUSY. */
  static const field32_t LPUART1_ISR_CTS         = {.msk = 0x00000400U, .pos = 10};   /** @brief CTS. */
  static const field32_t LPUART1_ISR_CTSIF       = {.msk = 0x00000200U, .pos = 9};    /** @brief CTSIF. */
  static const field32_t LPUART1_ISR_TXE         = {.msk = 0x00000080U, .pos = 7};    /** @brief TXE. */
  static const field32_t LPUART1_ISR_TC          = {.msk = 0x00000040U, .pos = 6};    /** @brief TC. */
  static const field32_t LPUART1_ISR_RXNE        = {.msk = 0x00000020U, .pos = 5};    /** @brief RXNE. */
  static const field32_t LPUART1_ISR_IDLE        = {.msk = 0x00000010U, .pos = 4};    /** @brief IDLE. */
  static const field32_t LPUART1_ISR_ORE         = {.msk = 0x00000008U, .pos = 3};    /** @brief ORE. */
  static const field32_t LPUART1_ISR_NE          = {.msk = 0x00000004U, .pos = 2};    /** @brief NE. */
  static const field32_t LPUART1_ISR_FE          = {.msk = 0x00000002U, .pos = 1};    /** @brief FE. */
  static const field32_t LPUART1_ISR_PE          = {.msk = 0x00000001U, .pos = 0};    /** @brief PE. */
  static const field32_t LPUART1_ICR_WUCF        = {.msk = 0x00100000U, .pos = 20};   /** @brief Wakeup from stop mode clear flag. */
  static const field32_t LPUART1_ICR_CMCF        = {.msk = 0x00020000U, .pos = 17};   /** @brief Character match clear flag. */
  static const field32_t LPUART1_ICR_CTSCF       = {.msk = 0x00000200U, .pos = 9};    /** @brief CTS clear flag. */
  static const field32_t LPUART1_ICR_TCCF        = {.msk = 0x00000040U, .pos = 6};    /** @brief Transmission complete clear flag. */
  static const field32_t LPUART1_ICR_IDLECF      = {.msk = 0x00000010U, .pos = 4};    /** @brief Idle line detected clear flag. */
  static const field32_t LPUART1_ICR_ORECF       = {.msk = 0x00000008U, .pos = 3};    /** @brief Overrun error clear flag. */
  static const field32_t LPUART1_ICR_NCF         = {.msk = 0x00000004U, .pos = 2};    /** @brief Noise detected clear flag. */
  static const field32_t LPUART1_ICR_FECF        = {.msk = 0x00000002U, .pos = 1};    /** @brief Framing error clear flag. */
  static const field32_t LPUART1_ICR_PECF        = {.msk = 0x00000001U, .pos = 0};    /** @brief Parity error clear flag. */
  static const field32_t LPUART1_RDR_RDR         = {.msk = 0x000001FFU, .pos = 0};    /** @brief Receive data value. */
  static const field32_t LPUART1_TDR_TDR         = {.msk = 0x000001FFU, .pos = 0};    /** @brief Transmit data value. */
  static const field32_t LPUART1_PRESC_PRESCALER = {.msk = 0x0000000FU, .pos = 0};    /** @brief Clock prescaler. */

  /**** Enumerated LPUART1 Register Field Definitions ****/

  static field32_t const LPUART1_CRx_Mx[2] = {
    [0] = {.msk = 0x00001000U, .pos = 12},   /** @brief Word length. */
    [1] = {.msk = 0x10000000U, .pos = 28},   /** @brief Word length. */
  };

  /************************************************************************************************
   * SYSCFG Definitions
   ************************************************************************************************/

  /**** SYSCFG Register Definitions ****/

  static const rw_reg32_t SYSCFG_PMCR  = (rw_reg32_t)0x58000404U;   /** @brief Peripheral mode configuration register. */
  static const rw_reg32_t SYSCFG_CCCSR = (rw_reg32_t)0x58000420U;   /** @brief Compensation cell control/status register. */
  static const ro_reg32_t SYSCFG_CCVR  = (ro_reg32_t)0x58000424U;   /** @brief SYSCFG compensation cell value register. */
  static const rw_reg32_t SYSCFG_CCCR  = (rw_reg32_t)0x58000428U;   /** @brief SYSCFG compensation cell code register. */
  static const ro_reg32_t SYSCFG_PKGR  = (ro_reg32_t)0x58000524U;   /** @brief SYSCFG package register. */

  /**** Enumerated SYSCFG Register Definitions ****/

  static const rw_reg32_t SYSCFG_EXTICRx[5] = {
    [1] = (rw_reg32_t)0x58000408U,   /** @brief External interrupt configuration register 1. */
    [2] = (rw_reg32_t)0x5800040CU,   /** @brief External interrupt configuration register 2. */
    [3] = (rw_reg32_t)0x58000410U,   /** @brief External interrupt configuration register 3. */
    [4] = (rw_reg32_t)0x58000414U,   /** @brief External interrupt configuration register 4. */
  };

  static const ro_reg32_t SYSCFG_URx[18] = {
    [0]  = (ro_reg32_t)0x58000700U,   /** @brief SYSCFG user register 0. */
    [2]  = (ro_reg32_t)0x58000708U,   /** @brief SYSCFG user register 2. */
    [3]  = (ro_reg32_t)0x5800070CU,   /** @brief SYSCFG user register 3. */
    [4]  = (ro_reg32_t)0x58000710U,   /** @brief SYSCFG user register 4. */
    [5]  = (ro_reg32_t)0x58000714U,   /** @brief SYSCFG user register 5. */
    [6]  = (ro_reg32_t)0x58000718U,   /** @brief SYSCFG user register 6. */
    [7]  = (ro_reg32_t)0x5800071CU,   /** @brief SYSCFG user register 7. */
    [8]  = (ro_reg32_t)0x58000720U,   /** @brief SYSCFG user register 8. */
    [9]  = (ro_reg32_t)0x58000724U,   /** @brief SYSCFG user register 9. */
    [10] = (ro_reg32_t)0x58000728U,   /** @brief SYSCFG user register 10. */
    [11] = (ro_reg32_t)0x5800072CU,   /** @brief SYSCFG user register 11. */
    [12] = (ro_reg32_t)0x58000730U,   /** @brief SYSCFG user register 12. */
    [13] = (ro_reg32_t)0x58000734U,   /** @brief SYSCFG user register 13. */
    [14] = (ro_reg32_t)0x58000738U,   /** @brief SYSCFG user register 14. */
    [15] = (ro_reg32_t)0x5800073CU,   /** @brief SYSCFG user register 15. */
    [16] = (ro_reg32_t)0x58000740U,   /** @brief SYSCFG user register 16. */
    [17] = (ro_reg32_t)0x58000744U,   /** @brief SYSCFG user register 17. */
  };

  /**** SYSCFG Register Field Definitions ****/

  static const field32_t SYSCFG_PMCR_BOOSTE = {.msk = 0x00000100U, .pos = 8};    /** @brief Booster enable. */
  static const field32_t SYSCFG_PMCR_EPIS   = {.msk = 0x00E00000U, .pos = 21};   /** @brief Ethernet PHY interface selection. */
  static const field32_t SYSCFG_CCCSR_EN    = {.msk = 0x00000001U, .pos = 0};    /** @brief Enable. */
  static const field32_t SYSCFG_CCCSR_CS    = {.msk = 0x00000002U, .pos = 1};    /** @brief Code selection. */
  static const field32_t SYSCFG_CCCSR_READY = {.msk = 0x00000100U, .pos = 8};    /** @brief Compensation cell ready flag. */
  static const field32_t SYSCFG_CCCSR_HSLV  = {.msk = 0x00010000U, .pos = 16};   /** @brief High-speed at low-voltage. */
  static const field32_t SYSCFG_CCVR_NCV    = {.msk = 0x0000000FU, .pos = 0};    /** @brief NMOS compensation value. */
  static const field32_t SYSCFG_CCVR_PCV    = {.msk = 0x000000F0U, .pos = 4};    /** @brief PMOS compensation value. */
  static const field32_t SYSCFG_CCCR_NCC    = {.msk = 0x0000000FU, .pos = 0};    /** @brief NMOS compensation code. */
  static const field32_t SYSCFG_CCCR_PCC    = {.msk = 0x000000F0U, .pos = 4};    /** @brief PMOS compensation code. */
  static const field32_t SYSCFG_PKGR_PKG    = {.msk = 0x0000000FU, .pos = 0};    /** @brief Package. */
  static const field32_t SYSCFG_URx_BKS     = {.msk = 0x00000001U, .pos = 0};    /** @brief Bank swap. */
  static const field32_t SYSCFG_URx_RDP     = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Readout protection. */

  /**** Enumerated SYSCFG Register Field Definitions ****/

  static field32_t const SYSCFG_PMCR_I2CxFMP[5] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief I2C1 fm+. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief I2C2 fm+. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief I2C3 fm+. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief I2C4 fm+. */
  };

  static field32_t const SYSCFG_PMCR_PBxFMP[10] = {
    [6]  = {.msk = 0x00000010U, .pos = 4},   /** @brief PB(6) fm+. */
    [7]  = {.msk = 0x00000020U, .pos = 5},   /** @brief PB(7) fast mode plus. */
    [8]  = {.msk = 0x00000040U, .pos = 6},   /** @brief PB(8) fast mode plus. */
    [9]  = {.msk = 0x00000080U, .pos = 7},   /** @brief PB(9) fm+. */
  };

  static field32_t const SYSCFG_PMCR_PAxSO[2] = {
    [0] = {.msk = 0x01000000U, .pos = 24},   /** @brief PA0 switch open. */
    [1] = {.msk = 0x02000000U, .pos = 25},   /** @brief PA1 switch open. */
  };

  static field32_t const SYSCFG_PMCR_PCxSO[4] = {
    [2] = {.msk = 0x04000000U, .pos = 26},   /** @brief PC2 switch open. */
    [3] = {.msk = 0x08000000U, .pos = 27},   /** @brief PC3 switch open. */
  };

  static field32_t const SYSCFG_EXTICRx_EXTIx[4] = {
    [0] = {.msk = 0x0000000FU, .pos = 0},    /** @brief EXTI x configuration (x = 0 to 3). */
    [1] = {.msk = 0x000000F0U, .pos = 4},    /** @brief EXTI x configuration (x = 0 to 3). */
    [2] = {.msk = 0x00000F00U, .pos = 8},    /** @brief EXTI x configuration (x = 0 to 3). */
    [3] = {.msk = 0x0000F000U, .pos = 12},   /** @brief EXTI x configuration (x = 0 to 3). */
  };

  /************************************************************************************************
   * EXTI Definitions
   ************************************************************************************************/

  /**** Enumerated EXTI Register Definitions ****/

  static const rw_reg32_t EXTI_RTSRx[4] = {
    [1] = (rw_reg32_t)0x58000000U,   /** @brief EXTI rising trigger selection register. */
    [2] = (rw_reg32_t)0x58000020U,   /** @brief EXTI rising trigger selection register. */
    [3] = (rw_reg32_t)0x58000040U,   /** @brief EXTI rising trigger selection register. */
  };

  static const rw_reg32_t EXTI_FTSRx[4] = {
    [1] = (rw_reg32_t)0x58000004U,   /** @brief EXTI falling trigger selection register. */
    [2] = (rw_reg32_t)0x58000024U,   /** @brief EXTI falling trigger selection register. */
    [3] = (rw_reg32_t)0x58000044U,   /** @brief EXTI falling trigger selection register. */
  };

  static const rw_reg32_t EXTI_SWIERx[4] = {
    [1] = (rw_reg32_t)0x58000008U,   /** @brief EXTI software interrupt event register. */
    [2] = (rw_reg32_t)0x58000028U,   /** @brief EXTI software interrupt event register. */
    [3] = (rw_reg32_t)0x58000048U,   /** @brief EXTI software interrupt event register. */
  };

  static const rw_reg32_t EXTI_D3PMRx[4] = {
    [1] = (rw_reg32_t)0x5800000CU,   /** @brief EXTI D3 pending mask register. */
    [2] = (rw_reg32_t)0x5800002CU,   /** @brief EXTI D3 pending mask register. */
    [3] = (rw_reg32_t)0x5800004CU,   /** @brief EXTI D3 pending mask register. */
  };

  static const rw_reg32_t EXTI_D3PCRxL[3] = {
    [1] = (rw_reg32_t)0x58000010U,   /** @brief EXTI D3 pending clear selection register low. */
    [2] = (rw_reg32_t)0x58000030U,   /** @brief EXTI D3 pending clear selection register low. */
  };

  static const rw_reg32_t EXTI_D3PCRxH[4] = {
    [1] = (rw_reg32_t)0x58000014U,   /** @brief EXTI D3 pending clear selection register high. */
    [2] = (rw_reg32_t)0x58000034U,   /** @brief EXTI D3 pending clear selection register high. */
    [3] = (rw_reg32_t)0x58000054U,   /** @brief EXTI D3 pending clear selection register high. */
  };

  static const rw_reg32_t EXTI_CPUIMRx[4] = {
    [1] = (rw_reg32_t)0x58000080U,   /** @brief EXTI interrupt mask register. */
    [2] = (rw_reg32_t)0x58000090U,   /** @brief EXTI interrupt mask register. */
    [3] = (rw_reg32_t)0x580000A0U,   /** @brief EXTI interrupt mask register. */
  };

  static const rw_reg32_t EXTI_CPUEMRx[4] = {
    [1] = (rw_reg32_t)0x58000084U,   /** @brief EXTI event mask register. */
    [2] = (rw_reg32_t)0x58000094U,   /** @brief EXTI event mask register. */
    [3] = (rw_reg32_t)0x580000A4U,   /** @brief EXTI event mask register. */
  };

  static const rw_reg32_t EXTI_CPUPRx[4] = {
    [1] = (rw_reg32_t)0x58000088U,   /** @brief EXTI pending register. */
    [2] = (rw_reg32_t)0x58000098U,   /** @brief EXTI pending register. */
    [3] = (rw_reg32_t)0x580000A8U,   /** @brief EXTI pending register. */
  };

  /**** Enumerated EXTI Register Field Definitions ****/

  static field32_t const EXTI_RTSRx_TRx[22] = {
    [0]  = {.msk = 0x00000001U, .pos = 0},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [1]  = {.msk = 0x00000002U, .pos = 1},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [2]  = {.msk = 0x00000004U, .pos = 2},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [3]  = {.msk = 0x00000008U, .pos = 3},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [4]  = {.msk = 0x00000010U, .pos = 4},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [5]  = {.msk = 0x00000020U, .pos = 5},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [6]  = {.msk = 0x00000040U, .pos = 6},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [7]  = {.msk = 0x00000080U, .pos = 7},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [8]  = {.msk = 0x00000100U, .pos = 8},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [9]  = {.msk = 0x00000200U, .pos = 9},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [10] = {.msk = 0x00000400U, .pos = 10},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [11] = {.msk = 0x00000800U, .pos = 11},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [12] = {.msk = 0x00001000U, .pos = 12},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [13] = {.msk = 0x00002000U, .pos = 13},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [14] = {.msk = 0x00004000U, .pos = 14},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [15] = {.msk = 0x00008000U, .pos = 15},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [16] = {.msk = 0x00010000U, .pos = 16},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [17] = {.msk = 0x00020000U, .pos = 17},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [18] = {.msk = 0x00040000U, .pos = 18},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [19] = {.msk = 0x00080000U, .pos = 19},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [20] = {.msk = 0x00100000U, .pos = 20},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [21] = {.msk = 0x00200000U, .pos = 21},   /** @brief Rising trigger event configuration bit of configurable event input. */
  };

  static field32_t const EXTI_SWIERx_SWIERx[22] = {
    [0]  = {.msk = 0x00000001U, .pos = 0},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [1]  = {.msk = 0x00000002U, .pos = 1},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [2]  = {.msk = 0x00000004U, .pos = 2},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [3]  = {.msk = 0x00000008U, .pos = 3},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [4]  = {.msk = 0x00000010U, .pos = 4},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [5]  = {.msk = 0x00000020U, .pos = 5},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [6]  = {.msk = 0x00000040U, .pos = 6},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [7]  = {.msk = 0x00000080U, .pos = 7},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [8]  = {.msk = 0x00000100U, .pos = 8},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [9]  = {.msk = 0x00000200U, .pos = 9},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [10] = {.msk = 0x00000400U, .pos = 10},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [11] = {.msk = 0x00000800U, .pos = 11},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [12] = {.msk = 0x00001000U, .pos = 12},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [13] = {.msk = 0x00002000U, .pos = 13},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [14] = {.msk = 0x00004000U, .pos = 14},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [15] = {.msk = 0x00008000U, .pos = 15},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [16] = {.msk = 0x00010000U, .pos = 16},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [17] = {.msk = 0x00020000U, .pos = 17},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [18] = {.msk = 0x00040000U, .pos = 18},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [19] = {.msk = 0x00080000U, .pos = 19},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [20] = {.msk = 0x00100000U, .pos = 20},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [21] = {.msk = 0x00200000U, .pos = 21},   /** @brief Rising trigger event configuration bit of configurable event input. */
  };

  static field32_t const EXTI_D3PMRx_MRx[26] = {
    [0]  = {.msk = 0x00000001U, .pos = 0},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [1]  = {.msk = 0x00000002U, .pos = 1},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [2]  = {.msk = 0x00000004U, .pos = 2},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [3]  = {.msk = 0x00000008U, .pos = 3},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [4]  = {.msk = 0x00000010U, .pos = 4},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [5]  = {.msk = 0x00000020U, .pos = 5},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [6]  = {.msk = 0x00000040U, .pos = 6},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [7]  = {.msk = 0x00000080U, .pos = 7},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [8]  = {.msk = 0x00000100U, .pos = 8},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [9]  = {.msk = 0x00000200U, .pos = 9},    /** @brief Rising trigger event configuration bit of configurable event input. */
    [10] = {.msk = 0x00000400U, .pos = 10},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [11] = {.msk = 0x00000800U, .pos = 11},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [12] = {.msk = 0x00001000U, .pos = 12},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [13] = {.msk = 0x00002000U, .pos = 13},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [14] = {.msk = 0x00004000U, .pos = 14},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [15] = {.msk = 0x00008000U, .pos = 15},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [19] = {.msk = 0x00080000U, .pos = 19},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [20] = {.msk = 0x00100000U, .pos = 20},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [21] = {.msk = 0x00200000U, .pos = 21},   /** @brief Rising trigger event configuration bit of configurable event input. */
    [25] = {.msk = 0x02000000U, .pos = 25},   /** @brief Rising trigger event configuration bit of configurable event input. */
  };

  static field32_t const EXTI_D3PCRxL_PCSx[16] = {
    [0]  = {.msk = 0x00000003U, .pos = 0},    /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2). */
    [1]  = {.msk = 0x0000000CU, .pos = 2},    /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2). */
    [2]  = {.msk = 0x00000030U, .pos = 4},    /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2). */
    [3]  = {.msk = 0x000000C0U, .pos = 6},    /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2). */
    [4]  = {.msk = 0x00000300U, .pos = 8},    /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2). */
    [5]  = {.msk = 0x00000C00U, .pos = 10},   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2). */
    [6]  = {.msk = 0x00003000U, .pos = 12},   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2). */
    [7]  = {.msk = 0x0000C000U, .pos = 14},   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2). */
    [8]  = {.msk = 0x00030000U, .pos = 16},   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2). */
    [9]  = {.msk = 0x000C0000U, .pos = 18},   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2). */
    [10] = {.msk = 0x00300000U, .pos = 20},   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2). */
    [11] = {.msk = 0x00C00000U, .pos = 22},   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2). */
    [12] = {.msk = 0x03000000U, .pos = 24},   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2). */
    [13] = {.msk = 0x0C000000U, .pos = 26},   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2). */
    [14] = {.msk = 0x30000000U, .pos = 28},   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2). */
    [15] = {.msk = 0xC0000000U, .pos = 30},   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2). */
  };

  static field32_t const EXTI_CPUPRx_PRx[22] = {
    [0]  = {.msk = 0x00000001U, .pos = 0},    /** @brief CPU event mask on event input x. */
    [1]  = {.msk = 0x00000002U, .pos = 1},    /** @brief CPU event mask on event input x. */
    [2]  = {.msk = 0x00000004U, .pos = 2},    /** @brief CPU event mask on event input x. */
    [3]  = {.msk = 0x00000008U, .pos = 3},    /** @brief CPU event mask on event input x. */
    [4]  = {.msk = 0x00000010U, .pos = 4},    /** @brief CPU event mask on event input x. */
    [5]  = {.msk = 0x00000020U, .pos = 5},    /** @brief CPU event mask on event input x. */
    [6]  = {.msk = 0x00000040U, .pos = 6},    /** @brief CPU event mask on event input x. */
    [7]  = {.msk = 0x00000080U, .pos = 7},    /** @brief CPU event mask on event input x. */
    [8]  = {.msk = 0x00000100U, .pos = 8},    /** @brief CPU event mask on event input x. */
    [9]  = {.msk = 0x00000200U, .pos = 9},    /** @brief CPU event mask on event input x. */
    [10] = {.msk = 0x00000400U, .pos = 10},   /** @brief CPU event mask on event input x. */
    [11] = {.msk = 0x00000800U, .pos = 11},   /** @brief CPU event mask on event input x. */
    [12] = {.msk = 0x00001000U, .pos = 12},   /** @brief CPU event mask on event input x. */
    [13] = {.msk = 0x00002000U, .pos = 13},   /** @brief CPU event mask on event input x. */
    [14] = {.msk = 0x00004000U, .pos = 14},   /** @brief CPU event mask on event input x. */
    [15] = {.msk = 0x00008000U, .pos = 15},   /** @brief CPU event mask on event input x. */
    [16] = {.msk = 0x00010000U, .pos = 16},   /** @brief CPU event mask on event input x. */
    [17] = {.msk = 0x00020000U, .pos = 17},   /** @brief CPU event mask on event input x. */
    [18] = {.msk = 0x00040000U, .pos = 18},   /** @brief CPU event mask on event input x. */
    [19] = {.msk = 0x00080000U, .pos = 19},   /** @brief CPU event mask on event input x. */
    [20] = {.msk = 0x00100000U, .pos = 20},   /** @brief CPU event mask on event input x. */
    [21] = {.msk = 0x00200000U, .pos = 21},   /** @brief CPU event mask on event input x. */
  };

  /************************************************************************************************
   * DELAY_BLOCK_SDMMCx Definitions
   ************************************************************************************************/

  /**** Enumerated DELAY_BLOCK_SDMMCx Register Definitions ****/

  static const rw_reg32_t DELAY_BLOCK_SDMMCx_CR[3] = {
    [1] = (rw_reg32_t)0x52008000U,   /** @brief DLYB control register. */
    [2] = (rw_reg32_t)0x48022800U,   /** @brief DLYB control register. */
  };

  static const rw_reg32_t DELAY_BLOCK_SDMMCx_CFGR[3] = {
    [1] = (rw_reg32_t)0x52008004U,   /** @brief DLYB configuration register. */
    [2] = (rw_reg32_t)0x48022804U,   /** @brief DLYB configuration register. */
  };

  /**** DELAY_BLOCK_SDMMCx Register Field Definitions ****/

  static const field32_t DELAY_BLOCK_SDMMCx_CR_DEN    = {.msk = 0x00000001U, .pos = 0};    /** @brief Delay block enable bit. */
  static const field32_t DELAY_BLOCK_SDMMCx_CR_SEN    = {.msk = 0x00000002U, .pos = 1};    /** @brief Sampler length enable bit. */
  static const field32_t DELAY_BLOCK_SDMMCx_CFGR_SEL  = {.msk = 0x0000000FU, .pos = 0};    /** @brief Select the phase for the output clock. */
  static const field32_t DELAY_BLOCK_SDMMCx_CFGR_UNIT = {.msk = 0x00007F00U, .pos = 8};    /** @brief Delay defines the delay of a unit delay cell. */
  static const field32_t DELAY_BLOCK_SDMMCx_CFGR_LNG  = {.msk = 0x0FFF0000U, .pos = 16};   /** @brief Delay line length value. */
  static const field32_t DELAY_BLOCK_SDMMCx_CFGR_LNGF = {.msk = 0x80000000U, .pos = 31};   /** @brief Length valid flag. */

  /************************************************************************************************
   * DELAY_BLOCK_QUADSPI Definitions
   ************************************************************************************************/

  /**** DELAY_BLOCK_QUADSPI Register Definitions ****/

  static const rw_reg32_t DELAY_BLOCK_QUADSPI_CR   = (rw_reg32_t)0x52006000U;   /** @brief DLYB control register. */
  static const rw_reg32_t DELAY_BLOCK_QUADSPI_CFGR = (rw_reg32_t)0x52006004U;   /** @brief DLYB configuration register. */

  /**** DELAY_BLOCK_QUADSPI Register Field Definitions ****/

  static const field32_t DELAY_BLOCK_QUADSPI_CR_DEN    = {.msk = 0x00000001U, .pos = 0};    /** @brief Delay block enable bit. */
  static const field32_t DELAY_BLOCK_QUADSPI_CR_SEN    = {.msk = 0x00000002U, .pos = 1};    /** @brief Sampler length enable bit. */
  static const field32_t DELAY_BLOCK_QUADSPI_CFGR_SEL  = {.msk = 0x0000000FU, .pos = 0};    /** @brief Select the phase for the output clock. */
  static const field32_t DELAY_BLOCK_QUADSPI_CFGR_UNIT = {.msk = 0x00007F00U, .pos = 8};    /** @brief Delay defines the delay of a unit delay cell. */
  static const field32_t DELAY_BLOCK_QUADSPI_CFGR_LNG  = {.msk = 0x0FFF0000U, .pos = 16};   /** @brief Delay line length value. */
  static const field32_t DELAY_BLOCK_QUADSPI_CFGR_LNGF = {.msk = 0x80000000U, .pos = 31};   /** @brief Length valid flag. */

  /************************************************************************************************
   * FLASH Definitions
   ************************************************************************************************/

  /**** FLASH Register Definitions ****/

  static const rw_reg32_t FLASH_ACR        = (rw_reg32_t)0x52002000U;   /** @brief Access control register. */
  static const rw_reg32_t FLASH_ACR_       = (rw_reg32_t)0x52002100U;   /** @brief Access control register. */
  static const rw_reg32_t FLASH_OPTKEYR    = (rw_reg32_t)0x52002008U;   /** @brief FLASH option key register. */
  static const rw_reg32_t FLASH_OPTKEYR_   = (rw_reg32_t)0x52002108U;   /** @brief FLASH option key register. */
  static const rw_reg32_t FLASH_OPTCR      = (rw_reg32_t)0x52002018U;   /** @brief FLASH option control register. */
  static const rw_reg32_t FLASH_OPTCR_     = (rw_reg32_t)0x52002118U;   /** @brief FLASH option control register. */
  static const rw_reg32_t FLASH_OPTSR_CUR_ = (rw_reg32_t)0x5200211CU;   /** @brief FLASH option status register. */
  static const rw_reg32_t FLASH_OPTSR_CUR  = (rw_reg32_t)0x5200201CU;   /** @brief FLASH option status register. */
  static const rw_reg32_t FLASH_OPTSR_PRG  = (rw_reg32_t)0x52002020U;   /** @brief FLASH option status register. */
  static const rw_reg32_t FLASH_OPTSR_PRG_ = (rw_reg32_t)0x52002120U;   /** @brief FLASH option status register. */
  static const rw_reg32_t FLASH_OPTCCR_    = (rw_reg32_t)0x52002124U;   /** @brief FLASH option clear control register. */
  static const rw_reg32_t FLASH_OPTCCR     = (rw_reg32_t)0x52002024U;   /** @brief FLASH option clear control register. */
  static const ro_reg32_t FLASH_BOOT_CURR  = (ro_reg32_t)0x52002040U;   /** @brief FLASH register with boot address. */
  static const ro_reg32_t FLASH_BOOT_PRGR  = (ro_reg32_t)0x52002044U;   /** @brief FLASH register with boot address. */
  static const rw_reg32_t FLASH_CRCDATAR   = (rw_reg32_t)0x5200205CU;   /** @brief FLASH CRC data register. */

  /**** Enumerated FLASH Register Definitions ****/

  static const rw_reg32_t FLASH_KEYRx[3] = {
    [1] = (rw_reg32_t)0x52002004U,   /** @brief FLASH key register for bank 1. */
    [2] = (rw_reg32_t)0x52002104U,   /** @brief FLASH key register for bank 2. */
  };

  static const rw_reg32_t FLASH_CRx[3] = {
    [1] = (rw_reg32_t)0x5200200CU,   /** @brief FLASH control register for bank 1. */
    [2] = (rw_reg32_t)0x5200210CU,   /** @brief FLASH control register for bank 2. */
  };

  static const rw_reg32_t FLASH_SRx[3] = {
    [1] = (rw_reg32_t)0x52002010U,   /** @brief FLASH status register for bank 1. */
    [2] = (rw_reg32_t)0x52002110U,   /** @brief FLASH status register for bank 2. */
  };

  static const rw_reg32_t FLASH_CCRx[3] = {
    [1] = (rw_reg32_t)0x52002014U,   /** @brief FLASH clear control register for bank 1. */
    [2] = (rw_reg32_t)0x52002114U,   /** @brief FLASH clear control register for bank 2. */
  };

  static const ro_reg32_t FLASH_PRAR_CURx[3] = {
    [1] = (ro_reg32_t)0x52002028U,   /** @brief FLASH protection address for bank 1. */
    [2] = (ro_reg32_t)0x52002128U,   /** @brief FLASH protection address for bank 1. */
  };

  static const rw_reg32_t FLASH_PRAR_PRGx[3] = {
    [1] = (rw_reg32_t)0x5200202CU,   /** @brief FLASH protection address for bank 1. */
    [2] = (rw_reg32_t)0x5200202CU,   /** @brief FLASH protection address for bank 2. */
  };

  static const rw_reg32_t FLASH_SCAR_CURx[3] = {
    [1] = (rw_reg32_t)0x52002030U,   /** @brief FLASH secure address for bank 1. */
    [2] = (rw_reg32_t)0x52002130U,   /** @brief FLASH secure address for bank 2. */
  };

  static const rw_reg32_t FLASH_SCAR_PRGx[3] = {
    [1] = (rw_reg32_t)0x52002034U,   /** @brief FLASH secure address for bank 1. */
    [2] = (rw_reg32_t)0x52002134U,   /** @brief FLASH secure address for bank 2. */
  };

  static const ro_reg32_t FLASH_WPSN_CURxR[3] = {
    [1] = (ro_reg32_t)0x52002038U,   /** @brief FLASH write sector protection for bank 1. */
    [2] = (ro_reg32_t)0x52002138U,   /** @brief FLASH write sector protection for bank 2. */
  };

  static const rw_reg32_t FLASH_WPSN_PRGxR[3] = {
    [1] = (rw_reg32_t)0x5200203CU,   /** @brief FLASH write sector protection for bank 1. */
    [2] = (rw_reg32_t)0x5200213CU,   /** @brief FLASH write sector protection for bank 2. */
  };

  static const rw_reg32_t FLASH_CRCCRx[3] = {
    [1] = (rw_reg32_t)0x52002050U,   /** @brief FLASH CRC control register for bank 1. */
    [2] = (rw_reg32_t)0x52002150U,   /** @brief FLASH CRC control register for bank 1. */
  };

  static const rw_reg32_t FLASH_CRCSADDxR[3] = {
    [1] = (rw_reg32_t)0x52002054U,   /** @brief FLASH CRC start address register for bank 1. */
    [2] = (rw_reg32_t)0x52002154U,   /** @brief FLASH CRC start address register for bank 2. */
  };

  static const rw_reg32_t FLASH_CRCEADDxR[3] = {
    [1] = (rw_reg32_t)0x52002058U,   /** @brief FLASH CRC end address register for bank 1. */
    [2] = (rw_reg32_t)0x52002158U,   /** @brief FLASH CRC end address register for bank 2. */
  };

  static const ro_reg32_t FLASH_ECC_FAxR[3] = {
    [1] = (ro_reg32_t)0x52002060U,   /** @brief FLASH ECC fail address for bank 1. */
    [2] = (ro_reg32_t)0x52002160U,   /** @brief FLASH ECC fail address for bank 2. */
  };

  /**** FLASH Register Field Definitions ****/

  static const field32_t FLASH_ACR_LATENCY                = {.msk = 0x00000007U, .pos = 0};    /** @brief Read latency. */
  static const field32_t FLASH_ACR_WRHIGHFREQ             = {.msk = 0x00000030U, .pos = 4};    /** @brief Flash signal delay. */
  static const field32_t FLASH_ACR__LATENCY               = {.msk = 0x00000007U, .pos = 0};    /** @brief Read latency. */
  static const field32_t FLASH_ACR__WRHIGHFREQ            = {.msk = 0x00000030U, .pos = 4};    /** @brief Flash signal delay. */
  static const field32_t FLASH_CRx_LOCK1                  = {.msk = 0x00000001U, .pos = 0};    /** @brief Bank 1 configuration lock bit. */
  static const field32_t FLASH_CRx_PG1                    = {.msk = 0x00000002U, .pos = 1};    /** @brief Bank 1 program enable bit. */
  static const field32_t FLASH_CRx_SER1                   = {.msk = 0x00000004U, .pos = 2};    /** @brief Bank 1 sector erase request. */
  static const field32_t FLASH_CRx_BER1                   = {.msk = 0x00000008U, .pos = 3};    /** @brief Bank 1 erase request. */
  static const field32_t FLASH_CRx_PSIZE1                 = {.msk = 0x00000030U, .pos = 4};    /** @brief Bank 1 program size. */
  static const field32_t FLASH_CRx_FW1                    = {.msk = 0x00000040U, .pos = 6};    /** @brief Bank 1 write forcing control bit. */
  static const field32_t FLASH_CRx_START1                 = {.msk = 0x00000080U, .pos = 7};    /** @brief Bank 1 bank or sector erase start control bit. */
  static const field32_t FLASH_CRx_SNB1                   = {.msk = 0x00000700U, .pos = 8};    /** @brief Bank 1 sector erase selection number. */
  static const field32_t FLASH_CRx_CRC_EN                 = {.msk = 0x00008000U, .pos = 15};   /** @brief Bank 1 CRC control bit. */
  static const field32_t FLASH_CRx_EOPIE1                 = {.msk = 0x00010000U, .pos = 16};   /** @brief Bank 1 end-of-program interrupt control bit. */
  static const field32_t FLASH_CRx_WRPERRIE1              = {.msk = 0x00020000U, .pos = 17};   /** @brief Bank 1 write protection error interrupt enable bit. */
  static const field32_t FLASH_CRx_PGSERRIE1              = {.msk = 0x00040000U, .pos = 18};   /** @brief Bank 1 programming sequence error interrupt enable bit. */
  static const field32_t FLASH_CRx_STRBERRIE1             = {.msk = 0x00080000U, .pos = 19};   /** @brief Bank 1 strobe error interrupt enable bit. */
  static const field32_t FLASH_CRx_INCERRIE1              = {.msk = 0x00200000U, .pos = 21};   /** @brief Bank 1 inconsistency error interrupt enable bit. */
  static const field32_t FLASH_CRx_OPERRIE1               = {.msk = 0x00400000U, .pos = 22};   /** @brief Bank 1 write/erase error interrupt enable bit. */
  static const field32_t FLASH_CRx_RDPERRIE1              = {.msk = 0x00800000U, .pos = 23};   /** @brief Bank 1 read protection error interrupt enable bit. */
  static const field32_t FLASH_CRx_RDSERRIE1              = {.msk = 0x01000000U, .pos = 24};   /** @brief Bank 1 secure error interrupt enable bit. */
  static const field32_t FLASH_CRx_SNECCERRIE1            = {.msk = 0x02000000U, .pos = 25};   /** @brief Bank 1 ECC single correction error interrupt enable bit. */
  static const field32_t FLASH_CRx_DBECCERRIE1            = {.msk = 0x04000000U, .pos = 26};   /** @brief Bank 1 ECC double detection error interrupt enable bit. */
  static const field32_t FLASH_CRx_CRCENDIE1              = {.msk = 0x08000000U, .pos = 27};   /** @brief Bank 1 end of CRC calculation interrupt enable bit. */
  static const field32_t FLASH_SRx_BSY1                   = {.msk = 0x00000001U, .pos = 0};    /** @brief Bank 1 ongoing program flag. */
  static const field32_t FLASH_SRx_WBNE1                  = {.msk = 0x00000002U, .pos = 1};    /** @brief Bank 1 write buffer not empty flag. */
  static const field32_t FLASH_SRx_QW1                    = {.msk = 0x00000004U, .pos = 2};    /** @brief Bank 1 wait queue flag. */
  static const field32_t FLASH_SRx_CRC_BUSY1              = {.msk = 0x00000008U, .pos = 3};    /** @brief Bank 1 CRC busy flag. */
  static const field32_t FLASH_SRx_EOP1                   = {.msk = 0x00010000U, .pos = 16};   /** @brief Bank 1 end-of-program flag. */
  static const field32_t FLASH_SRx_WRPERR1                = {.msk = 0x00020000U, .pos = 17};   /** @brief Bank 1 write protection error flag. */
  static const field32_t FLASH_SRx_PGSERR1                = {.msk = 0x00040000U, .pos = 18};   /** @brief Bank 1 programming sequence error flag. */
  static const field32_t FLASH_SRx_STRBERR1               = {.msk = 0x00080000U, .pos = 19};   /** @brief Bank 1 strobe error flag. */
  static const field32_t FLASH_SRx_INCERR1                = {.msk = 0x00200000U, .pos = 21};   /** @brief Bank 1 inconsistency error flag. */
  static const field32_t FLASH_SRx_OPERR1                 = {.msk = 0x00400000U, .pos = 22};   /** @brief Bank 1 write/erase error flag. */
  static const field32_t FLASH_SRx_RDPERR1                = {.msk = 0x00800000U, .pos = 23};   /** @brief Bank 1 read protection error flag. */
  static const field32_t FLASH_SRx_RDSERR1                = {.msk = 0x01000000U, .pos = 24};   /** @brief Bank 1 secure error flag. */
  static const field32_t FLASH_SRx_SNECCERR11             = {.msk = 0x02000000U, .pos = 25};   /** @brief Bank 1 single correction error flag. */
  static const field32_t FLASH_SRx_DBECCERR1              = {.msk = 0x04000000U, .pos = 26};   /** @brief Bank 1 ECC double detection error flag. */
  static const field32_t FLASH_SRx_CRCEND1                = {.msk = 0x08000000U, .pos = 27};   /** @brief Bank 1 crc-complete flag. */
  static const field32_t FLASH_CCRx_CLR_EOP1              = {.msk = 0x00010000U, .pos = 16};   /** @brief Bank 1 EOP1 flag clear bit. */
  static const field32_t FLASH_CCRx_CLR_WRPERR1           = {.msk = 0x00020000U, .pos = 17};   /** @brief Bank 1 WRPERR1 flag clear bit. */
  static const field32_t FLASH_CCRx_CLR_PGSERR1           = {.msk = 0x00040000U, .pos = 18};   /** @brief Bank 1 PGSERR1 flag clear bi. */
  static const field32_t FLASH_CCRx_CLR_STRBERR1          = {.msk = 0x00080000U, .pos = 19};   /** @brief Bank 1 STRBERR1 flag clear bit. */
  static const field32_t FLASH_CCRx_CLR_INCERR1           = {.msk = 0x00200000U, .pos = 21};   /** @brief Bank 1 INCERR1 flag clear bit. */
  static const field32_t FLASH_CCRx_CLR_OPERR1            = {.msk = 0x00400000U, .pos = 22};   /** @brief Bank 1 OPERR1 flag clear bit. */
  static const field32_t FLASH_CCRx_CLR_RDPERR1           = {.msk = 0x00800000U, .pos = 23};   /** @brief Bank 1 RDPERR1 flag clear bit. */
  static const field32_t FLASH_CCRx_CLR_RDSERR1           = {.msk = 0x01000000U, .pos = 24};   /** @brief Bank 1 RDSERR1 flag clear bit. */
  static const field32_t FLASH_CCRx_CLR_SNECCERR1         = {.msk = 0x02000000U, .pos = 25};   /** @brief Bank 1 SNECCERR1 flag clear bit. */
  static const field32_t FLASH_CCRx_CLR_DBECCERR1         = {.msk = 0x04000000U, .pos = 26};   /** @brief Bank 1 DBECCERR1 flag clear bit. */
  static const field32_t FLASH_CCRx_CLR_CRCEND1           = {.msk = 0x08000000U, .pos = 27};   /** @brief Bank 1 CRCEND1 flag clear bit. */
  static const field32_t FLASH_OPTCR_OPTLOCK              = {.msk = 0x00000001U, .pos = 0};    /** @brief FLASH_OPTCR lock option configuration bit. */
  static const field32_t FLASH_OPTCR_OPTSTART             = {.msk = 0x00000002U, .pos = 1};    /** @brief Option byte start change option configuration bit. */
  static const field32_t FLASH_OPTCR_MER                  = {.msk = 0x00000010U, .pos = 4};    /** @brief Flash mass erase enable bit. */
  static const field32_t FLASH_OPTCR_OPTCHANGEERRIE       = {.msk = 0x40000000U, .pos = 30};   /** @brief Option byte change error interrupt enable bit. */
  static const field32_t FLASH_OPTCR_SWAP_BANK            = {.msk = 0x80000000U, .pos = 31};   /** @brief Bank swapping configuration bit. */
  static const field32_t FLASH_OPTCR__OPTLOCK             = {.msk = 0x00000001U, .pos = 0};    /** @brief FLASH_OPTCR lock option configuration bit. */
  static const field32_t FLASH_OPTCR__OPTSTART            = {.msk = 0x00000002U, .pos = 1};    /** @brief Option byte start change option configuration bit. */
  static const field32_t FLASH_OPTCR__MER                 = {.msk = 0x00000010U, .pos = 4};    /** @brief Flash mass erase enable bit. */
  static const field32_t FLASH_OPTCR__OPTCHANGEERRIE      = {.msk = 0x40000000U, .pos = 30};   /** @brief Option byte change error interrupt enable bit. */
  static const field32_t FLASH_OPTCR__SWAP_BANK           = {.msk = 0x80000000U, .pos = 31};   /** @brief Bank swapping configuration bit. */
  static const field32_t FLASH_OPTSR_CUR__OPT_BUSY        = {.msk = 0x00000001U, .pos = 0};    /** @brief Option byte change ongoing flag. */
  static const field32_t FLASH_OPTSR_CUR__BOR_LEV         = {.msk = 0x0000000CU, .pos = 2};    /** @brief Brownout level option status bit. */
  static const field32_t FLASH_OPTSR_CUR__IWDG1_HW        = {.msk = 0x00000010U, .pos = 4};    /** @brief IWDG1 control option status bit. */
  static const field32_t FLASH_OPTSR_CUR__NRST_STOP_D1    = {.msk = 0x00000040U, .pos = 6};    /** @brief D1 dstop entry reset option status bit. */
  static const field32_t FLASH_OPTSR_CUR__NRST_STBY_D1    = {.msk = 0x00000080U, .pos = 7};    /** @brief D1 dstandby entry reset option status bit. */
  static const field32_t FLASH_OPTSR_CUR__RDP             = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Readout protection level option status byte. */
  static const field32_t FLASH_OPTSR_CUR__FZ_IWDG_STOP    = {.msk = 0x00020000U, .pos = 17};   /** @brief IWDG stop mode freeze option status bit. */
  static const field32_t FLASH_OPTSR_CUR__FZ_IWDG_SDBY    = {.msk = 0x00040000U, .pos = 18};   /** @brief IWDG standby mode freeze option status bit. */
  static const field32_t FLASH_OPTSR_CUR__ST_RAM_SIZE     = {.msk = 0x00180000U, .pos = 19};   /** @brief DTCM RAM size option status. */
  static const field32_t FLASH_OPTSR_CUR__SECURITY        = {.msk = 0x00200000U, .pos = 21};   /** @brief Security enable option status bit. */
  static const field32_t FLASH_OPTSR_CUR__RSS1            = {.msk = 0x04000000U, .pos = 26};   /** @brief User option bit 1. */
  static const field32_t FLASH_OPTSR_CUR__PERSO_OK        = {.msk = 0x10000000U, .pos = 28};   /** @brief Device personalization status bit. */
  static const field32_t FLASH_OPTSR_CUR__IO_HSLV         = {.msk = 0x20000000U, .pos = 29};   /** @brief I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V). */
  static const field32_t FLASH_OPTSR_CUR__OPTCHANGEERR    = {.msk = 0x40000000U, .pos = 30};   /** @brief Option byte change error flag. */
  static const field32_t FLASH_OPTSR_CUR__SWAP_BANK_OPT   = {.msk = 0x80000000U, .pos = 31};   /** @brief Bank swapping option status bit. */
  static const field32_t FLASH_OPTSR_CUR_OPT_BUSY         = {.msk = 0x00000001U, .pos = 0};    /** @brief Option byte change ongoing flag. */
  static const field32_t FLASH_OPTSR_CUR_BOR_LEV          = {.msk = 0x0000000CU, .pos = 2};    /** @brief Brownout level option status bit. */
  static const field32_t FLASH_OPTSR_CUR_IWDG1_HW         = {.msk = 0x00000010U, .pos = 4};    /** @brief IWDG1 control option status bit. */
  static const field32_t FLASH_OPTSR_CUR_NRST_STOP_D1     = {.msk = 0x00000040U, .pos = 6};    /** @brief D1 dstop entry reset option status bit. */
  static const field32_t FLASH_OPTSR_CUR_NRST_STBY_D1     = {.msk = 0x00000080U, .pos = 7};    /** @brief D1 dstandby entry reset option status bit. */
  static const field32_t FLASH_OPTSR_CUR_RDP              = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Readout protection level option status byte. */
  static const field32_t FLASH_OPTSR_CUR_FZ_IWDG_STOP     = {.msk = 0x00020000U, .pos = 17};   /** @brief IWDG stop mode freeze option status bit. */
  static const field32_t FLASH_OPTSR_CUR_FZ_IWDG_SDBY     = {.msk = 0x00040000U, .pos = 18};   /** @brief IWDG standby mode freeze option status bit. */
  static const field32_t FLASH_OPTSR_CUR_ST_RAM_SIZE      = {.msk = 0x00180000U, .pos = 19};   /** @brief DTCM RAM size option status. */
  static const field32_t FLASH_OPTSR_CUR_SECURITY         = {.msk = 0x00200000U, .pos = 21};   /** @brief Security enable option status bit. */
  static const field32_t FLASH_OPTSR_CUR_RSS1             = {.msk = 0x04000000U, .pos = 26};   /** @brief User option bit 1. */
  static const field32_t FLASH_OPTSR_CUR_PERSO_OK         = {.msk = 0x10000000U, .pos = 28};   /** @brief Device personalization status bit. */
  static const field32_t FLASH_OPTSR_CUR_IO_HSLV          = {.msk = 0x20000000U, .pos = 29};   /** @brief I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V). */
  static const field32_t FLASH_OPTSR_CUR_OPTCHANGEERR     = {.msk = 0x40000000U, .pos = 30};   /** @brief Option byte change error flag. */
  static const field32_t FLASH_OPTSR_CUR_SWAP_BANK_OPT    = {.msk = 0x80000000U, .pos = 31};   /** @brief Bank swapping option status bit. */
  static const field32_t FLASH_OPTSR_PRG_BOR_LEV          = {.msk = 0x0000000CU, .pos = 2};    /** @brief BOR reset level option configuration bits. */
  static const field32_t FLASH_OPTSR_PRG_IWDG1_HW         = {.msk = 0x00000010U, .pos = 4};    /** @brief IWDG1 option configuration bit. */
  static const field32_t FLASH_OPTSR_PRG_NRST_STOP_D1     = {.msk = 0x00000040U, .pos = 6};    /** @brief Option byte erase after D1 dstop option configuration bit. */
  static const field32_t FLASH_OPTSR_PRG_NRST_STBY_D1     = {.msk = 0x00000080U, .pos = 7};    /** @brief Option byte erase after D1 dstandby option configuration bit. */
  static const field32_t FLASH_OPTSR_PRG_RDP              = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Readout protection level option configuration byte. */
  static const field32_t FLASH_OPTSR_PRG_FZ_IWDG_STOP     = {.msk = 0x00020000U, .pos = 17};   /** @brief IWDG stop mode freeze option configuration bit. */
  static const field32_t FLASH_OPTSR_PRG_FZ_IWDG_SDBY     = {.msk = 0x00040000U, .pos = 18};   /** @brief IWDG standby mode freeze option configuration bit. */
  static const field32_t FLASH_OPTSR_PRG_ST_RAM_SIZE      = {.msk = 0x00180000U, .pos = 19};   /** @brief DTCM size select option configuration bits. */
  static const field32_t FLASH_OPTSR_PRG_SECURITY         = {.msk = 0x00200000U, .pos = 21};   /** @brief Security option configuration bit. */
  static const field32_t FLASH_OPTSR_PRG_IO_HSLV          = {.msk = 0x20000000U, .pos = 29};   /** @brief I/O high-speed at low-voltage (PRODUCT_BELOW_25V). */
  static const field32_t FLASH_OPTSR_PRG_SWAP_BANK_OPT    = {.msk = 0x80000000U, .pos = 31};   /** @brief Bank swapping option configuration bit. */
  static const field32_t FLASH_OPTSR_PRG__BOR_LEV         = {.msk = 0x0000000CU, .pos = 2};    /** @brief BOR reset level option configuration bits. */
  static const field32_t FLASH_OPTSR_PRG__IWDG1_HW        = {.msk = 0x00000010U, .pos = 4};    /** @brief IWDG1 option configuration bit. */
  static const field32_t FLASH_OPTSR_PRG__NRST_STOP_D1    = {.msk = 0x00000040U, .pos = 6};    /** @brief Option byte erase after D1 dstop option configuration bit. */
  static const field32_t FLASH_OPTSR_PRG__NRST_STBY_D1    = {.msk = 0x00000080U, .pos = 7};    /** @brief Option byte erase after D1 dstandby option configuration bit. */
  static const field32_t FLASH_OPTSR_PRG__RDP             = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Readout protection level option configuration byte. */
  static const field32_t FLASH_OPTSR_PRG__FZ_IWDG_STOP    = {.msk = 0x00020000U, .pos = 17};   /** @brief IWDG stop mode freeze option configuration bit. */
  static const field32_t FLASH_OPTSR_PRG__FZ_IWDG_SDBY    = {.msk = 0x00040000U, .pos = 18};   /** @brief IWDG standby mode freeze option configuration bit. */
  static const field32_t FLASH_OPTSR_PRG__ST_RAM_SIZE     = {.msk = 0x00180000U, .pos = 19};   /** @brief DTCM size select option configuration bits. */
  static const field32_t FLASH_OPTSR_PRG__SECURITY        = {.msk = 0x00200000U, .pos = 21};   /** @brief Security option configuration bit. */
  static const field32_t FLASH_OPTSR_PRG__IO_HSLV         = {.msk = 0x20000000U, .pos = 29};   /** @brief I/O high-speed at low-voltage (PRODUCT_BELOW_25V). */
  static const field32_t FLASH_OPTSR_PRG__SWAP_BANK_OPT   = {.msk = 0x80000000U, .pos = 31};   /** @brief Bank swapping option configuration bit. */
  static const field32_t FLASH_OPTCCR__CLR_OPTCHANGEERR   = {.msk = 0x40000000U, .pos = 30};   /** @brief OPTCHANGEERR reset bit. */
  static const field32_t FLASH_OPTCCR_CLR_OPTCHANGEERR    = {.msk = 0x40000000U, .pos = 30};   /** @brief OPTCHANGEERR reset bit. */
  static const field32_t FLASH_PRAR_CURx_PROT_AREA_START1 = {.msk = 0x00000FFFU, .pos = 0};    /** @brief Bank 1 lowest PCROP protected address. */
  static const field32_t FLASH_PRAR_CURx_PROT_AREA_END1   = {.msk = 0x0FFF0000U, .pos = 16};   /** @brief Bank 1 highest PCROP protected address. */
  static const field32_t FLASH_PRAR_CURx_DMEP1            = {.msk = 0x80000000U, .pos = 31};   /** @brief Bank 1 PCROP protected erase enable option status bit. */
  static const field32_t FLASH_PRAR_PRGx_PROT_AREA_START1 = {.msk = 0x00000FFFU, .pos = 0};    /** @brief Bank 1 lowest PCROP protected address configuration. */
  static const field32_t FLASH_PRAR_PRGx_PROT_AREA_END1   = {.msk = 0x0FFF0000U, .pos = 16};   /** @brief Bank 1 highest PCROP protected address configuration. */
  static const field32_t FLASH_PRAR_PRGx_DMEP1            = {.msk = 0x80000000U, .pos = 31};   /** @brief Bank 1 PCROP protected erase enable option configuration bit. */
  static const field32_t FLASH_SCAR_CURx_SEC_AREA_START1  = {.msk = 0x00000FFFU, .pos = 0};    /** @brief Bank 1 lowest secure protected address. */
  static const field32_t FLASH_SCAR_CURx_SEC_AREA_END1    = {.msk = 0x0FFF0000U, .pos = 16};   /** @brief Bank 1 highest secure protected address. */
  static const field32_t FLASH_SCAR_CURx_DMES1            = {.msk = 0x80000000U, .pos = 31};   /** @brief Bank 1 secure protected erase enable option status bit. */
  static const field32_t FLASH_SCAR_PRGx_SEC_AREA_START1  = {.msk = 0x00000FFFU, .pos = 0};    /** @brief Bank 1 lowest secure protected address configuration. */
  static const field32_t FLASH_SCAR_PRGx_SEC_AREA_END1    = {.msk = 0x0FFF0000U, .pos = 16};   /** @brief Bank 1 highest secure protected address configuration. */
  static const field32_t FLASH_SCAR_PRGx_DMES1            = {.msk = 0x80000000U, .pos = 31};   /** @brief Bank 1 secure protected erase enable option configuration bit. */
  static const field32_t FLASH_WPSN_CURxR_WRPSN1          = {.msk = 0x000000FFU, .pos = 0};    /** @brief Bank 1 sector write protection option status byte. */
  static const field32_t FLASH_WPSN_PRGxR_WRPSN1          = {.msk = 0x000000FFU, .pos = 0};    /** @brief Bank 1 sector write protection configuration byte. */
  static const field32_t FLASH_CRCCRx_CRC_SECT            = {.msk = 0x00000007U, .pos = 0};    /** @brief Bank 1 CRC sector number. */
  static const field32_t FLASH_CRCCRx_ALL_BANK            = {.msk = 0x00000080U, .pos = 7};    /** @brief Bank 1 CRC select bit. */
  static const field32_t FLASH_CRCCRx_CRC_BY_SECT         = {.msk = 0x00000100U, .pos = 8};    /** @brief Bank 1 CRC sector mode select bit. */
  static const field32_t FLASH_CRCCRx_ADD_SECT            = {.msk = 0x00000200U, .pos = 9};    /** @brief Bank 1 CRC sector select bit. */
  static const field32_t FLASH_CRCCRx_CLEAN_SECT          = {.msk = 0x00000400U, .pos = 10};   /** @brief Bank 1 CRC sector list clear bit. */
  static const field32_t FLASH_CRCCRx_START_CRC           = {.msk = 0x00010000U, .pos = 16};   /** @brief Bank 1 CRC start bit. */
  static const field32_t FLASH_CRCCRx_CLEAN_CRC           = {.msk = 0x00020000U, .pos = 17};   /** @brief Bank 1 CRC clear bit. */
  static const field32_t FLASH_CRCCRx_CRC_BURST           = {.msk = 0x00300000U, .pos = 20};   /** @brief Bank 1 CRC burst size. */
  static const field32_t FLASH_ECC_FAxR_FAIL_ECC_ADDR1    = {.msk = 0x00007FFFU, .pos = 0};    /** @brief Bank 1 ECC error address. */

  /**** Enumerated FLASH Register Field Definitions ****/

  static field32_t const FLASH_OPTSR_PRG_RSSx[3] = {
    [1] = {.msk = 0x04000000U, .pos = 26},   /** @brief User option configuration bit 1. */
    [2] = {.msk = 0x08000000U, .pos = 27},   /** @brief User option configuration bit 2. */
  };

  static field32_t const FLASH_BOOT_CURR_BOOT_ADDx[2] = {
    [0] = {.msk = 0x0000FFFFU, .pos = 0},    /** @brief Boot address 0. */
    [1] = {.msk = 0xFFFF0000U, .pos = 16},   /** @brief Boot address 1. */
  };

  /************************************************************************************************
   * AXI Definitions
   ************************************************************************************************/

  /**** Enumerated AXI Register Definitions ****/

  static const ro_reg32_t AXI_AXI_PERIPH_ID_x[5] = {
    [0] = (ro_reg32_t)0x51001FE0U,   /** @brief AXI interconnect - peripheral ID0 register. */
    [1] = (ro_reg32_t)0x51001FE4U,   /** @brief AXI interconnect - peripheral ID1 register. */
    [2] = (ro_reg32_t)0x51001FE8U,   /** @brief AXI interconnect - peripheral ID2 register. */
    [3] = (ro_reg32_t)0x51001FECU,   /** @brief AXI interconnect - peripheral ID3 register. */
    [4] = (ro_reg32_t)0x51001FD0U,   /** @brief AXI interconnect - peripheral ID4 register. */
  };

  static const ro_reg32_t AXI_AXI_COMP_ID_x[4] = {
    [0] = (ro_reg32_t)0x51001FF0U,   /** @brief AXI interconnect - component ID0 register. */
    [1] = (ro_reg32_t)0x51001FF4U,   /** @brief AXI interconnect - component ID1 register. */
    [2] = (ro_reg32_t)0x51001FF8U,   /** @brief AXI interconnect - component ID2 register. */
    [3] = (ro_reg32_t)0x51001FFCU,   /** @brief AXI interconnect - component ID3 register. */
  };

  static const rw_reg32_t AXI_AXI_TARGx_FN_MOD_ISS_BM[8] = {
    [1] = (rw_reg32_t)0x51002008U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register. */
    [2] = (rw_reg32_t)0x51003008U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register. */
    [3] = (rw_reg32_t)0x51004008U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register. */
    [4] = (rw_reg32_t)0x51005008U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register. */
    [5] = (rw_reg32_t)0x51006008U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register. */
    [6] = (rw_reg32_t)0x51007008U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register. */
    [7] = (rw_reg32_t)0x5100800CU,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register. */
  };

  static const rw_reg32_t AXI_AXI_TARGx_FN_MOD2[8] = {
    [1] = (rw_reg32_t)0x51002024U,   /** @brief AXI interconnect - TARG x bus matrix functionality 2 register. */
    [2] = (rw_reg32_t)0x51003024U,   /** @brief AXI interconnect - TARG x bus matrix functionality 2 register. */
    [7] = (rw_reg32_t)0x51008024U,   /** @brief AXI interconnect - TARG x bus matrix functionality 2 register. */
  };

  static const rw_reg32_t AXI_AXI_TARGx_FN_MOD_LB[3] = {
    [1] = (rw_reg32_t)0x5100202CU,   /** @brief AXI interconnect - TARG x long burst functionality modification. */
    [2] = (rw_reg32_t)0x5100302CU,   /** @brief AXI interconnect - TARG x long burst functionality modification. */
  };

  static const rw_reg32_t AXI_AXI_TARGx_FN_MOD[8] = {
    [1] = (rw_reg32_t)0x51002108U,   /** @brief AXI interconnect - TARG x long burst functionality modification. */
    [2] = (rw_reg32_t)0x51003108U,   /** @brief AXI interconnect - TARG x long burst functionality modification. */
    [7] = (rw_reg32_t)0x51008108U,   /** @brief AXI interconnect - TARG x long burst functionality modification. */
  };

  static const rw_reg32_t AXI_AXI_INIx_FN_MOD2[4] = {
    [1] = (rw_reg32_t)0x51042024U,   /** @brief AXI interconnect - INI x functionality modification 2 register. */
    [3] = (rw_reg32_t)0x51044024U,   /** @brief AXI interconnect - INI x functionality modification 2 register. */
  };

  static const rw_reg32_t AXI_AXI_INIx_FN_MOD_AHB[4] = {
    [1] = (rw_reg32_t)0x51042028U,   /** @brief AXI interconnect - INI x AHB functionality modification register. */
    [3] = (rw_reg32_t)0x51044028U,   /** @brief AXI interconnect - INI x AHB functionality modification register. */
  };

  static const rw_reg32_t AXI_AXI_INIx_READ_QOS[7] = {
    [1] = (rw_reg32_t)0x51042100U,   /** @brief AXI interconnect - INI x read qos register. */
    [2] = (rw_reg32_t)0x51043100U,   /** @brief AXI interconnect - INI x read qos register. */
    [3] = (rw_reg32_t)0x51044100U,   /** @brief AXI interconnect - INI x read qos register. */
    [4] = (rw_reg32_t)0x51045100U,   /** @brief AXI interconnect - INI x read qos register. */
    [5] = (rw_reg32_t)0x51046100U,   /** @brief AXI interconnect - INI x read qos register. */
    [6] = (rw_reg32_t)0x51047100U,   /** @brief AXI interconnect - INI x read qos register. */
  };

  static const rw_reg32_t AXI_AXI_INIx_WRITE_QOS[7] = {
    [1] = (rw_reg32_t)0x51042104U,   /** @brief AXI interconnect - INI x write qos register. */
    [2] = (rw_reg32_t)0x51043104U,   /** @brief AXI interconnect - INI x write qos register. */
    [3] = (rw_reg32_t)0x51044104U,   /** @brief AXI interconnect - INI x write qos register. */
    [4] = (rw_reg32_t)0x51045104U,   /** @brief AXI interconnect - INI x write qos register. */
    [5] = (rw_reg32_t)0x51046104U,   /** @brief AXI interconnect - INI x write qos register. */
    [6] = (rw_reg32_t)0x51047104U,   /** @brief AXI interconnect - INI x write qos register. */
  };

  static const rw_reg32_t AXI_AXI_INIx_FN_MOD[7] = {
    [1] = (rw_reg32_t)0x51042108U,   /** @brief AXI interconnect - INI x issuing functionality modification register. */
    [2] = (rw_reg32_t)0x51043108U,   /** @brief AXI interconnect - INI x issuing functionality modification register. */
    [3] = (rw_reg32_t)0x51044108U,   /** @brief AXI interconnect - INI x issuing functionality modification register. */
    [4] = (rw_reg32_t)0x51045108U,   /** @brief AXI interconnect - INI x issuing functionality modification register. */
    [5] = (rw_reg32_t)0x51046108U,   /** @brief AXI interconnect - INI x issuing functionality modification register. */
    [6] = (rw_reg32_t)0x51047108U,   /** @brief AXI interconnect - INI x issuing functionality modification register. */
  };

  /**** AXI Register Field Definitions ****/

  static const field32_t AXI_AXI_PERIPH_ID_x_JEP106CON                  = {.msk = 0x0000000FU, .pos = 0};   /** @brief JEP106 continuation code. */
  static const field32_t AXI_AXI_PERIPH_ID_x_KCOUNT4                    = {.msk = 0x000000F0U, .pos = 4};   /** @brief Register file size. */
  static const field32_t AXI_AXI_COMP_ID_x_PREAMBLE                     = {.msk = 0x000000FFU, .pos = 0};   /** @brief Preamble bits 0 to 7. */
  static const field32_t AXI_AXI_TARGx_FN_MOD_ISS_BM_READ_ISS_OVERRIDE  = {.msk = 0x00000001U, .pos = 0};   /** @brief READ_ISS_OVERRIDE. */
  static const field32_t AXI_AXI_TARGx_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = {.msk = 0x00000002U, .pos = 1};   /** @brief Switch matrix write issuing override for target. */
  static const field32_t AXI_AXI_TARGx_FN_MOD2_BYPASS_MERGE             = {.msk = 0x00000001U, .pos = 0};   /** @brief Disable packing of beats to match the output data width. */
  static const field32_t AXI_AXI_TARGx_FN_MOD_LB_FN_MOD_LB              = {.msk = 0x00000001U, .pos = 0};   /** @brief Controls burst breaking of long bursts. */
  static const field32_t AXI_AXI_TARGx_FN_MOD_READ_ISS_OVERRIDE         = {.msk = 0x00000001U, .pos = 0};   /** @brief Override AMIB read issuing capability. */
  static const field32_t AXI_AXI_TARGx_FN_MOD_WRITE_ISS_OVERRIDE        = {.msk = 0x00000002U, .pos = 1};   /** @brief Override AMIB write issuing capability. */
  static const field32_t AXI_AXI_INIx_FN_MOD2_BYPASS_MERGE              = {.msk = 0x00000001U, .pos = 0};   /** @brief Disables alteration of transactions by the up-sizer unless required by the protocol. */
  static const field32_t AXI_AXI_INIx_FN_MOD_AHB_RD_INC_OVERRIDE        = {.msk = 0x00000001U, .pos = 0};   /** @brief Converts all ahb-lite write transactions to a series of single beat AXI. */
  static const field32_t AXI_AXI_INIx_FN_MOD_AHB_WR_INC_OVERRIDE        = {.msk = 0x00000002U, .pos = 1};   /** @brief Converts all ahb-lite read transactions to a series of single beat AXI. */
  static const field32_t AXI_AXI_INIx_READ_QOS_AR_QOS                   = {.msk = 0x0000000FU, .pos = 0};   /** @brief Read channel qos setting. */
  static const field32_t AXI_AXI_INIx_WRITE_QOS_AW_QOS                  = {.msk = 0x0000000FU, .pos = 0};   /** @brief Write channel qos setting. */
  static const field32_t AXI_AXI_INIx_FN_MOD_READ_ISS_OVERRIDE          = {.msk = 0x00000001U, .pos = 0};   /** @brief Override ASIB read issuing capability. */
  static const field32_t AXI_AXI_INIx_FN_MOD_WRITE_ISS_OVERRIDE         = {.msk = 0x00000002U, .pos = 1};   /** @brief Override ASIB write issuing capability. */

  /************************************************************************************************
   * HASH Definitions
   ************************************************************************************************/

  /**** HASH Register Definitions ****/

  static const rw_reg32_t HASH_CR  = (rw_reg32_t)0x48021400U;   /** @brief Control register. */
  static const rw_reg32_t HASH_DIN = (rw_reg32_t)0x48021404U;   /** @brief Data input register. */
  static const rw_reg32_t HASH_STR = (rw_reg32_t)0x48021408U;   /** @brief Start register. */
  static const rw_reg32_t HASH_IMR = (rw_reg32_t)0x48021420U;   /** @brief Interrupt enable register. */
  static const rw_reg32_t HASH_SR  = (rw_reg32_t)0x48021424U;   /** @brief Status register. */

  /**** Enumerated HASH Register Definitions ****/

  static const ro_reg32_t HASH_HRx[5] = {
    [0] = (ro_reg32_t)0x4802140CU,   /** @brief Digest registers. */
    [1] = (ro_reg32_t)0x48021410U,   /** @brief Digest registers. */
    [2] = (ro_reg32_t)0x48021414U,   /** @brief Digest registers. */
    [3] = (ro_reg32_t)0x48021418U,   /** @brief Digest registers. */
    [4] = (ro_reg32_t)0x4802141CU,   /** @brief Digest registers. */
  };

  static const rw_reg32_t HASH_CSRx[54] = {
    [0]  = (rw_reg32_t)0x480214F8U,   /** @brief Context swap registers. */
    [1]  = (rw_reg32_t)0x480214FCU,   /** @brief Context swap registers. */
    [2]  = (rw_reg32_t)0x48021500U,   /** @brief Context swap registers. */
    [3]  = (rw_reg32_t)0x48021504U,   /** @brief Context swap registers. */
    [4]  = (rw_reg32_t)0x48021508U,   /** @brief Context swap registers. */
    [5]  = (rw_reg32_t)0x4802150CU,   /** @brief Context swap registers. */
    [6]  = (rw_reg32_t)0x48021510U,   /** @brief Context swap registers. */
    [7]  = (rw_reg32_t)0x48021514U,   /** @brief Context swap registers. */
    [8]  = (rw_reg32_t)0x48021518U,   /** @brief Context swap registers. */
    [9]  = (rw_reg32_t)0x4802151CU,   /** @brief Context swap registers. */
    [10] = (rw_reg32_t)0x48021520U,   /** @brief Context swap registers. */
    [11] = (rw_reg32_t)0x48021524U,   /** @brief Context swap registers. */
    [12] = (rw_reg32_t)0x48021528U,   /** @brief Context swap registers. */
    [13] = (rw_reg32_t)0x4802152CU,   /** @brief Context swap registers. */
    [14] = (rw_reg32_t)0x48021530U,   /** @brief Context swap registers. */
    [15] = (rw_reg32_t)0x48021534U,   /** @brief Context swap registers. */
    [16] = (rw_reg32_t)0x48021538U,   /** @brief Context swap registers. */
    [17] = (rw_reg32_t)0x4802153CU,   /** @brief Context swap registers. */
    [18] = (rw_reg32_t)0x48021540U,   /** @brief Context swap registers. */
    [19] = (rw_reg32_t)0x48021544U,   /** @brief Context swap registers. */
    [20] = (rw_reg32_t)0x48021548U,   /** @brief Context swap registers. */
    [21] = (rw_reg32_t)0x4802154CU,   /** @brief Context swap registers. */
    [22] = (rw_reg32_t)0x48021550U,   /** @brief Context swap registers. */
    [23] = (rw_reg32_t)0x48021554U,   /** @brief Context swap registers. */
    [24] = (rw_reg32_t)0x48021558U,   /** @brief Context swap registers. */
    [25] = (rw_reg32_t)0x4802155CU,   /** @brief Context swap registers. */
    [26] = (rw_reg32_t)0x48021560U,   /** @brief Context swap registers. */
    [27] = (rw_reg32_t)0x48021564U,   /** @brief Context swap registers. */
    [28] = (rw_reg32_t)0x48021568U,   /** @brief Context swap registers. */
    [29] = (rw_reg32_t)0x4802156CU,   /** @brief Context swap registers. */
    [30] = (rw_reg32_t)0x48021570U,   /** @brief Context swap registers. */
    [31] = (rw_reg32_t)0x48021574U,   /** @brief Context swap registers. */
    [32] = (rw_reg32_t)0x48021578U,   /** @brief Context swap registers. */
    [33] = (rw_reg32_t)0x4802157CU,   /** @brief Context swap registers. */
    [34] = (rw_reg32_t)0x48021580U,   /** @brief Context swap registers. */
    [35] = (rw_reg32_t)0x48021584U,   /** @brief Context swap registers. */
    [36] = (rw_reg32_t)0x48021588U,   /** @brief Context swap registers. */
    [37] = (rw_reg32_t)0x4802158CU,   /** @brief Context swap registers. */
    [38] = (rw_reg32_t)0x48021590U,   /** @brief Context swap registers. */
    [39] = (rw_reg32_t)0x48021594U,   /** @brief Context swap registers. */
    [40] = (rw_reg32_t)0x48021598U,   /** @brief Context swap registers. */
    [41] = (rw_reg32_t)0x4802159CU,   /** @brief Context swap registers. */
    [42] = (rw_reg32_t)0x480215A0U,   /** @brief Context swap registers. */
    [43] = (rw_reg32_t)0x480215A4U,   /** @brief Context swap registers. */
    [44] = (rw_reg32_t)0x480215A8U,   /** @brief Context swap registers. */
    [45] = (rw_reg32_t)0x480215ACU,   /** @brief Context swap registers. */
    [46] = (rw_reg32_t)0x480215B0U,   /** @brief Context swap registers. */
    [47] = (rw_reg32_t)0x480215B4U,   /** @brief Context swap registers. */
    [48] = (rw_reg32_t)0x480215B8U,   /** @brief Context swap registers. */
    [49] = (rw_reg32_t)0x480215BCU,   /** @brief Context swap registers. */
    [50] = (rw_reg32_t)0x480215C0U,   /** @brief Context swap registers. */
    [51] = (rw_reg32_t)0x480215C4U,   /** @brief Context swap registers. */
    [52] = (rw_reg32_t)0x480215C8U,   /** @brief Context swap registers. */
    [53] = (rw_reg32_t)0x480215CCU,   /** @brief Context swap registers. */
  };

  static const ro_reg32_t HASH_HASH_HRx[8] = {
    [0] = (ro_reg32_t)0x48021710U,   /** @brief HASH digest register. */
    [1] = (ro_reg32_t)0x48021714U,   /** @brief Read-only. */
    [2] = (ro_reg32_t)0x48021718U,   /** @brief Read-only. */
    [3] = (ro_reg32_t)0x4802171CU,   /** @brief Read-only. */
    [4] = (ro_reg32_t)0x48021720U,   /** @brief Read-only. */
    [5] = (ro_reg32_t)0x48021724U,   /** @brief Read-only. */
    [6] = (ro_reg32_t)0x48021728U,   /** @brief Read-only. */
    [7] = (ro_reg32_t)0x4802172CU,   /** @brief Read-only. */
  };

  /**** HASH Register Field Definitions ****/

  static const field32_t HASH_CR_INIT     = {.msk = 0x00000004U, .pos = 2};    /** @brief Initialize message digest calculation. */
  static const field32_t HASH_CR_DMAE     = {.msk = 0x00000008U, .pos = 3};    /** @brief DMA enable. */
  static const field32_t HASH_CR_DATATYPE = {.msk = 0x00000030U, .pos = 4};    /** @brief Data type selection. */
  static const field32_t HASH_CR_MODE     = {.msk = 0x00000040U, .pos = 6};    /** @brief Mode selection. */
  static const field32_t HASH_CR_NBW      = {.msk = 0x00000F00U, .pos = 8};    /** @brief Number of words already pushed. */
  static const field32_t HASH_CR_DINNE    = {.msk = 0x00001000U, .pos = 12};   /** @brief DIN not empty. */
  static const field32_t HASH_CR_MDMAT    = {.msk = 0x00002000U, .pos = 13};   /** @brief Multiple DMA transfers. */
  static const field32_t HASH_CR_LKEY     = {.msk = 0x00010000U, .pos = 16};   /** @brief Long key selection. */
  static const field32_t HASH_STR_DCAL    = {.msk = 0x00000100U, .pos = 8};    /** @brief Digest calculation. */
  static const field32_t HASH_STR_NBLW    = {.msk = 0x0000001FU, .pos = 0};    /** @brief Number of valid bits in the last word of the message. */
  static const field32_t HASH_IMR_DCIE    = {.msk = 0x00000002U, .pos = 1};    /** @brief Digest calculation completion interrupt enable. */
  static const field32_t HASH_IMR_DINIE   = {.msk = 0x00000001U, .pos = 0};    /** @brief Data input interrupt enable. */
  static const field32_t HASH_SR_BUSY     = {.msk = 0x00000008U, .pos = 3};    /** @brief Busy bit. */
  static const field32_t HASH_SR_DMAS     = {.msk = 0x00000004U, .pos = 2};    /** @brief DMA status. */
  static const field32_t HASH_SR_DCIS     = {.msk = 0x00000002U, .pos = 1};    /** @brief Digest calculation completion interrupt status. */
  static const field32_t HASH_SR_DINIS    = {.msk = 0x00000001U, .pos = 0};    /** @brief Data input interrupt status. */

  /**** Enumerated HASH Register Field Definitions ****/

  static field32_t const HASH_CR_ALGOx[2] = {
    [0] = {.msk = 0x00000080U, .pos = 7},    /** @brief Algorithm selection. */
    [1] = {.msk = 0x00040000U, .pos = 18},   /** @brief ALGO. */
  };

  /************************************************************************************************
   * CRYP Definitions
   ************************************************************************************************/

  /**** CRYP Register Definitions ****/

  static const rw_reg32_t CRYP_CR    = (rw_reg32_t)0x48021000U;   /** @brief Control register. */
  static const ro_reg32_t CRYP_SR    = (ro_reg32_t)0x48021004U;   /** @brief Status register. */
  static const rw_reg32_t CRYP_DIN   = (rw_reg32_t)0x48021008U;   /** @brief Data input register. */
  static const ro_reg32_t CRYP_DOUT  = (ro_reg32_t)0x4802100CU;   /** @brief Data output register. */
  static const rw_reg32_t CRYP_DMACR = (rw_reg32_t)0x48021010U;   /** @brief DMA control register. */
  static const rw_reg32_t CRYP_IMSCR = (rw_reg32_t)0x48021014U;   /** @brief Interrupt mask set/clear register. */
  static const ro_reg32_t CRYP_RISR  = (ro_reg32_t)0x48021018U;   /** @brief Raw interrupt status register. */
  static const ro_reg32_t CRYP_MISR  = (ro_reg32_t)0x4802101CU;   /** @brief Masked interrupt status register. */

  /**** Enumerated CRYP Register Definitions ****/

  static const rw_reg32_t CRYP_KxLR[4] = {
    [0] = (rw_reg32_t)0x48021020U,   /** @brief Key registers. */
    [1] = (rw_reg32_t)0x48021028U,   /** @brief Key registers. */
    [2] = (rw_reg32_t)0x48021030U,   /** @brief Key registers. */
    [3] = (rw_reg32_t)0x48021038U,   /** @brief Key registers. */
  };

  static const rw_reg32_t CRYP_KxRR[4] = {
    [0] = (rw_reg32_t)0x48021024U,   /** @brief Key registers. */
    [1] = (rw_reg32_t)0x4802102CU,   /** @brief Key registers. */
    [2] = (rw_reg32_t)0x48021034U,   /** @brief Key registers. */
    [3] = (rw_reg32_t)0x4802103CU,   /** @brief Key registers. */
  };

  static const rw_reg32_t CRYP_IVxLR[2] = {
    [0] = (rw_reg32_t)0x48021040U,   /** @brief Initialization vector registers. */
    [1] = (rw_reg32_t)0x48021048U,   /** @brief Initialization vector registers. */
  };

  static const rw_reg32_t CRYP_IVxRR[2] = {
    [0] = (rw_reg32_t)0x48021044U,   /** @brief Initialization vector registers. */
    [1] = (rw_reg32_t)0x4802104CU,   /** @brief Initialization vector registers. */
  };

  static const rw_reg32_t CRYP_CSGCMCCMxR[8] = {
    [0] = (rw_reg32_t)0x48021050U,   /** @brief Context swap register. */
    [1] = (rw_reg32_t)0x48021054U,   /** @brief Context swap register. */
    [2] = (rw_reg32_t)0x48021058U,   /** @brief Context swap register. */
    [3] = (rw_reg32_t)0x4802105CU,   /** @brief Context swap register. */
    [4] = (rw_reg32_t)0x48021060U,   /** @brief Context swap register. */
    [5] = (rw_reg32_t)0x48021064U,   /** @brief Context swap register. */
    [6] = (rw_reg32_t)0x48021068U,   /** @brief Context swap register. */
    [7] = (rw_reg32_t)0x4802106CU,   /** @brief Context swap register. */
  };

  static const rw_reg32_t CRYP_CSGCMxR[8] = {
    [0] = (rw_reg32_t)0x48021070U,   /** @brief Context swap register. */
    [1] = (rw_reg32_t)0x48021074U,   /** @brief Context swap register. */
    [2] = (rw_reg32_t)0x48021078U,   /** @brief Context swap register. */
    [3] = (rw_reg32_t)0x4802107CU,   /** @brief Context swap register. */
    [4] = (rw_reg32_t)0x48021080U,   /** @brief Context swap register. */
    [5] = (rw_reg32_t)0x48021084U,   /** @brief Context swap register. */
    [6] = (rw_reg32_t)0x48021088U,   /** @brief Context swap register. */
    [7] = (rw_reg32_t)0x4802108CU,   /** @brief Context swap register. */
  };

  /**** CRYP Register Field Definitions ****/

  static const field32_t CRYP_CR_ALGODIR   = {.msk = 0x00000004U, .pos = 2};    /** @brief Algorithm direction. */
  static const field32_t CRYP_CR_DATATYPE  = {.msk = 0x000000C0U, .pos = 6};    /** @brief Data type selection. */
  static const field32_t CRYP_CR_KEYSIZE   = {.msk = 0x00000300U, .pos = 8};    /** @brief Key size selection (AES mode only). */
  static const field32_t CRYP_CR_FFLUSH    = {.msk = 0x00004000U, .pos = 14};   /** @brief FIFO flush. */
  static const field32_t CRYP_CR_CRYPEN    = {.msk = 0x00008000U, .pos = 15};   /** @brief Cryptographic processor enable. */
  static const field32_t CRYP_CR_GCM_CCMPH = {.msk = 0x00030000U, .pos = 16};   /** @brief GCM_CCMPH. */
  static const field32_t CRYP_SR_BUSY      = {.msk = 0x00000010U, .pos = 4};    /** @brief Busy bit. */
  static const field32_t CRYP_SR_OFFU      = {.msk = 0x00000008U, .pos = 3};    /** @brief Output FIFO full. */
  static const field32_t CRYP_SR_OFNE      = {.msk = 0x00000004U, .pos = 2};    /** @brief Output FIFO not empty. */
  static const field32_t CRYP_SR_IFNF      = {.msk = 0x00000002U, .pos = 1};    /** @brief Input FIFO not full. */
  static const field32_t CRYP_SR_IFEM      = {.msk = 0x00000001U, .pos = 0};    /** @brief Input FIFO empty. */
  static const field32_t CRYP_DMACR_DOEN   = {.msk = 0x00000002U, .pos = 1};    /** @brief DMA output enable. */
  static const field32_t CRYP_DMACR_DIEN   = {.msk = 0x00000001U, .pos = 0};    /** @brief DMA input enable. */
  static const field32_t CRYP_IMSCR_OUTIM  = {.msk = 0x00000002U, .pos = 1};    /** @brief Output FIFO service interrupt mask. */
  static const field32_t CRYP_IMSCR_INIM   = {.msk = 0x00000001U, .pos = 0};    /** @brief Input FIFO service interrupt mask. */
  static const field32_t CRYP_RISR_OUTRIS  = {.msk = 0x00000002U, .pos = 1};    /** @brief Output FIFO service raw interrupt status. */
  static const field32_t CRYP_RISR_INRIS   = {.msk = 0x00000001U, .pos = 0};    /** @brief Input FIFO service raw interrupt status. */
  static const field32_t CRYP_MISR_OUTMIS  = {.msk = 0x00000002U, .pos = 1};    /** @brief Output FIFO service masked interrupt status. */
  static const field32_t CRYP_MISR_INMIS   = {.msk = 0x00000001U, .pos = 0};    /** @brief Input FIFO service masked interrupt status. */

  /**** Enumerated CRYP Register Field Definitions ****/

  static field32_t const CRYP_CR_ALGOMODEx[4] = {
    [0] = {.msk = 0x00000038U, .pos = 3},    /** @brief Algorithm mode. */
    [3] = {.msk = 0x00080000U, .pos = 19},   /** @brief ALGOMODE. */
  };

  static field32_t const CRYP_KxLR_B2x[56] = {
    [24] = {.msk = 0x00000001U, .pos = 0},    /** @brief B224. */
    [30] = {.msk = 0x00000040U, .pos = 6},    /** @brief B230. */
    [31] = {.msk = 0x00000080U, .pos = 7},    /** @brief B231. */
    [32] = {.msk = 0x00000100U, .pos = 8},    /** @brief B232. */
    [33] = {.msk = 0x00000200U, .pos = 9},    /** @brief B233. */
    [34] = {.msk = 0x00000400U, .pos = 10},   /** @brief B234. */
    [35] = {.msk = 0x00000800U, .pos = 11},   /** @brief B235. */
    [36] = {.msk = 0x00001000U, .pos = 12},   /** @brief B236. */
    [37] = {.msk = 0x00002000U, .pos = 13},   /** @brief B237. */
    [38] = {.msk = 0x00004000U, .pos = 14},   /** @brief B238. */
    [39] = {.msk = 0x00008000U, .pos = 15},   /** @brief B239. */
    [40] = {.msk = 0x00010000U, .pos = 16},   /** @brief B240. */
    [41] = {.msk = 0x00020000U, .pos = 17},   /** @brief B241. */
    [42] = {.msk = 0x00040000U, .pos = 18},   /** @brief B242. */
    [43] = {.msk = 0x00080000U, .pos = 19},   /** @brief B243. */
    [44] = {.msk = 0x00100000U, .pos = 20},   /** @brief B244. */
    [45] = {.msk = 0x00200000U, .pos = 21},   /** @brief B245. */
    [46] = {.msk = 0x00400000U, .pos = 22},   /** @brief B246. */
    [47] = {.msk = 0x00800000U, .pos = 23},   /** @brief B247. */
    [48] = {.msk = 0x01000000U, .pos = 24},   /** @brief B248. */
    [49] = {.msk = 0x02000000U, .pos = 25},   /** @brief B249. */
    [50] = {.msk = 0x04000000U, .pos = 26},   /** @brief B250. */
    [51] = {.msk = 0x08000000U, .pos = 27},   /** @brief B251. */
    [52] = {.msk = 0x10000000U, .pos = 28},   /** @brief B252. */
    [53] = {.msk = 0x20000000U, .pos = 29},   /** @brief B253. */
    [54] = {.msk = 0x40000000U, .pos = 30},   /** @brief B254. */
    [55] = {.msk = 0x80000000U, .pos = 31},   /** @brief B255. */
  };

  static field32_t const CRYP_KxLR_B22x[10] = {
    [5]  = {.msk = 0x00000002U, .pos = 1},   /** @brief B225. */
    [6]  = {.msk = 0x00000004U, .pos = 2},   /** @brief B226. */
    [7]  = {.msk = 0x00000008U, .pos = 3},   /** @brief B227. */
    [8]  = {.msk = 0x00000010U, .pos = 4},   /** @brief B228. */
    [9]  = {.msk = 0x00000020U, .pos = 5},   /** @brief B229. */
  };

  static field32_t const CRYP_KxRR_B19x[10] = {
    [2]  = {.msk = 0x00000001U, .pos = 0},   /** @brief B192. */
    [3]  = {.msk = 0x00000002U, .pos = 1},   /** @brief B193. */
    [4]  = {.msk = 0x00000004U, .pos = 2},   /** @brief B194. */
    [5]  = {.msk = 0x00000008U, .pos = 3},   /** @brief B195. */
    [6]  = {.msk = 0x00000010U, .pos = 4},   /** @brief B196. */
    [7]  = {.msk = 0x00000020U, .pos = 5},   /** @brief B197. */
    [8]  = {.msk = 0x00000040U, .pos = 6},   /** @brief B198. */
    [9]  = {.msk = 0x00000080U, .pos = 7},   /** @brief B199. */
  };

  static field32_t const CRYP_KxRR_B20x[10] = {
    [1]  = {.msk = 0x00000200U, .pos = 9},    /** @brief B201. */
    [2]  = {.msk = 0x00000400U, .pos = 10},   /** @brief B202. */
    [3]  = {.msk = 0x00000800U, .pos = 11},   /** @brief B203. */
    [4]  = {.msk = 0x00001000U, .pos = 12},   /** @brief B204. */
    [5]  = {.msk = 0x00002000U, .pos = 13},   /** @brief B205. */
    [6]  = {.msk = 0x00004000U, .pos = 14},   /** @brief B206. */
    [7]  = {.msk = 0x00008000U, .pos = 15},   /** @brief B207. */
    [8]  = {.msk = 0x00010000U, .pos = 16},   /** @brief B208. */
    [9]  = {.msk = 0x00020000U, .pos = 17},   /** @brief B209. */
  };

  static field32_t const CRYP_IVxLR_IVx[32] = {
    [0]  = {.msk = 0x80000000U, .pos = 31},   /** @brief IV0. */
    [1]  = {.msk = 0x40000000U, .pos = 30},   /** @brief IV1. */
    [2]  = {.msk = 0x20000000U, .pos = 29},   /** @brief IV2. */
    [3]  = {.msk = 0x10000000U, .pos = 28},   /** @brief IV3. */
    [4]  = {.msk = 0x08000000U, .pos = 27},   /** @brief IV4. */
    [5]  = {.msk = 0x04000000U, .pos = 26},   /** @brief IV5. */
    [6]  = {.msk = 0x02000000U, .pos = 25},   /** @brief IV6. */
    [7]  = {.msk = 0x01000000U, .pos = 24},   /** @brief IV7. */
    [8]  = {.msk = 0x00800000U, .pos = 23},   /** @brief IV8. */
    [9]  = {.msk = 0x00400000U, .pos = 22},   /** @brief IV9. */
    [10] = {.msk = 0x00200000U, .pos = 21},   /** @brief IV10. */
    [11] = {.msk = 0x00100000U, .pos = 20},   /** @brief IV11. */
    [12] = {.msk = 0x00080000U, .pos = 19},   /** @brief IV12. */
    [13] = {.msk = 0x00040000U, .pos = 18},   /** @brief IV13. */
    [14] = {.msk = 0x00020000U, .pos = 17},   /** @brief IV14. */
    [15] = {.msk = 0x00010000U, .pos = 16},   /** @brief IV15. */
    [16] = {.msk = 0x00008000U, .pos = 15},   /** @brief IV16. */
    [17] = {.msk = 0x00004000U, .pos = 14},   /** @brief IV17. */
    [18] = {.msk = 0x00002000U, .pos = 13},   /** @brief IV18. */
    [19] = {.msk = 0x00001000U, .pos = 12},   /** @brief IV19. */
    [20] = {.msk = 0x00000800U, .pos = 11},   /** @brief IV20. */
    [21] = {.msk = 0x00000400U, .pos = 10},   /** @brief IV21. */
    [22] = {.msk = 0x00000200U, .pos = 9},    /** @brief IV22. */
    [23] = {.msk = 0x00000100U, .pos = 8},    /** @brief IV23. */
    [24] = {.msk = 0x00000080U, .pos = 7},    /** @brief IV24. */
    [25] = {.msk = 0x00000040U, .pos = 6},    /** @brief IV25. */
    [26] = {.msk = 0x00000020U, .pos = 5},    /** @brief IV26. */
    [27] = {.msk = 0x00000010U, .pos = 4},    /** @brief IV27. */
    [28] = {.msk = 0x00000008U, .pos = 3},    /** @brief IV28. */
    [29] = {.msk = 0x00000004U, .pos = 2},    /** @brief IV29. */
    [31] = {.msk = 0x00000001U, .pos = 0},    /** @brief IV31. */
  };

  static field32_t const CRYP_IVxLR_IV3x[2] = {
    [0] = {.msk = 0x00000002U, .pos = 1},   /** @brief IV30. */
  };

  static field32_t const CRYP_IVxRR_IV6x[4] = {
    [0] = {.msk = 0x00000008U, .pos = 3},   /** @brief IV60. */
    [1] = {.msk = 0x00000004U, .pos = 2},   /** @brief IV61. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief IV62. */
  };

  /************************************************************************************************
   * DCMI Definitions
   ************************************************************************************************/

  /**** DCMI Register Definitions ****/

  static const rw_reg32_t DCMI_CR     = (rw_reg32_t)0x48020000U;   /** @brief Control register 1. */
  static const ro_reg32_t DCMI_SR     = (ro_reg32_t)0x48020004U;   /** @brief Status register. */
  static const ro_reg32_t DCMI_RIS    = (ro_reg32_t)0x48020008U;   /** @brief Raw interrupt status register. */
  static const rw_reg32_t DCMI_IER    = (rw_reg32_t)0x4802000CU;   /** @brief Interrupt enable register. */
  static const ro_reg32_t DCMI_MIS    = (ro_reg32_t)0x48020010U;   /** @brief Masked interrupt status register. */
  static const rw_reg32_t DCMI_ICR    = (rw_reg32_t)0x48020014U;   /** @brief Interrupt clear register. */
  static const rw_reg32_t DCMI_ESCR   = (rw_reg32_t)0x48020018U;   /** @brief Embedded synchronization code register. */
  static const rw_reg32_t DCMI_ESUR   = (rw_reg32_t)0x4802001CU;   /** @brief Embedded synchronization unmask register. */
  static const rw_reg32_t DCMI_CWSTRT = (rw_reg32_t)0x48020020U;   /** @brief Crop window start. */
  static const rw_reg32_t DCMI_CWSIZE = (rw_reg32_t)0x48020024U;   /** @brief Crop window size. */
  static const ro_reg32_t DCMI_DR     = (ro_reg32_t)0x48020028U;   /** @brief Data register. */

  /**** DCMI Register Field Definitions ****/

  static const field32_t DCMI_CR_OELS        = {.msk = 0x00100000U, .pos = 20};   /** @brief Odd/Even line select (line select start). */
  static const field32_t DCMI_CR_LSM         = {.msk = 0x00080000U, .pos = 19};   /** @brief Line select mode. */
  static const field32_t DCMI_CR_OEBS        = {.msk = 0x00040000U, .pos = 18};   /** @brief Odd/Even byte select (byte select start). */
  static const field32_t DCMI_CR_BSM         = {.msk = 0x00030000U, .pos = 16};   /** @brief Byte select mode. */
  static const field32_t DCMI_CR_ENABLE      = {.msk = 0x00004000U, .pos = 14};   /** @brief DCMI enable. */
  static const field32_t DCMI_CR_EDM         = {.msk = 0x00000C00U, .pos = 10};   /** @brief Extended data mode. */
  static const field32_t DCMI_CR_FCRC        = {.msk = 0x00000300U, .pos = 8};    /** @brief Frame capture rate control. */
  static const field32_t DCMI_CR_VSPOL       = {.msk = 0x00000080U, .pos = 7};    /** @brief Vertical synchronization polarity. */
  static const field32_t DCMI_CR_HSPOL       = {.msk = 0x00000040U, .pos = 6};    /** @brief Horizontal synchronization polarity. */
  static const field32_t DCMI_CR_PCKPOL      = {.msk = 0x00000020U, .pos = 5};    /** @brief Pixel clock polarity. */
  static const field32_t DCMI_CR_ESS         = {.msk = 0x00000010U, .pos = 4};    /** @brief Embedded synchronization select. */
  static const field32_t DCMI_CR_JPEG        = {.msk = 0x00000008U, .pos = 3};    /** @brief JPEG format. */
  static const field32_t DCMI_CR_CROP        = {.msk = 0x00000004U, .pos = 2};    /** @brief Crop feature. */
  static const field32_t DCMI_CR_CM          = {.msk = 0x00000002U, .pos = 1};    /** @brief Capture mode. */
  static const field32_t DCMI_CR_CAPTURE     = {.msk = 0x00000001U, .pos = 0};    /** @brief Capture enable. */
  static const field32_t DCMI_SR_FNE         = {.msk = 0x00000004U, .pos = 2};    /** @brief FIFO not empty. */
  static const field32_t DCMI_SR_VSYNC       = {.msk = 0x00000002U, .pos = 1};    /** @brief VSYNC. */
  static const field32_t DCMI_SR_HSYNC       = {.msk = 0x00000001U, .pos = 0};    /** @brief HSYNC. */
  static const field32_t DCMI_RIS_LINE_RIS   = {.msk = 0x00000010U, .pos = 4};    /** @brief Line raw interrupt status. */
  static const field32_t DCMI_RIS_VSYNC_RIS  = {.msk = 0x00000008U, .pos = 3};    /** @brief VSYNC raw interrupt status. */
  static const field32_t DCMI_RIS_ERR_RIS    = {.msk = 0x00000004U, .pos = 2};    /** @brief Synchronization error raw interrupt status. */
  static const field32_t DCMI_RIS_OVR_RIS    = {.msk = 0x00000002U, .pos = 1};    /** @brief Overrun raw interrupt status. */
  static const field32_t DCMI_RIS_FRAME_RIS  = {.msk = 0x00000001U, .pos = 0};    /** @brief Capture complete raw interrupt status. */
  static const field32_t DCMI_IER_LINE_IE    = {.msk = 0x00000010U, .pos = 4};    /** @brief Line interrupt enable. */
  static const field32_t DCMI_IER_VSYNC_IE   = {.msk = 0x00000008U, .pos = 3};    /** @brief VSYNC interrupt enable. */
  static const field32_t DCMI_IER_ERR_IE     = {.msk = 0x00000004U, .pos = 2};    /** @brief Synchronization error interrupt enable. */
  static const field32_t DCMI_IER_OVR_IE     = {.msk = 0x00000002U, .pos = 1};    /** @brief Overrun interrupt enable. */
  static const field32_t DCMI_IER_FRAME_IE   = {.msk = 0x00000001U, .pos = 0};    /** @brief Capture complete interrupt enable. */
  static const field32_t DCMI_MIS_LINE_MIS   = {.msk = 0x00000010U, .pos = 4};    /** @brief Line masked interrupt status. */
  static const field32_t DCMI_MIS_VSYNC_MIS  = {.msk = 0x00000008U, .pos = 3};    /** @brief VSYNC masked interrupt status. */
  static const field32_t DCMI_MIS_ERR_MIS    = {.msk = 0x00000004U, .pos = 2};    /** @brief Synchronization error masked interrupt status. */
  static const field32_t DCMI_MIS_OVR_MIS    = {.msk = 0x00000002U, .pos = 1};    /** @brief Overrun masked interrupt status. */
  static const field32_t DCMI_MIS_FRAME_MIS  = {.msk = 0x00000001U, .pos = 0};    /** @brief Capture complete masked interrupt status. */
  static const field32_t DCMI_ICR_LINE_ISC   = {.msk = 0x00000010U, .pos = 4};    /** @brief Line interrupt status clear. */
  static const field32_t DCMI_ICR_VSYNC_ISC  = {.msk = 0x00000008U, .pos = 3};    /** @brief Vertical synch interrupt status clear. */
  static const field32_t DCMI_ICR_ERR_ISC    = {.msk = 0x00000004U, .pos = 2};    /** @brief Synchronization error interrupt status clear. */
  static const field32_t DCMI_ICR_OVR_ISC    = {.msk = 0x00000002U, .pos = 1};    /** @brief Overrun interrupt status clear. */
  static const field32_t DCMI_ICR_FRAME_ISC  = {.msk = 0x00000001U, .pos = 0};    /** @brief Capture complete interrupt status clear. */
  static const field32_t DCMI_ESCR_FEC       = {.msk = 0xFF000000U, .pos = 24};   /** @brief Frame end delimiter code. */
  static const field32_t DCMI_ESCR_LEC       = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Line end delimiter code. */
  static const field32_t DCMI_ESCR_LSC       = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Line start delimiter code. */
  static const field32_t DCMI_ESCR_FSC       = {.msk = 0x000000FFU, .pos = 0};    /** @brief Frame start delimiter code. */
  static const field32_t DCMI_ESUR_FEU       = {.msk = 0xFF000000U, .pos = 24};   /** @brief Frame end delimiter unmask. */
  static const field32_t DCMI_ESUR_LEU       = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Line end delimiter unmask. */
  static const field32_t DCMI_ESUR_LSU       = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Line start delimiter unmask. */
  static const field32_t DCMI_ESUR_FSU       = {.msk = 0x000000FFU, .pos = 0};    /** @brief Frame start delimiter unmask. */
  static const field32_t DCMI_CWSTRT_VST     = {.msk = 0x1FFF0000U, .pos = 16};   /** @brief Vertical start line count. */
  static const field32_t DCMI_CWSTRT_HOFFCNT = {.msk = 0x00003FFFU, .pos = 0};    /** @brief Horizontal offset count. */
  static const field32_t DCMI_CWSIZE_VLINE   = {.msk = 0x3FFF0000U, .pos = 16};   /** @brief Vertical line count. */
  static const field32_t DCMI_CWSIZE_CAPCNT  = {.msk = 0x00003FFFU, .pos = 0};    /** @brief Capture count. */

  /**** Enumerated DCMI Register Field Definitions ****/

  static field32_t const DCMI_DR_BYTEx[4] = {
    [0] = {.msk = 0x000000FFU, .pos = 0},    /** @brief Data byte 0. */
    [1] = {.msk = 0x0000FF00U, .pos = 8},    /** @brief Data byte 1. */
    [2] = {.msk = 0x00FF0000U, .pos = 16},   /** @brief Data byte 2. */
    [3] = {.msk = 0xFF000000U, .pos = 24},   /** @brief Data byte 3. */
  };

  /************************************************************************************************
   * OTGx_HS_GLOBAL Definitions
   ************************************************************************************************/

  /**** Enumerated OTGx_HS_GLOBAL Register Definitions ****/

  static const rw_reg32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL[3] = {
    [1] = (rw_reg32_t)0x40040000U,   /** @brief OTG_HS control and status register. */
    [2] = (rw_reg32_t)0x40080000U,   /** @brief OTG_HS control and status register. */
  };

  static const rw_reg32_t OTGx_HS_GLOBAL_OTG_HS_GOTGINT[3] = {
    [1] = (rw_reg32_t)0x40040004U,   /** @brief OTG_HS interrupt register. */
    [2] = (rw_reg32_t)0x40080004U,   /** @brief OTG_HS interrupt register. */
  };

  static const rw_reg32_t OTGx_HS_GLOBAL_OTG_HS_GAHBCFG[3] = {
    [1] = (rw_reg32_t)0x40040008U,   /** @brief OTG_HS AHB configuration register. */
    [2] = (rw_reg32_t)0x40080008U,   /** @brief OTG_HS AHB configuration register. */
  };

  static const rw_reg32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG[3] = {
    [1] = (rw_reg32_t)0x4004000CU,   /** @brief OTG_HS USB configuration register. */
    [2] = (rw_reg32_t)0x4008000CU,   /** @brief OTG_HS USB configuration register. */
  };

  static const rw_reg32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL[3] = {
    [1] = (rw_reg32_t)0x40040010U,   /** @brief OTG_HS reset register. */
    [2] = (rw_reg32_t)0x40080010U,   /** @brief OTG_HS reset register. */
  };

  static const rw_reg32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS[3] = {
    [1] = (rw_reg32_t)0x40040014U,   /** @brief OTG_HS core interrupt register. */
    [2] = (rw_reg32_t)0x40080014U,   /** @brief OTG_HS core interrupt register. */
  };

  static const rw_reg32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK[3] = {
    [1] = (rw_reg32_t)0x40040018U,   /** @brief OTG_HS interrupt mask register. */
    [2] = (rw_reg32_t)0x40080018U,   /** @brief OTG_HS interrupt mask register. */
  };

  static const ro_reg32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_HOST[3] = {
    [1] = (ro_reg32_t)0x4004001CU,   /** @brief OTG_HS receive status debug read register (host mode). */
    [2] = (ro_reg32_t)0x4008001CU,   /** @brief OTG_HS receive status debug read register (host mode). */
  };

  static const ro_reg32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_HOST[3] = {
    [1] = (ro_reg32_t)0x40040020U,   /** @brief OTG_HS status read and pop register (host mode). */
    [2] = (ro_reg32_t)0x40080020U,   /** @brief OTG_HS status read and pop register (host mode). */
  };

  static const rw_reg32_t OTGx_HS_GLOBAL_OTG_HS_GRXFSIZ[3] = {
    [1] = (rw_reg32_t)0x40040024U,   /** @brief OTG_HS receive FIFO size register. */
    [2] = (rw_reg32_t)0x40080024U,   /** @brief OTG_HS receive FIFO size register. */
  };

  static const rw_reg32_t OTGx_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST[3] = {
    [1] = (rw_reg32_t)0x40040028U,   /** @brief OTG_HS nonperiodic transmit FIFO size register (host mode). */
    [2] = (rw_reg32_t)0x40080028U,   /** @brief OTG_HS nonperiodic transmit FIFO size register (host mode). */
  };

  static const rw_reg32_t OTGx_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE[3] = {
    [1] = (rw_reg32_t)0x40040028U,   /** @brief OTG_HS nonperiodic transmit FIFO size register (host mode). */
    [2] = (rw_reg32_t)0x40080028U,   /** @brief OTG_HS nonperiodic transmit FIFO size register (host mode). */
  };

  static const ro_reg32_t OTGx_HS_GLOBAL_OTG_HS_GNPTXSTS[3] = {
    [1] = (ro_reg32_t)0x4004002CU,   /** @brief OTG_HS nonperiodic transmit fifo/queue status register. */
    [2] = (ro_reg32_t)0x4008002CU,   /** @brief OTG_HS nonperiodic transmit fifo/queue status register. */
  };

  static const rw_reg32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG[3] = {
    [1] = (rw_reg32_t)0x40040038U,   /** @brief OTG_HS general core configuration register. */
    [2] = (rw_reg32_t)0x40080038U,   /** @brief OTG_HS general core configuration register. */
  };

  static const rw_reg32_t OTGx_HS_GLOBAL_OTG_HS_CID[3] = {
    [1] = (rw_reg32_t)0x4004003CU,   /** @brief OTG_HS core ID register. */
    [2] = (rw_reg32_t)0x4008003CU,   /** @brief OTG_HS core ID register. */
  };

  static const rw_reg32_t OTGx_HS_GLOBAL_OTG_HS_HPTXFSIZ[3] = {
    [1] = (rw_reg32_t)0x40040100U,   /** @brief OTG_HS host periodic transmit FIFO size register. */
    [2] = (rw_reg32_t)0x40080100U,   /** @brief OTG_HS host periodic transmit FIFO size register. */
  };

  static const rw_reg32_t OTGx_HS_GLOBAL_OTG_HS_DIEPTXFx[3][8] = {
    [1] = {
      [1] = (rw_reg32_t)0x40040104U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register. */
      [2] = (rw_reg32_t)0x40040108U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register. */
      [3] = (rw_reg32_t)0x4004011CU,   /** @brief OTG_HS device IN endpoint transmit FIFO size register. */
      [4] = (rw_reg32_t)0x40040120U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register. */
      [5] = (rw_reg32_t)0x40040124U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register. */
      [6] = (rw_reg32_t)0x40040128U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register. */
      [7] = (rw_reg32_t)0x4004012CU,   /** @brief OTG_HS device IN endpoint transmit FIFO size register. */
    },
    [2] = {
      [1] = (rw_reg32_t)0x40080104U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register. */
      [2] = (rw_reg32_t)0x40080108U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register. */
      [3] = (rw_reg32_t)0x4008011CU,   /** @brief OTG_HS device IN endpoint transmit FIFO size register. */
      [4] = (rw_reg32_t)0x40080120U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register. */
      [5] = (rw_reg32_t)0x40080124U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register. */
      [6] = (rw_reg32_t)0x40080128U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register. */
      [7] = (rw_reg32_t)0x4008012CU,   /** @brief OTG_HS device IN endpoint transmit FIFO size register. */
    },
  };

  static const ro_reg32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE[3] = {
    [1] = (ro_reg32_t)0x4004001CU,   /** @brief OTG_HS receive status debug read register (host mode). */
    [2] = (ro_reg32_t)0x4008001CU,   /** @brief OTG_HS receive status debug read register (host mode). */
  };

  static const ro_reg32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE[3] = {
    [1] = (ro_reg32_t)0x40040020U,   /** @brief OTG_HS status read and pop register (host mode). */
    [2] = (ro_reg32_t)0x40080020U,   /** @brief OTG_HS status read and pop register (host mode). */
  };

  static const rw_reg32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG[3] = {
    [1] = (rw_reg32_t)0x40040054U,   /** @brief OTG core LPM configuration register. */
    [2] = (rw_reg32_t)0x40080054U,   /** @brief OTG core LPM configuration register. */
  };

  /**** OTGx_HS_GLOBAL Register Field Definitions ****/

  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_SRQSCS            = {.msk = 0x00000001U, .pos = 0};    /** @brief Session request success. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_SRQ               = {.msk = 0x00000002U, .pos = 1};    /** @brief Session request. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_HNGSCS            = {.msk = 0x00000100U, .pos = 8};    /** @brief Host negotiation success. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_HNPRQ             = {.msk = 0x00000200U, .pos = 9};    /** @brief HNP request. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_HSHNPEN           = {.msk = 0x00000400U, .pos = 10};   /** @brief Host set HNP enable. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_DHNPEN            = {.msk = 0x00000800U, .pos = 11};   /** @brief Device HNP enabled. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_CIDSTS            = {.msk = 0x00010000U, .pos = 16};   /** @brief Connector ID status. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_DBCT              = {.msk = 0x00020000U, .pos = 17};   /** @brief Long/short debounce time. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_ASVLD             = {.msk = 0x00040000U, .pos = 18};   /** @brief A-session valid. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_BSVLD             = {.msk = 0x00080000U, .pos = 19};   /** @brief B-session valid. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_EHEN              = {.msk = 0x00001000U, .pos = 12};   /** @brief Embedded host enable. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GOTGINT_SEDET             = {.msk = 0x00000004U, .pos = 2};    /** @brief Session end detected. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GOTGINT_SRSSCHG           = {.msk = 0x00000100U, .pos = 8};    /** @brief Session request success status change. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GOTGINT_HNSSCHG           = {.msk = 0x00000200U, .pos = 9};    /** @brief Host negotiation success status change. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GOTGINT_HNGDET            = {.msk = 0x00020000U, .pos = 17};   /** @brief Host negotiation detected. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GOTGINT_ADTOCHG           = {.msk = 0x00040000U, .pos = 18};   /** @brief A-device timeout change. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GOTGINT_DBCDNE            = {.msk = 0x00080000U, .pos = 19};   /** @brief Debounce done. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GOTGINT_IDCHNG            = {.msk = 0x00100000U, .pos = 20};   /** @brief ID input pin changed. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GAHBCFG_GINT              = {.msk = 0x00000001U, .pos = 0};    /** @brief Global interrupt mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GAHBCFG_HBSTLEN           = {.msk = 0x0000001EU, .pos = 1};    /** @brief Burst length/type. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GAHBCFG_DMAEN             = {.msk = 0x00000020U, .pos = 5};    /** @brief DMA enable. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GAHBCFG_TXFELVL           = {.msk = 0x00000080U, .pos = 7};    /** @brief TxFIFO empty level. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GAHBCFG_PTXFELVL          = {.msk = 0x00000100U, .pos = 8};    /** @brief Periodic txfifo empty level. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_TOCAL             = {.msk = 0x00000007U, .pos = 0};    /** @brief FS timeout calibration. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_PHYSEL            = {.msk = 0x00000040U, .pos = 6};    /** @brief USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_SRPCAP            = {.msk = 0x00000100U, .pos = 8};    /** @brief SRP-capable. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_HNPCAP            = {.msk = 0x00000200U, .pos = 9};    /** @brief HNP-capable. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_TRDT              = {.msk = 0x00003C00U, .pos = 10};   /** @brief USB turnaround time. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_PHYLPCS           = {.msk = 0x00008000U, .pos = 15};   /** @brief PHY low-power clock select. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIFSLS          = {.msk = 0x00020000U, .pos = 17};   /** @brief ULPI FS/LS select. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIAR            = {.msk = 0x00040000U, .pos = 18};   /** @brief ULPI auto-resume. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_ULPICSM           = {.msk = 0x00080000U, .pos = 19};   /** @brief ULPI clock suspendm. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSD        = {.msk = 0x00100000U, .pos = 20};   /** @brief ULPI external VBUS drive. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSI        = {.msk = 0x00200000U, .pos = 21};   /** @brief ULPI external VBUS indicator. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_TSDPS             = {.msk = 0x00400000U, .pos = 22};   /** @brief TermSel dline pulsing selection. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_PCCI              = {.msk = 0x00800000U, .pos = 23};   /** @brief Indicator complement. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_PTCI              = {.msk = 0x01000000U, .pos = 24};   /** @brief Indicator pass through. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIIPD           = {.msk = 0x02000000U, .pos = 25};   /** @brief ULPI interface protect disable. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_FHMOD             = {.msk = 0x20000000U, .pos = 29};   /** @brief Forced host mode. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_FDMOD             = {.msk = 0x40000000U, .pos = 30};   /** @brief Forced peripheral mode. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_CSRST             = {.msk = 0x00000001U, .pos = 0};    /** @brief Core soft reset. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_HSRST             = {.msk = 0x00000002U, .pos = 1};    /** @brief HCLK soft reset. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_FCRST             = {.msk = 0x00000004U, .pos = 2};    /** @brief Host frame counter reset. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_RXFFLSH           = {.msk = 0x00000010U, .pos = 4};    /** @brief RxFIFO flush. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_TXFFLSH           = {.msk = 0x00000020U, .pos = 5};    /** @brief TxFIFO flush. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_TXFNUM            = {.msk = 0x000007C0U, .pos = 6};    /** @brief TxFIFO number. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_AHBIDL            = {.msk = 0x80000000U, .pos = 31};   /** @brief AHB master idle. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_DMAREQ            = {.msk = 0x40000000U, .pos = 30};   /** @brief DMA request signal enabled for USB OTG HS. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_CMOD              = {.msk = 0x00000001U, .pos = 0};    /** @brief Current mode of operation. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_MMIS              = {.msk = 0x00000002U, .pos = 1};    /** @brief Mode mismatch interrupt. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_OTGINT            = {.msk = 0x00000004U, .pos = 2};    /** @brief OTG interrupt. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_SOF               = {.msk = 0x00000008U, .pos = 3};    /** @brief Start of frame. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_RXFLVL            = {.msk = 0x00000010U, .pos = 4};    /** @brief RxFIFO nonempty. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_NPTXFE            = {.msk = 0x00000020U, .pos = 5};    /** @brief Nonperiodic txfifo empty. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_GINAKEFF          = {.msk = 0x00000040U, .pos = 6};    /** @brief Global IN nonperiodic NAK effective. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_BOUTNAKEFF        = {.msk = 0x00000080U, .pos = 7};    /** @brief Global OUT NAK effective. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_ESUSP             = {.msk = 0x00000400U, .pos = 10};   /** @brief Early suspend. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_USBSUSP           = {.msk = 0x00000800U, .pos = 11};   /** @brief USB suspend. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_USBRST            = {.msk = 0x00001000U, .pos = 12};   /** @brief USB reset. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_ENUMDNE           = {.msk = 0x00002000U, .pos = 13};   /** @brief Enumeration done. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_ISOODRP           = {.msk = 0x00004000U, .pos = 14};   /** @brief Isochronous OUT packet dropped interrupt. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_EOPF              = {.msk = 0x00008000U, .pos = 15};   /** @brief End of periodic frame interrupt. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_IEPINT            = {.msk = 0x00040000U, .pos = 18};   /** @brief IN endpoint interrupt. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_OEPINT            = {.msk = 0x00080000U, .pos = 19};   /** @brief OUT endpoint interrupt. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_IISOIXFR          = {.msk = 0x00100000U, .pos = 20};   /** @brief Incomplete isochronous IN transfer. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_PXFR_INCOMPISOOUT = {.msk = 0x00200000U, .pos = 21};   /** @brief Incomplete periodic transfer. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_DATAFSUSP         = {.msk = 0x00400000U, .pos = 22};   /** @brief Data fetch suspended. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_HPRTINT           = {.msk = 0x01000000U, .pos = 24};   /** @brief Host port interrupt. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_HCINT             = {.msk = 0x02000000U, .pos = 25};   /** @brief Host channels interrupt. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_PTXFE             = {.msk = 0x04000000U, .pos = 26};   /** @brief Periodic txfifo empty. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_CIDSCHG           = {.msk = 0x10000000U, .pos = 28};   /** @brief Connector ID status change. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_DISCINT           = {.msk = 0x20000000U, .pos = 29};   /** @brief Disconnect detected interrupt. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_SRQINT            = {.msk = 0x40000000U, .pos = 30};   /** @brief Session request/new session detected interrupt. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_WKUINT            = {.msk = 0x80000000U, .pos = 31};   /** @brief Resume/remote wakeup detected interrupt. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_MMISM             = {.msk = 0x00000002U, .pos = 1};    /** @brief Mode mismatch interrupt mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_OTGINT            = {.msk = 0x00000004U, .pos = 2};    /** @brief OTG interrupt mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_SOFM              = {.msk = 0x00000008U, .pos = 3};    /** @brief Start of frame mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_RXFLVLM           = {.msk = 0x00000010U, .pos = 4};    /** @brief Receive FIFO nonempty mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_NPTXFEM           = {.msk = 0x00000020U, .pos = 5};    /** @brief Nonperiodic txfifo empty mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_GINAKEFFM         = {.msk = 0x00000040U, .pos = 6};    /** @brief Global nonperiodic IN NAK effective mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_GONAKEFFM         = {.msk = 0x00000080U, .pos = 7};    /** @brief Global OUT NAK effective mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_ESUSPM            = {.msk = 0x00000400U, .pos = 10};   /** @brief Early suspend mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_USBSUSPM          = {.msk = 0x00000800U, .pos = 11};   /** @brief USB suspend mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_USBRST            = {.msk = 0x00001000U, .pos = 12};   /** @brief USB reset mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_ENUMDNEM          = {.msk = 0x00002000U, .pos = 13};   /** @brief Enumeration done mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_ISOODRPM          = {.msk = 0x00004000U, .pos = 14};   /** @brief Isochronous OUT packet dropped interrupt mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_EOPFM             = {.msk = 0x00008000U, .pos = 15};   /** @brief End of periodic frame interrupt mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_IEPINT            = {.msk = 0x00040000U, .pos = 18};   /** @brief IN endpoints interrupt mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_OEPINT            = {.msk = 0x00080000U, .pos = 19};   /** @brief OUT endpoints interrupt mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_IISOIXFRM         = {.msk = 0x00100000U, .pos = 20};   /** @brief Incomplete isochronous IN transfer mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_PXFRM_IISOOXFRM   = {.msk = 0x00200000U, .pos = 21};   /** @brief Incomplete periodic transfer mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_FSUSPM            = {.msk = 0x00400000U, .pos = 22};   /** @brief Data fetch suspended mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_PRTIM             = {.msk = 0x01000000U, .pos = 24};   /** @brief Host port interrupt mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_HCIM              = {.msk = 0x02000000U, .pos = 25};   /** @brief Host channels interrupt mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_PTXFEM            = {.msk = 0x04000000U, .pos = 26};   /** @brief Periodic txfifo empty mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_CIDSCHGM          = {.msk = 0x10000000U, .pos = 28};   /** @brief Connector ID status change mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_DISCINT           = {.msk = 0x20000000U, .pos = 29};   /** @brief Disconnect detected interrupt mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_SRQIM             = {.msk = 0x40000000U, .pos = 30};   /** @brief Session request/new session detected interrupt mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_WUIM              = {.msk = 0x80000000U, .pos = 31};   /** @brief Resume/remote wakeup detected interrupt mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_RSTDE             = {.msk = 0x00800000U, .pos = 23};   /** @brief Reset detected interrupt mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_LPMINTM           = {.msk = 0x08000000U, .pos = 27};   /** @brief LPM interrupt mask. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_CHNUM        = {.msk = 0x0000000FU, .pos = 0};    /** @brief Channel number. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_BCNT         = {.msk = 0x00007FF0U, .pos = 4};    /** @brief Byte count. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_DPID         = {.msk = 0x00018000U, .pos = 15};   /** @brief Data PID. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_PKTSTS       = {.msk = 0x001E0000U, .pos = 17};   /** @brief Packet status. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_CHNUM        = {.msk = 0x0000000FU, .pos = 0};    /** @brief Channel number. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_BCNT         = {.msk = 0x00007FF0U, .pos = 4};    /** @brief Byte count. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_DPID         = {.msk = 0x00018000U, .pos = 15};   /** @brief Data PID. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_PKTSTS       = {.msk = 0x001E0000U, .pos = 17};   /** @brief Packet status. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRXFSIZ_RXFD              = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief RxFIFO depth. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFSA    = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Nonperiodic transmit RAM start address. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFD     = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief Nonperiodic txfifo depth. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_TX0FSA    = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Endpoint 0 transmit RAM start address. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_TX0FD     = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief Endpoint 0 txfifo depth. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXFSAV         = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Nonperiodic txfifo space available. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTQXSAV         = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Nonperiodic transmit request queue space available. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXQTOP         = {.msk = 0x7F000000U, .pos = 24};   /** @brief Top of the nonperiodic transmit request queue. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_PWRDWN              = {.msk = 0x00010000U, .pos = 16};   /** @brief Power down. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_BCDEN               = {.msk = 0x00020000U, .pos = 17};   /** @brief Battery charging detector (BCD) enable. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_DCDEN               = {.msk = 0x00040000U, .pos = 18};   /** @brief Data contact detection (DCD) mode enable. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_PDEN                = {.msk = 0x00080000U, .pos = 19};   /** @brief Primary detection (PD) mode enable. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_SDEN                = {.msk = 0x00100000U, .pos = 20};   /** @brief Secondary detection (SD) mode enable. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_VBDEN               = {.msk = 0x00200000U, .pos = 21};   /** @brief USB VBUS detection enable. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_DCDET               = {.msk = 0x00000001U, .pos = 0};    /** @brief Data contact detection (DCD) status. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_PDET                = {.msk = 0x00000002U, .pos = 1};    /** @brief Primary detection (PD) status. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_SDET                = {.msk = 0x00000004U, .pos = 2};    /** @brief Secondary detection (SD) status. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_PS2DET              = {.msk = 0x00000008U, .pos = 3};    /** @brief DM pull-up detection status. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXSA            = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Host periodic txfifo start address. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXFD            = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief Host periodic txfifo depth. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_DIEPTXFx_INEPTXSA         = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief IN endpoint fifox transmit RAM start address. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_DIEPTXFx_INEPTXFD         = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief IN endpoint txfifo depth. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_EPNUM      = {.msk = 0x0000000FU, .pos = 0};    /** @brief Endpoint number. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_BCNT       = {.msk = 0x00007FF0U, .pos = 4};    /** @brief Byte count. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_DPID       = {.msk = 0x00018000U, .pos = 15};   /** @brief Data PID. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_PKTSTS     = {.msk = 0x001E0000U, .pos = 17};   /** @brief Packet status. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_FRMNUM     = {.msk = 0x01E00000U, .pos = 21};   /** @brief Frame number. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_EPNUM      = {.msk = 0x0000000FU, .pos = 0};    /** @brief Endpoint number. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_BCNT       = {.msk = 0x00007FF0U, .pos = 4};    /** @brief Byte count. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_DPID       = {.msk = 0x00018000U, .pos = 15};   /** @brief Data PID. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_PKTSTS     = {.msk = 0x001E0000U, .pos = 17};   /** @brief Packet status. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_FRMNUM     = {.msk = 0x01E00000U, .pos = 21};   /** @brief Frame number. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_LPMEN             = {.msk = 0x00000001U, .pos = 0};    /** @brief LPM support enable. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_LPMACK            = {.msk = 0x00000002U, .pos = 1};    /** @brief LPM token acknowledge enable. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_BESL              = {.msk = 0x0000003CU, .pos = 2};    /** @brief Best effort service latency. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_REMWAKE           = {.msk = 0x00000040U, .pos = 6};    /** @brief BRemoteWake value. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_L1SSEN            = {.msk = 0x00000080U, .pos = 7};    /** @brief L1 shallow sleep enable. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_BESLTHRS          = {.msk = 0x00000F00U, .pos = 8};    /** @brief BESL threshold. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_L1DSEN            = {.msk = 0x00001000U, .pos = 12};   /** @brief L1 deep sleep enable. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRST            = {.msk = 0x00006000U, .pos = 13};   /** @brief LPM response. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_SLPSTS            = {.msk = 0x00008000U, .pos = 15};   /** @brief Port sleep status. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_L1RSMOK           = {.msk = 0x00010000U, .pos = 16};   /** @brief Sleep state resume OK. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_LPMCHIDX          = {.msk = 0x001E0000U, .pos = 17};   /** @brief LPM channel index. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNT           = {.msk = 0x00E00000U, .pos = 21};   /** @brief LPM retry count. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_SNDLPM            = {.msk = 0x01000000U, .pos = 24};   /** @brief Send LPM transaction. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNTSTS        = {.msk = 0x0E000000U, .pos = 25};   /** @brief LPM retry count status. */
  static const field32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_ENBESL            = {.msk = 0x10000000U, .pos = 28};   /** @brief Enable best effort service latency. */

  /************************************************************************************************
   * OTGx_HS_HOST Definitions
   ************************************************************************************************/

  /**** Enumerated OTGx_HS_HOST Register Definitions ****/

  static const rw_reg32_t OTGx_HS_HOST_OTG_HS_HCFG[3] = {
    [1] = (rw_reg32_t)0x40040400U,   /** @brief OTG_HS host configuration register. */
    [2] = (rw_reg32_t)0x40080400U,   /** @brief OTG_HS host configuration register. */
  };

  static const rw_reg32_t OTGx_HS_HOST_OTG_HS_HFIR[3] = {
    [1] = (rw_reg32_t)0x40040404U,   /** @brief OTG_HS host frame interval register. */
    [2] = (rw_reg32_t)0x40080404U,   /** @brief OTG_HS host frame interval register. */
  };

  static const ro_reg32_t OTGx_HS_HOST_OTG_HS_HFNUM[3] = {
    [1] = (ro_reg32_t)0x40040408U,   /** @brief OTG_HS host frame number/frame time remaining register. */
    [2] = (ro_reg32_t)0x40080408U,   /** @brief OTG_HS host frame number/frame time remaining register. */
  };

  static const rw_reg32_t OTGx_HS_HOST_OTG_HS_HPTXSTS[3] = {
    [1] = (rw_reg32_t)0x40040410U,   /** @brief OTG_HS_Host periodic transmit fifo/queue status register. */
    [2] = (rw_reg32_t)0x40080410U,   /** @brief OTG_HS_Host periodic transmit fifo/queue status register. */
  };

  static const ro_reg32_t OTGx_HS_HOST_OTG_HS_HAINT[3] = {
    [1] = (ro_reg32_t)0x40040414U,   /** @brief OTG_HS host all channels interrupt register. */
    [2] = (ro_reg32_t)0x40080414U,   /** @brief OTG_HS host all channels interrupt register. */
  };

  static const rw_reg32_t OTGx_HS_HOST_OTG_HS_HAINTMSK[3] = {
    [1] = (rw_reg32_t)0x40040418U,   /** @brief OTG_HS host all channels interrupt mask register. */
    [2] = (rw_reg32_t)0x40080418U,   /** @brief OTG_HS host all channels interrupt mask register. */
  };

  static const rw_reg32_t OTGx_HS_HOST_OTG_HS_HPRT[3] = {
    [1] = (rw_reg32_t)0x40040440U,   /** @brief OTG_HS host port control and status register. */
    [2] = (rw_reg32_t)0x40080440U,   /** @brief OTG_HS host port control and status register. */
  };

  static const rw_reg32_t OTGx_HS_HOST_OTG_HS_HCCHARx[3][16] = {
    [1] = {
      [0]  = (rw_reg32_t)0x40040500U,   /** @brief OTG_HS host channel-0 characteristics register. */
      [1]  = (rw_reg32_t)0x40040520U,   /** @brief OTG_HS host channel-1 characteristics register. */
      [2]  = (rw_reg32_t)0x40040540U,   /** @brief OTG_HS host channel-2 characteristics register. */
      [3]  = (rw_reg32_t)0x40040560U,   /** @brief OTG_HS host channel-3 characteristics register. */
      [4]  = (rw_reg32_t)0x40040580U,   /** @brief OTG_HS host channel-4 characteristics register. */
      [5]  = (rw_reg32_t)0x400405A0U,   /** @brief OTG_HS host channel-5 characteristics register. */
      [6]  = (rw_reg32_t)0x400405C0U,   /** @brief OTG_HS host channel-6 characteristics register. */
      [7]  = (rw_reg32_t)0x400405E0U,   /** @brief OTG_HS host channel-7 characteristics register. */
      [8]  = (rw_reg32_t)0x40040600U,   /** @brief OTG_HS host channel-8 characteristics register. */
      [9]  = (rw_reg32_t)0x40040620U,   /** @brief OTG_HS host channel-9 characteristics register. */
      [10] = (rw_reg32_t)0x40040640U,   /** @brief OTG_HS host channel-10 characteristics register. */
      [11] = (rw_reg32_t)0x40040660U,   /** @brief OTG_HS host channel-11 characteristics register. */
      [12] = (rw_reg32_t)0x40040678U,   /** @brief OTG_HS host channel-12 characteristics register. */
      [13] = (rw_reg32_t)0x40040690U,   /** @brief OTG_HS host channel-13 characteristics register. */
      [14] = (rw_reg32_t)0x400406A8U,   /** @brief OTG_HS host channel-14 characteristics register. */
      [15] = (rw_reg32_t)0x400406C0U,   /** @brief OTG_HS host channel-15 characteristics register. */
    },
    [2] = {
      [0]  = (rw_reg32_t)0x40080500U,   /** @brief OTG_HS host channel-0 characteristics register. */
      [1]  = (rw_reg32_t)0x40080520U,   /** @brief OTG_HS host channel-1 characteristics register. */
      [2]  = (rw_reg32_t)0x40080540U,   /** @brief OTG_HS host channel-2 characteristics register. */
      [3]  = (rw_reg32_t)0x40080560U,   /** @brief OTG_HS host channel-3 characteristics register. */
      [4]  = (rw_reg32_t)0x40080580U,   /** @brief OTG_HS host channel-4 characteristics register. */
      [5]  = (rw_reg32_t)0x400805A0U,   /** @brief OTG_HS host channel-5 characteristics register. */
      [6]  = (rw_reg32_t)0x400805C0U,   /** @brief OTG_HS host channel-6 characteristics register. */
      [7]  = (rw_reg32_t)0x400805E0U,   /** @brief OTG_HS host channel-7 characteristics register. */
      [8]  = (rw_reg32_t)0x40080600U,   /** @brief OTG_HS host channel-8 characteristics register. */
      [9]  = (rw_reg32_t)0x40080620U,   /** @brief OTG_HS host channel-9 characteristics register. */
      [10] = (rw_reg32_t)0x40080640U,   /** @brief OTG_HS host channel-10 characteristics register. */
      [11] = (rw_reg32_t)0x40080660U,   /** @brief OTG_HS host channel-11 characteristics register. */
      [12] = (rw_reg32_t)0x40080678U,   /** @brief OTG_HS host channel-12 characteristics register. */
      [13] = (rw_reg32_t)0x40080690U,   /** @brief OTG_HS host channel-13 characteristics register. */
      [14] = (rw_reg32_t)0x400806A8U,   /** @brief OTG_HS host channel-14 characteristics register. */
      [15] = (rw_reg32_t)0x400806C0U,   /** @brief OTG_HS host channel-15 characteristics register. */
    },
  };

  static const rw_reg32_t OTGx_HS_HOST_OTG_HS_HCSPLTx[3][16] = {
    [1] = {
      [0]  = (rw_reg32_t)0x40040504U,   /** @brief OTG_HS host channel-0 split control register. */
      [1]  = (rw_reg32_t)0x40040524U,   /** @brief OTG_HS host channel-1 split control register. */
      [2]  = (rw_reg32_t)0x40040544U,   /** @brief OTG_HS host channel-2 split control register. */
      [3]  = (rw_reg32_t)0x40040564U,   /** @brief OTG_HS host channel-3 split control register. */
      [4]  = (rw_reg32_t)0x40040584U,   /** @brief OTG_HS host channel-4 split control register. */
      [5]  = (rw_reg32_t)0x400405A4U,   /** @brief OTG_HS host channel-5 split control register. */
      [6]  = (rw_reg32_t)0x400405C4U,   /** @brief OTG_HS host channel-6 split control register. */
      [7]  = (rw_reg32_t)0x400405E4U,   /** @brief OTG_HS host channel-7 split control register. */
      [8]  = (rw_reg32_t)0x40040604U,   /** @brief OTG_HS host channel-8 split control register. */
      [9]  = (rw_reg32_t)0x40040624U,   /** @brief OTG_HS host channel-9 split control register. */
      [10] = (rw_reg32_t)0x40040644U,   /** @brief OTG_HS host channel-10 split control register. */
      [11] = (rw_reg32_t)0x40040664U,   /** @brief OTG_HS host channel-11 split control register. */
      [12] = (rw_reg32_t)0x4004067CU,   /** @brief OTG_HS host channel-12 split control register. */
      [13] = (rw_reg32_t)0x40040694U,   /** @brief OTG_HS host channel-13 split control register. */
      [14] = (rw_reg32_t)0x400406ACU,   /** @brief OTG_HS host channel-14 split control register. */
      [15] = (rw_reg32_t)0x400406C4U,   /** @brief OTG_HS host channel-15 split control register. */
    },
    [2] = {
      [0]  = (rw_reg32_t)0x40080504U,   /** @brief OTG_HS host channel-0 split control register. */
      [1]  = (rw_reg32_t)0x40080524U,   /** @brief OTG_HS host channel-1 split control register. */
      [2]  = (rw_reg32_t)0x40080544U,   /** @brief OTG_HS host channel-2 split control register. */
      [3]  = (rw_reg32_t)0x40080564U,   /** @brief OTG_HS host channel-3 split control register. */
      [4]  = (rw_reg32_t)0x40080584U,   /** @brief OTG_HS host channel-4 split control register. */
      [5]  = (rw_reg32_t)0x400805A4U,   /** @brief OTG_HS host channel-5 split control register. */
      [6]  = (rw_reg32_t)0x400805C4U,   /** @brief OTG_HS host channel-6 split control register. */
      [7]  = (rw_reg32_t)0x400805E4U,   /** @brief OTG_HS host channel-7 split control register. */
      [8]  = (rw_reg32_t)0x40080604U,   /** @brief OTG_HS host channel-8 split control register. */
      [9]  = (rw_reg32_t)0x40080624U,   /** @brief OTG_HS host channel-9 split control register. */
      [10] = (rw_reg32_t)0x40080644U,   /** @brief OTG_HS host channel-10 split control register. */
      [11] = (rw_reg32_t)0x40080664U,   /** @brief OTG_HS host channel-11 split control register. */
      [12] = (rw_reg32_t)0x4008067CU,   /** @brief OTG_HS host channel-12 split control register. */
      [13] = (rw_reg32_t)0x40080694U,   /** @brief OTG_HS host channel-13 split control register. */
      [14] = (rw_reg32_t)0x400806ACU,   /** @brief OTG_HS host channel-14 split control register. */
      [15] = (rw_reg32_t)0x400806C4U,   /** @brief OTG_HS host channel-15 split control register. */
    },
  };

  static const rw_reg32_t OTGx_HS_HOST_OTG_HS_HCINTx[3][16] = {
    [1] = {
      [0]  = (rw_reg32_t)0x40040508U,   /** @brief OTG_HS host channel-11 interrupt register. */
      [1]  = (rw_reg32_t)0x40040528U,   /** @brief OTG_HS host channel-1 interrupt register. */
      [2]  = (rw_reg32_t)0x40040548U,   /** @brief OTG_HS host channel-2 interrupt register. */
      [3]  = (rw_reg32_t)0x40040568U,   /** @brief OTG_HS host channel-3 interrupt register. */
      [4]  = (rw_reg32_t)0x40040588U,   /** @brief OTG_HS host channel-4 interrupt register. */
      [5]  = (rw_reg32_t)0x400405A8U,   /** @brief OTG_HS host channel-5 interrupt register. */
      [6]  = (rw_reg32_t)0x400405C8U,   /** @brief OTG_HS host channel-6 interrupt register. */
      [7]  = (rw_reg32_t)0x400405E8U,   /** @brief OTG_HS host channel-7 interrupt register. */
      [8]  = (rw_reg32_t)0x40040608U,   /** @brief OTG_HS host channel-8 interrupt register. */
      [9]  = (rw_reg32_t)0x40040628U,   /** @brief OTG_HS host channel-9 interrupt register. */
      [10] = (rw_reg32_t)0x40040648U,   /** @brief OTG_HS host channel-10 interrupt register. */
      [11] = (rw_reg32_t)0x40040668U,   /** @brief OTG_HS host channel-11 interrupt register. */
      [12] = (rw_reg32_t)0x40040680U,   /** @brief OTG_HS host channel-12 interrupt register. */
      [13] = (rw_reg32_t)0x40040698U,   /** @brief OTG_HS host channel-13 interrupt register. */
      [14] = (rw_reg32_t)0x400406B0U,   /** @brief OTG_HS host channel-14 interrupt register. */
      [15] = (rw_reg32_t)0x400406C8U,   /** @brief OTG_HS host channel-15 interrupt register. */
    },
    [2] = {
      [0]  = (rw_reg32_t)0x40080508U,   /** @brief OTG_HS host channel-11 interrupt register. */
      [1]  = (rw_reg32_t)0x40080528U,   /** @brief OTG_HS host channel-1 interrupt register. */
      [2]  = (rw_reg32_t)0x40080548U,   /** @brief OTG_HS host channel-2 interrupt register. */
      [3]  = (rw_reg32_t)0x40080568U,   /** @brief OTG_HS host channel-3 interrupt register. */
      [4]  = (rw_reg32_t)0x40080588U,   /** @brief OTG_HS host channel-4 interrupt register. */
      [5]  = (rw_reg32_t)0x400805A8U,   /** @brief OTG_HS host channel-5 interrupt register. */
      [6]  = (rw_reg32_t)0x400805C8U,   /** @brief OTG_HS host channel-6 interrupt register. */
      [7]  = (rw_reg32_t)0x400805E8U,   /** @brief OTG_HS host channel-7 interrupt register. */
      [8]  = (rw_reg32_t)0x40080608U,   /** @brief OTG_HS host channel-8 interrupt register. */
      [9]  = (rw_reg32_t)0x40080628U,   /** @brief OTG_HS host channel-9 interrupt register. */
      [10] = (rw_reg32_t)0x40080648U,   /** @brief OTG_HS host channel-10 interrupt register. */
      [11] = (rw_reg32_t)0x40080668U,   /** @brief OTG_HS host channel-11 interrupt register. */
      [12] = (rw_reg32_t)0x40080680U,   /** @brief OTG_HS host channel-12 interrupt register. */
      [13] = (rw_reg32_t)0x40080698U,   /** @brief OTG_HS host channel-13 interrupt register. */
      [14] = (rw_reg32_t)0x400806B0U,   /** @brief OTG_HS host channel-14 interrupt register. */
      [15] = (rw_reg32_t)0x400806C8U,   /** @brief OTG_HS host channel-15 interrupt register. */
    },
  };

  static const rw_reg32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx[3][16] = {
    [1] = {
      [0]  = (rw_reg32_t)0x4004050CU,   /** @brief OTG_HS host channel-11 interrupt mask register. */
      [1]  = (rw_reg32_t)0x4004052CU,   /** @brief OTG_HS host channel-1 interrupt mask register. */
      [2]  = (rw_reg32_t)0x4004054CU,   /** @brief OTG_HS host channel-2 interrupt mask register. */
      [3]  = (rw_reg32_t)0x4004056CU,   /** @brief OTG_HS host channel-3 interrupt mask register. */
      [4]  = (rw_reg32_t)0x4004058CU,   /** @brief OTG_HS host channel-4 interrupt mask register. */
      [5]  = (rw_reg32_t)0x400405ACU,   /** @brief OTG_HS host channel-5 interrupt mask register. */
      [6]  = (rw_reg32_t)0x400405CCU,   /** @brief OTG_HS host channel-6 interrupt mask register. */
      [7]  = (rw_reg32_t)0x400405ECU,   /** @brief OTG_HS host channel-7 interrupt mask register. */
      [8]  = (rw_reg32_t)0x4004060CU,   /** @brief OTG_HS host channel-8 interrupt mask register. */
      [9]  = (rw_reg32_t)0x4004062CU,   /** @brief OTG_HS host channel-9 interrupt mask register. */
      [10] = (rw_reg32_t)0x4004064CU,   /** @brief OTG_HS host channel-10 interrupt mask register. */
      [11] = (rw_reg32_t)0x4004066CU,   /** @brief OTG_HS host channel-11 interrupt mask register. */
      [12] = (rw_reg32_t)0x40040684U,   /** @brief OTG_HS host channel-12 interrupt mask register. */
      [13] = (rw_reg32_t)0x4004069CU,   /** @brief OTG_HS host channel-13 interrupt mask register. */
      [14] = (rw_reg32_t)0x400406B4U,   /** @brief OTG_HS host channel-14 interrupt mask register. */
      [15] = (rw_reg32_t)0x400406CCU,   /** @brief OTG_HS host channel-15 interrupt mask register. */
    },
    [2] = {
      [0]  = (rw_reg32_t)0x4008050CU,   /** @brief OTG_HS host channel-11 interrupt mask register. */
      [1]  = (rw_reg32_t)0x4008052CU,   /** @brief OTG_HS host channel-1 interrupt mask register. */
      [2]  = (rw_reg32_t)0x4008054CU,   /** @brief OTG_HS host channel-2 interrupt mask register. */
      [3]  = (rw_reg32_t)0x4008056CU,   /** @brief OTG_HS host channel-3 interrupt mask register. */
      [4]  = (rw_reg32_t)0x4008058CU,   /** @brief OTG_HS host channel-4 interrupt mask register. */
      [5]  = (rw_reg32_t)0x400805ACU,   /** @brief OTG_HS host channel-5 interrupt mask register. */
      [6]  = (rw_reg32_t)0x400805CCU,   /** @brief OTG_HS host channel-6 interrupt mask register. */
      [7]  = (rw_reg32_t)0x400805ECU,   /** @brief OTG_HS host channel-7 interrupt mask register. */
      [8]  = (rw_reg32_t)0x4008060CU,   /** @brief OTG_HS host channel-8 interrupt mask register. */
      [9]  = (rw_reg32_t)0x4008062CU,   /** @brief OTG_HS host channel-9 interrupt mask register. */
      [10] = (rw_reg32_t)0x4008064CU,   /** @brief OTG_HS host channel-10 interrupt mask register. */
      [11] = (rw_reg32_t)0x4008066CU,   /** @brief OTG_HS host channel-11 interrupt mask register. */
      [12] = (rw_reg32_t)0x40080684U,   /** @brief OTG_HS host channel-12 interrupt mask register. */
      [13] = (rw_reg32_t)0x4008069CU,   /** @brief OTG_HS host channel-13 interrupt mask register. */
      [14] = (rw_reg32_t)0x400806B4U,   /** @brief OTG_HS host channel-14 interrupt mask register. */
      [15] = (rw_reg32_t)0x400806CCU,   /** @brief OTG_HS host channel-15 interrupt mask register. */
    },
  };

  static const rw_reg32_t OTGx_HS_HOST_OTG_HS_HCTSIZx[3][16] = {
    [1] = {
      [0]  = (rw_reg32_t)0x40040510U,   /** @brief OTG_HS host channel-11 transfer size register. */
      [1]  = (rw_reg32_t)0x40040530U,   /** @brief OTG_HS host channel-1 transfer size register. */
      [2]  = (rw_reg32_t)0x40040550U,   /** @brief OTG_HS host channel-2 transfer size register. */
      [3]  = (rw_reg32_t)0x40040570U,   /** @brief OTG_HS host channel-3 transfer size register. */
      [4]  = (rw_reg32_t)0x40040590U,   /** @brief OTG_HS host channel-4 transfer size register. */
      [5]  = (rw_reg32_t)0x400405B0U,   /** @brief OTG_HS host channel-5 transfer size register. */
      [6]  = (rw_reg32_t)0x400405D0U,   /** @brief OTG_HS host channel-6 transfer size register. */
      [7]  = (rw_reg32_t)0x400405F0U,   /** @brief OTG_HS host channel-7 transfer size register. */
      [8]  = (rw_reg32_t)0x40040610U,   /** @brief OTG_HS host channel-8 transfer size register. */
      [9]  = (rw_reg32_t)0x40040630U,   /** @brief OTG_HS host channel-9 transfer size register. */
      [10] = (rw_reg32_t)0x40040650U,   /** @brief OTG_HS host channel-10 transfer size register. */
      [11] = (rw_reg32_t)0x40040670U,   /** @brief OTG_HS host channel-11 transfer size register. */
      [12] = (rw_reg32_t)0x40040688U,   /** @brief OTG_HS host channel-12 transfer size register. */
      [13] = (rw_reg32_t)0x400406A0U,   /** @brief OTG_HS host channel-13 transfer size register. */
      [14] = (rw_reg32_t)0x400406B8U,   /** @brief OTG_HS host channel-14 transfer size register. */
      [15] = (rw_reg32_t)0x400406D0U,   /** @brief OTG_HS host channel-15 transfer size register. */
    },
    [2] = {
      [0]  = (rw_reg32_t)0x40080510U,   /** @brief OTG_HS host channel-11 transfer size register. */
      [1]  = (rw_reg32_t)0x40080530U,   /** @brief OTG_HS host channel-1 transfer size register. */
      [2]  = (rw_reg32_t)0x40080550U,   /** @brief OTG_HS host channel-2 transfer size register. */
      [3]  = (rw_reg32_t)0x40080570U,   /** @brief OTG_HS host channel-3 transfer size register. */
      [4]  = (rw_reg32_t)0x40080590U,   /** @brief OTG_HS host channel-4 transfer size register. */
      [5]  = (rw_reg32_t)0x400805B0U,   /** @brief OTG_HS host channel-5 transfer size register. */
      [6]  = (rw_reg32_t)0x400805D0U,   /** @brief OTG_HS host channel-6 transfer size register. */
      [7]  = (rw_reg32_t)0x400805F0U,   /** @brief OTG_HS host channel-7 transfer size register. */
      [8]  = (rw_reg32_t)0x40080610U,   /** @brief OTG_HS host channel-8 transfer size register. */
      [9]  = (rw_reg32_t)0x40080630U,   /** @brief OTG_HS host channel-9 transfer size register. */
      [10] = (rw_reg32_t)0x40080650U,   /** @brief OTG_HS host channel-10 transfer size register. */
      [11] = (rw_reg32_t)0x40080670U,   /** @brief OTG_HS host channel-11 transfer size register. */
      [12] = (rw_reg32_t)0x40080688U,   /** @brief OTG_HS host channel-12 transfer size register. */
      [13] = (rw_reg32_t)0x400806A0U,   /** @brief OTG_HS host channel-13 transfer size register. */
      [14] = (rw_reg32_t)0x400806B8U,   /** @brief OTG_HS host channel-14 transfer size register. */
      [15] = (rw_reg32_t)0x400806D0U,   /** @brief OTG_HS host channel-15 transfer size register. */
    },
  };

  static const rw_reg32_t OTGx_HS_HOST_OTG_HS_HCDMAx[3][16] = {
    [1] = {
      [0]  = (rw_reg32_t)0x40040514U,   /** @brief OTG_HS host channel-0 DMA address register. */
      [1]  = (rw_reg32_t)0x40040534U,   /** @brief OTG_HS host channel-1 DMA address register. */
      [2]  = (rw_reg32_t)0x40040554U,   /** @brief OTG_HS host channel-2 DMA address register. */
      [3]  = (rw_reg32_t)0x40040574U,   /** @brief OTG_HS host channel-3 DMA address register. */
      [4]  = (rw_reg32_t)0x40040594U,   /** @brief OTG_HS host channel-4 DMA address register. */
      [5]  = (rw_reg32_t)0x400405B4U,   /** @brief OTG_HS host channel-5 DMA address register. */
      [6]  = (rw_reg32_t)0x400405D4U,   /** @brief OTG_HS host channel-6 DMA address register. */
      [7]  = (rw_reg32_t)0x400405F4U,   /** @brief OTG_HS host channel-7 DMA address register. */
      [8]  = (rw_reg32_t)0x40040614U,   /** @brief OTG_HS host channel-8 DMA address register. */
      [9]  = (rw_reg32_t)0x40040634U,   /** @brief OTG_HS host channel-9 DMA address register. */
      [10] = (rw_reg32_t)0x40040654U,   /** @brief OTG_HS host channel-10 DMA address register. */
      [11] = (rw_reg32_t)0x40040674U,   /** @brief OTG_HS host channel-11 DMA address register. */
      [12] = (rw_reg32_t)0x4004068CU,   /** @brief OTG_HS host channel-12 DMA address register. */
      [13] = (rw_reg32_t)0x400406A4U,   /** @brief OTG_HS host channel-13 DMA address register. */
      [14] = (rw_reg32_t)0x400406BCU,   /** @brief OTG_HS host channel-14 DMA address register. */
      [15] = (rw_reg32_t)0x400406D4U,   /** @brief OTG_HS host channel-15 DMA address register. */
    },
    [2] = {
      [0]  = (rw_reg32_t)0x40080514U,   /** @brief OTG_HS host channel-0 DMA address register. */
      [1]  = (rw_reg32_t)0x40080534U,   /** @brief OTG_HS host channel-1 DMA address register. */
      [2]  = (rw_reg32_t)0x40080554U,   /** @brief OTG_HS host channel-2 DMA address register. */
      [3]  = (rw_reg32_t)0x40080574U,   /** @brief OTG_HS host channel-3 DMA address register. */
      [4]  = (rw_reg32_t)0x40080594U,   /** @brief OTG_HS host channel-4 DMA address register. */
      [5]  = (rw_reg32_t)0x400805B4U,   /** @brief OTG_HS host channel-5 DMA address register. */
      [6]  = (rw_reg32_t)0x400805D4U,   /** @brief OTG_HS host channel-6 DMA address register. */
      [7]  = (rw_reg32_t)0x400805F4U,   /** @brief OTG_HS host channel-7 DMA address register. */
      [8]  = (rw_reg32_t)0x40080614U,   /** @brief OTG_HS host channel-8 DMA address register. */
      [9]  = (rw_reg32_t)0x40080634U,   /** @brief OTG_HS host channel-9 DMA address register. */
      [10] = (rw_reg32_t)0x40080654U,   /** @brief OTG_HS host channel-10 DMA address register. */
      [11] = (rw_reg32_t)0x40080674U,   /** @brief OTG_HS host channel-11 DMA address register. */
      [12] = (rw_reg32_t)0x4008068CU,   /** @brief OTG_HS host channel-12 DMA address register. */
      [13] = (rw_reg32_t)0x400806A4U,   /** @brief OTG_HS host channel-13 DMA address register. */
      [14] = (rw_reg32_t)0x400806BCU,   /** @brief OTG_HS host channel-14 DMA address register. */
      [15] = (rw_reg32_t)0x400806D4U,   /** @brief OTG_HS host channel-15 DMA address register. */
    },
  };

  /**** OTGx_HS_HOST Register Field Definitions ****/

  static const field32_t OTGx_HS_HOST_OTG_HS_HCFG_FSLSPCS      = {.msk = 0x00000003U, .pos = 0};    /** @brief FS/LS PHY clock select. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCFG_FSLSS        = {.msk = 0x00000004U, .pos = 2};    /** @brief FS- and ls-only support. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HFIR_FRIVL        = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Frame interval. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HFNUM_FRNUM       = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Frame number. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HFNUM_FTREM       = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief Frame time remaining. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HPTXSTS_PTXFSAVL  = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Periodic transmit data FIFO space available. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HPTXSTS_PTXQSAV   = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Periodic transmit request queue space available. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HPTXSTS_PTXQTOP   = {.msk = 0xFF000000U, .pos = 24};   /** @brief Top of the periodic transmit request queue. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HAINT_HAINT       = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Channel interrupts. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HAINTMSK_HAINTM   = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Channel interrupt mask. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HPRT_PCSTS        = {.msk = 0x00000001U, .pos = 0};    /** @brief Port connect status. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HPRT_PCDET        = {.msk = 0x00000002U, .pos = 1};    /** @brief Port connect detected. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HPRT_PENA         = {.msk = 0x00000004U, .pos = 2};    /** @brief Port enable. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HPRT_PENCHNG      = {.msk = 0x00000008U, .pos = 3};    /** @brief Port enable/disable change. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HPRT_POCA         = {.msk = 0x00000010U, .pos = 4};    /** @brief Port overcurrent active. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HPRT_POCCHNG      = {.msk = 0x00000020U, .pos = 5};    /** @brief Port overcurrent change. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HPRT_PRES         = {.msk = 0x00000040U, .pos = 6};    /** @brief Port resume. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HPRT_PSUSP        = {.msk = 0x00000080U, .pos = 7};    /** @brief Port suspend. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HPRT_PRST         = {.msk = 0x00000100U, .pos = 8};    /** @brief Port reset. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HPRT_PLSTS        = {.msk = 0x00000C00U, .pos = 10};   /** @brief Port line status. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HPRT_PPWR         = {.msk = 0x00001000U, .pos = 12};   /** @brief Port power. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HPRT_PTCTL        = {.msk = 0x0001E000U, .pos = 13};   /** @brief Port test control. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HPRT_PSPD         = {.msk = 0x00060000U, .pos = 17};   /** @brief Port speed. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCCHARx_MPSIZ     = {.msk = 0x000007FFU, .pos = 0};    /** @brief Maximum packet size. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCCHARx_EPNUM     = {.msk = 0x00007800U, .pos = 11};   /** @brief Endpoint number. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCCHARx_EPDIR     = {.msk = 0x00008000U, .pos = 15};   /** @brief Endpoint direction. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCCHARx_LSDEV     = {.msk = 0x00020000U, .pos = 17};   /** @brief Low-speed device. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCCHARx_EPTYP     = {.msk = 0x000C0000U, .pos = 18};   /** @brief Endpoint type. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCCHARx_MC        = {.msk = 0x00300000U, .pos = 20};   /** @brief Multi count (MC) / error count (EC). */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCCHARx_DAD       = {.msk = 0x1FC00000U, .pos = 22};   /** @brief Device address. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCCHARx_ODDFRM    = {.msk = 0x20000000U, .pos = 29};   /** @brief Odd frame. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCCHARx_CHDIS     = {.msk = 0x40000000U, .pos = 30};   /** @brief Channel disable. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCCHARx_CHENA     = {.msk = 0x80000000U, .pos = 31};   /** @brief Channel enable. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_PRTADDR   = {.msk = 0x0000007FU, .pos = 0};    /** @brief Port address. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_HUBADDR   = {.msk = 0x00003F80U, .pos = 7};    /** @brief Hub address. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_XACTPOS   = {.msk = 0x0000C000U, .pos = 14};   /** @brief XACTPOS. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_COMPLSPLT = {.msk = 0x00010000U, .pos = 16};   /** @brief Do complete split. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_SPLITEN   = {.msk = 0x80000000U, .pos = 31};   /** @brief Split enable. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCINTx_XFRC       = {.msk = 0x00000001U, .pos = 0};    /** @brief Transfer completed. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCINTx_CHH        = {.msk = 0x00000002U, .pos = 1};    /** @brief Channel halted. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCINTx_AHBERR     = {.msk = 0x00000004U, .pos = 2};    /** @brief AHB error. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCINTx_STALL      = {.msk = 0x00000008U, .pos = 3};    /** @brief STALL response received interrupt. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCINTx_NAK        = {.msk = 0x00000010U, .pos = 4};    /** @brief NAK response received interrupt. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCINTx_ACK        = {.msk = 0x00000020U, .pos = 5};    /** @brief ACK response received/transmitted interrupt. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCINTx_NYET       = {.msk = 0x00000040U, .pos = 6};    /** @brief Response received interrupt. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCINTx_TXERR      = {.msk = 0x00000080U, .pos = 7};    /** @brief Transaction error. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCINTx_BBERR      = {.msk = 0x00000100U, .pos = 8};    /** @brief Babble error. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCINTx_FRMOR      = {.msk = 0x00000200U, .pos = 9};    /** @brief Frame overrun. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCINTx_DTERR      = {.msk = 0x00000400U, .pos = 10};   /** @brief Data toggle error. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_XFRCM   = {.msk = 0x00000001U, .pos = 0};    /** @brief Transfer completed mask. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_CHHM    = {.msk = 0x00000002U, .pos = 1};    /** @brief Channel halted mask. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_AHBERR  = {.msk = 0x00000004U, .pos = 2};    /** @brief AHB error. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_STALLM  = {.msk = 0x00000008U, .pos = 3};    /** @brief STALL response received interrupt mask. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_NAKM    = {.msk = 0x00000010U, .pos = 4};    /** @brief NAK response received interrupt mask. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_ACKM    = {.msk = 0x00000020U, .pos = 5};    /** @brief ACK response received/transmitted interrupt mask. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_NYET    = {.msk = 0x00000040U, .pos = 6};    /** @brief Response received interrupt mask. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_TXERRM  = {.msk = 0x00000080U, .pos = 7};    /** @brief Transaction error mask. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_BBERRM  = {.msk = 0x00000100U, .pos = 8};    /** @brief Babble error mask. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_FRMORM  = {.msk = 0x00000200U, .pos = 9};    /** @brief Frame overrun mask. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_DTERRM  = {.msk = 0x00000400U, .pos = 10};   /** @brief Data toggle error mask. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCTSIZx_XFRSIZ    = {.msk = 0x0007FFFFU, .pos = 0};    /** @brief Transfer size. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCTSIZx_PKTCNT    = {.msk = 0x1FF80000U, .pos = 19};   /** @brief Packet count. */
  static const field32_t OTGx_HS_HOST_OTG_HS_HCTSIZx_DPID      = {.msk = 0x60000000U, .pos = 29};   /** @brief Data PID. */

  /************************************************************************************************
   * OTGx_HS_DEVICE Definitions
   ************************************************************************************************/

  /**** Enumerated OTGx_HS_DEVICE Register Definitions ****/

  static const rw_reg32_t OTGx_HS_DEVICE_OTG_HS_DCFG[3] = {
    [1] = (rw_reg32_t)0x40040800U,   /** @brief OTG_HS device configuration register. */
    [2] = (rw_reg32_t)0x40080800U,   /** @brief OTG_HS device configuration register. */
  };

  static const rw_reg32_t OTGx_HS_DEVICE_OTG_HS_DCTL[3] = {
    [1] = (rw_reg32_t)0x40040804U,   /** @brief OTG_HS device control register. */
    [2] = (rw_reg32_t)0x40080804U,   /** @brief OTG_HS device control register. */
  };

  static const ro_reg32_t OTGx_HS_DEVICE_OTG_HS_DSTS[3] = {
    [1] = (ro_reg32_t)0x40040808U,   /** @brief OTG_HS device status register. */
    [2] = (ro_reg32_t)0x40080808U,   /** @brief OTG_HS device status register. */
  };

  static const rw_reg32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK[3] = {
    [1] = (rw_reg32_t)0x40040810U,   /** @brief OTG_HS device IN endpoint common interrupt mask register. */
    [2] = (rw_reg32_t)0x40080810U,   /** @brief OTG_HS device IN endpoint common interrupt mask register. */
  };

  static const rw_reg32_t OTGx_HS_DEVICE_OTG_HS_DOEPMSK[3] = {
    [1] = (rw_reg32_t)0x40040814U,   /** @brief OTG_HS device OUT endpoint common interrupt mask register. */
    [2] = (rw_reg32_t)0x40080814U,   /** @brief OTG_HS device OUT endpoint common interrupt mask register. */
  };

  static const ro_reg32_t OTGx_HS_DEVICE_OTG_HS_DAINT[3] = {
    [1] = (ro_reg32_t)0x40040818U,   /** @brief OTG_HS device all endpoints interrupt register. */
    [2] = (ro_reg32_t)0x40080818U,   /** @brief OTG_HS device all endpoints interrupt register. */
  };

  static const rw_reg32_t OTGx_HS_DEVICE_OTG_HS_DAINTMSK[3] = {
    [1] = (rw_reg32_t)0x4004081CU,   /** @brief OTG_HS all endpoints interrupt mask register. */
    [2] = (rw_reg32_t)0x4008081CU,   /** @brief OTG_HS all endpoints interrupt mask register. */
  };

  static const rw_reg32_t OTGx_HS_DEVICE_OTG_HS_DVBUSDIS[3] = {
    [1] = (rw_reg32_t)0x40040828U,   /** @brief OTG_HS device VBUS discharge time register. */
    [2] = (rw_reg32_t)0x40080828U,   /** @brief OTG_HS device VBUS discharge time register. */
  };

  static const rw_reg32_t OTGx_HS_DEVICE_OTG_HS_DVBUSPULSE[3] = {
    [1] = (rw_reg32_t)0x4004082CU,   /** @brief OTG_HS device VBUS pulsing time register. */
    [2] = (rw_reg32_t)0x4008082CU,   /** @brief OTG_HS device VBUS pulsing time register. */
  };

  static const rw_reg32_t OTGx_HS_DEVICE_OTG_HS_DTHRCTL[3] = {
    [1] = (rw_reg32_t)0x40040830U,   /** @brief OTG_HS device threshold control register. */
    [2] = (rw_reg32_t)0x40080830U,   /** @brief OTG_HS device threshold control register. */
  };

  static const rw_reg32_t OTGx_HS_DEVICE_OTG_HS_DIEPEMPMSK[3] = {
    [1] = (rw_reg32_t)0x40040834U,   /** @brief OTG_HS device IN endpoint FIFO empty interrupt mask register. */
    [2] = (rw_reg32_t)0x40080834U,   /** @brief OTG_HS device IN endpoint FIFO empty interrupt mask register. */
  };

  static const rw_reg32_t OTGx_HS_DEVICE_OTG_HS_DEACHINT[3] = {
    [1] = (rw_reg32_t)0x40040838U,   /** @brief OTG_HS device each endpoint interrupt register. */
    [2] = (rw_reg32_t)0x40080838U,   /** @brief OTG_HS device each endpoint interrupt register. */
  };

  static const rw_reg32_t OTGx_HS_DEVICE_OTG_HS_DEACHINTMSK[3] = {
    [1] = (rw_reg32_t)0x4004083CU,   /** @brief OTG_HS device each endpoint interrupt register mask. */
    [2] = (rw_reg32_t)0x4008083CU,   /** @brief OTG_HS device each endpoint interrupt register mask. */
  };

  static const rw_reg32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx[3][8] = {
    [1] = {
      [0] = (rw_reg32_t)0x40040900U,   /** @brief OTG device endpoint-0 control register. */
      [1] = (rw_reg32_t)0x40040920U,   /** @brief OTG device endpoint-1 control register. */
      [2] = (rw_reg32_t)0x40040940U,   /** @brief OTG device endpoint-2 control register. */
      [3] = (rw_reg32_t)0x40040960U,   /** @brief OTG device endpoint-3 control register. */
      [4] = (rw_reg32_t)0x40040980U,   /** @brief OTG device endpoint-4 control register. */
      [5] = (rw_reg32_t)0x400409A0U,   /** @brief OTG device endpoint-5 control register. */
      [6] = (rw_reg32_t)0x400409C0U,   /** @brief OTG device endpoint-6 control register. */
      [7] = (rw_reg32_t)0x400409E0U,   /** @brief OTG device endpoint-7 control register. */
    },
    [2] = {
      [0] = (rw_reg32_t)0x40080900U,   /** @brief OTG device endpoint-0 control register. */
      [1] = (rw_reg32_t)0x40080920U,   /** @brief OTG device endpoint-1 control register. */
      [2] = (rw_reg32_t)0x40080940U,   /** @brief OTG device endpoint-2 control register. */
      [3] = (rw_reg32_t)0x40080960U,   /** @brief OTG device endpoint-3 control register. */
      [4] = (rw_reg32_t)0x40080980U,   /** @brief OTG device endpoint-4 control register. */
      [5] = (rw_reg32_t)0x400809A0U,   /** @brief OTG device endpoint-5 control register. */
      [6] = (rw_reg32_t)0x400809C0U,   /** @brief OTG device endpoint-6 control register. */
      [7] = (rw_reg32_t)0x400809E0U,   /** @brief OTG device endpoint-7 control register. */
    },
  };

  static const rw_reg32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx[3][8] = {
    [1] = {
      [0] = (rw_reg32_t)0x40040908U,   /** @brief OTG device endpoint-0 interrupt register. */
      [1] = (rw_reg32_t)0x40040928U,   /** @brief OTG device endpoint-1 interrupt register. */
      [2] = (rw_reg32_t)0x40040948U,   /** @brief OTG device endpoint-2 interrupt register. */
      [3] = (rw_reg32_t)0x40040968U,   /** @brief OTG device endpoint-3 interrupt register. */
      [4] = (rw_reg32_t)0x40040988U,   /** @brief OTG device endpoint-4 interrupt register. */
      [5] = (rw_reg32_t)0x400409A8U,   /** @brief OTG device endpoint-5 interrupt register. */
      [6] = (rw_reg32_t)0x400409C8U,   /** @brief OTG device endpoint-6 interrupt register. */
      [7] = (rw_reg32_t)0x400409E8U,   /** @brief OTG device endpoint-7 interrupt register. */
    },
    [2] = {
      [0] = (rw_reg32_t)0x40080908U,   /** @brief OTG device endpoint-0 interrupt register. */
      [1] = (rw_reg32_t)0x40080928U,   /** @brief OTG device endpoint-1 interrupt register. */
      [2] = (rw_reg32_t)0x40080948U,   /** @brief OTG device endpoint-2 interrupt register. */
      [3] = (rw_reg32_t)0x40080968U,   /** @brief OTG device endpoint-3 interrupt register. */
      [4] = (rw_reg32_t)0x40080988U,   /** @brief OTG device endpoint-4 interrupt register. */
      [5] = (rw_reg32_t)0x400809A8U,   /** @brief OTG device endpoint-5 interrupt register. */
      [6] = (rw_reg32_t)0x400809C8U,   /** @brief OTG device endpoint-6 interrupt register. */
      [7] = (rw_reg32_t)0x400809E8U,   /** @brief OTG device endpoint-7 interrupt register. */
    },
  };

  static const rw_reg32_t OTGx_HS_DEVICE_OTG_HS_DIEPTSIZx[3][8] = {
    [1] = {
      [0] = (rw_reg32_t)0x40040910U,   /** @brief OTG_HS device IN endpoint 0 transfer size register. */
      [1] = (rw_reg32_t)0x40040930U,   /** @brief OTG_HS device endpoint transfer size register. */
      [2] = (rw_reg32_t)0x40040950U,   /** @brief OTG_HS device endpoint transfer size register. */
      [3] = (rw_reg32_t)0x40040970U,   /** @brief OTG_HS device endpoint transfer size register. */
      [4] = (rw_reg32_t)0x40040990U,   /** @brief OTG_HS device endpoint transfer size register. */
      [5] = (rw_reg32_t)0x400409B0U,   /** @brief OTG_HS device endpoint transfer size register. */
      [6] = (rw_reg32_t)0x400409A0U,   /** @brief OTG_HS device endpoint transfer size register. */
      [7] = (rw_reg32_t)0x400409A8U,   /** @brief OTG_HS device endpoint transfer size register. */
    },
    [2] = {
      [0] = (rw_reg32_t)0x40080910U,   /** @brief OTG_HS device IN endpoint 0 transfer size register. */
      [1] = (rw_reg32_t)0x40080930U,   /** @brief OTG_HS device endpoint transfer size register. */
      [2] = (rw_reg32_t)0x40080950U,   /** @brief OTG_HS device endpoint transfer size register. */
      [3] = (rw_reg32_t)0x40080970U,   /** @brief OTG_HS device endpoint transfer size register. */
      [4] = (rw_reg32_t)0x40080990U,   /** @brief OTG_HS device endpoint transfer size register. */
      [5] = (rw_reg32_t)0x400809B0U,   /** @brief OTG_HS device endpoint transfer size register. */
      [6] = (rw_reg32_t)0x400809A0U,   /** @brief OTG_HS device endpoint transfer size register. */
      [7] = (rw_reg32_t)0x400809A8U,   /** @brief OTG_HS device endpoint transfer size register. */
    },
  };

  static const rw_reg32_t OTGx_HS_DEVICE_OTG_HS_DIEPDMAx[3][6] = {
    [1] = {
      [1] = (rw_reg32_t)0x40040914U,   /** @brief OTG_HS device endpoint-1 DMA address register. */
      [2] = (rw_reg32_t)0x40040934U,   /** @brief OTG_HS device endpoint-2 DMA address register. */
      [3] = (rw_reg32_t)0x40040954U,   /** @brief OTG_HS device endpoint-3 DMA address register. */
      [4] = (rw_reg32_t)0x40040974U,   /** @brief OTG_HS device endpoint-4 DMA address register. */
      [5] = (rw_reg32_t)0x40040994U,   /** @brief OTG_HS device endpoint-5 DMA address register. */
    },
    [2] = {
      [1] = (rw_reg32_t)0x40080914U,   /** @brief OTG_HS device endpoint-1 DMA address register. */
      [2] = (rw_reg32_t)0x40080934U,   /** @brief OTG_HS device endpoint-2 DMA address register. */
      [3] = (rw_reg32_t)0x40080954U,   /** @brief OTG_HS device endpoint-3 DMA address register. */
      [4] = (rw_reg32_t)0x40080974U,   /** @brief OTG_HS device endpoint-4 DMA address register. */
      [5] = (rw_reg32_t)0x40080994U,   /** @brief OTG_HS device endpoint-5 DMA address register. */
    },
  };

  static const ro_reg32_t OTGx_HS_DEVICE_OTG_HS_DTXFSTSx[3][8] = {
    [1] = {
      [0] = (ro_reg32_t)0x40040918U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register. */
      [1] = (ro_reg32_t)0x40040938U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register. */
      [2] = (ro_reg32_t)0x40040958U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register. */
      [3] = (ro_reg32_t)0x40040978U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register. */
      [4] = (ro_reg32_t)0x40040998U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register. */
      [5] = (ro_reg32_t)0x400409B8U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register. */
      [6] = (ro_reg32_t)0x400409A4U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register. */
      [7] = (ro_reg32_t)0x400409ACU,   /** @brief OTG_HS device IN endpoint transmit FIFO status register. */
    },
    [2] = {
      [0] = (ro_reg32_t)0x40080918U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register. */
      [1] = (ro_reg32_t)0x40080938U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register. */
      [2] = (ro_reg32_t)0x40080958U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register. */
      [3] = (ro_reg32_t)0x40080978U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register. */
      [4] = (ro_reg32_t)0x40080998U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register. */
      [5] = (ro_reg32_t)0x400809B8U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register. */
      [6] = (ro_reg32_t)0x400809A4U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register. */
      [7] = (ro_reg32_t)0x400809ACU,   /** @brief OTG_HS device IN endpoint transmit FIFO status register. */
    },
  };

  static const rw_reg32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx[3][8] = {
    [1] = {
      [0] = (rw_reg32_t)0x40040B00U,   /** @brief OTG_HS device control OUT endpoint 0 control register. */
      [1] = (rw_reg32_t)0x40040B20U,   /** @brief OTG device endpoint-1 control register. */
      [2] = (rw_reg32_t)0x40040B40U,   /** @brief OTG device endpoint-2 control register. */
      [3] = (rw_reg32_t)0x40040B60U,   /** @brief OTG device endpoint-3 control register. */
      [4] = (rw_reg32_t)0x40040B80U,   /** @brief OTG device endpoint-4 control register. */
      [5] = (rw_reg32_t)0x40040BA0U,   /** @brief OTG device endpoint-5 control register. */
      [6] = (rw_reg32_t)0x40040BC0U,   /** @brief OTG device endpoint-6 control register. */
      [7] = (rw_reg32_t)0x40040BE0U,   /** @brief OTG device endpoint-7 control register. */
    },
    [2] = {
      [0] = (rw_reg32_t)0x40080B00U,   /** @brief OTG_HS device control OUT endpoint 0 control register. */
      [1] = (rw_reg32_t)0x40080B20U,   /** @brief OTG device endpoint-1 control register. */
      [2] = (rw_reg32_t)0x40080B40U,   /** @brief OTG device endpoint-2 control register. */
      [3] = (rw_reg32_t)0x40080B60U,   /** @brief OTG device endpoint-3 control register. */
      [4] = (rw_reg32_t)0x40080B80U,   /** @brief OTG device endpoint-4 control register. */
      [5] = (rw_reg32_t)0x40080BA0U,   /** @brief OTG device endpoint-5 control register. */
      [6] = (rw_reg32_t)0x40080BC0U,   /** @brief OTG device endpoint-6 control register. */
      [7] = (rw_reg32_t)0x40080BE0U,   /** @brief OTG device endpoint-7 control register. */
    },
  };

  static const rw_reg32_t OTGx_HS_DEVICE_OTG_HS_DOEPINTx[3][8] = {
    [1] = {
      [0] = (rw_reg32_t)0x40040B08U,   /** @brief OTG_HS device endpoint-0 interrupt register. */
      [1] = (rw_reg32_t)0x40040B28U,   /** @brief OTG_HS device endpoint-1 interrupt register. */
      [2] = (rw_reg32_t)0x40040B48U,   /** @brief OTG_HS device endpoint-2 interrupt register. */
      [3] = (rw_reg32_t)0x40040B68U,   /** @brief OTG_HS device endpoint-3 interrupt register. */
      [4] = (rw_reg32_t)0x40040B88U,   /** @brief OTG_HS device endpoint-4 interrupt register. */
      [5] = (rw_reg32_t)0x40040BA8U,   /** @brief OTG_HS device endpoint-5 interrupt register. */
      [6] = (rw_reg32_t)0x40040BC8U,   /** @brief OTG_HS device endpoint-6 interrupt register. */
      [7] = (rw_reg32_t)0x40040BE8U,   /** @brief OTG_HS device endpoint-7 interrupt register. */
    },
    [2] = {
      [0] = (rw_reg32_t)0x40080B08U,   /** @brief OTG_HS device endpoint-0 interrupt register. */
      [1] = (rw_reg32_t)0x40080B28U,   /** @brief OTG_HS device endpoint-1 interrupt register. */
      [2] = (rw_reg32_t)0x40080B48U,   /** @brief OTG_HS device endpoint-2 interrupt register. */
      [3] = (rw_reg32_t)0x40080B68U,   /** @brief OTG_HS device endpoint-3 interrupt register. */
      [4] = (rw_reg32_t)0x40080B88U,   /** @brief OTG_HS device endpoint-4 interrupt register. */
      [5] = (rw_reg32_t)0x40080BA8U,   /** @brief OTG_HS device endpoint-5 interrupt register. */
      [6] = (rw_reg32_t)0x40080BC8U,   /** @brief OTG_HS device endpoint-6 interrupt register. */
      [7] = (rw_reg32_t)0x40080BE8U,   /** @brief OTG_HS device endpoint-7 interrupt register. */
    },
  };

  static const rw_reg32_t OTGx_HS_DEVICE_OTG_HS_DOEPTSIZx[3][8] = {
    [1] = {
      [0] = (rw_reg32_t)0x40040B10U,   /** @brief OTG_HS device endpoint-0 transfer size register. */
      [1] = (rw_reg32_t)0x40040B30U,   /** @brief OTG_HS device endpoint-1 transfer size register. */
      [2] = (rw_reg32_t)0x40040B50U,   /** @brief OTG_HS device endpoint-2 transfer size register. */
      [3] = (rw_reg32_t)0x40040B70U,   /** @brief OTG_HS device endpoint-3 transfer size register. */
      [4] = (rw_reg32_t)0x40040B90U,   /** @brief OTG_HS device endpoint-4 transfer size register. */
      [5] = (rw_reg32_t)0x40040BB0U,   /** @brief OTG_HS device endpoint-5 transfer size register. */
      [6] = (rw_reg32_t)0x40040BD0U,   /** @brief OTG_HS device endpoint-6 transfer size register. */
      [7] = (rw_reg32_t)0x40040BF0U,   /** @brief OTG_HS device endpoint-7 transfer size register. */
    },
    [2] = {
      [0] = (rw_reg32_t)0x40080B10U,   /** @brief OTG_HS device endpoint-0 transfer size register. */
      [1] = (rw_reg32_t)0x40080B30U,   /** @brief OTG_HS device endpoint-1 transfer size register. */
      [2] = (rw_reg32_t)0x40080B50U,   /** @brief OTG_HS device endpoint-2 transfer size register. */
      [3] = (rw_reg32_t)0x40080B70U,   /** @brief OTG_HS device endpoint-3 transfer size register. */
      [4] = (rw_reg32_t)0x40080B90U,   /** @brief OTG_HS device endpoint-4 transfer size register. */
      [5] = (rw_reg32_t)0x40080BB0U,   /** @brief OTG_HS device endpoint-5 transfer size register. */
      [6] = (rw_reg32_t)0x40080BD0U,   /** @brief OTG_HS device endpoint-6 transfer size register. */
      [7] = (rw_reg32_t)0x40080BF0U,   /** @brief OTG_HS device endpoint-7 transfer size register. */
    },
  };

  /**** OTGx_HS_DEVICE Register Field Definitions ****/

  static const field32_t OTGx_HS_DEVICE_OTG_HS_DCFG_DSPD               = {.msk = 0x00000003U, .pos = 0};    /** @brief Device speed. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DCFG_NZLSOHSK           = {.msk = 0x00000004U, .pos = 2};    /** @brief Nonzero-length status OUT handshake. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DCFG_DAD                = {.msk = 0x000007F0U, .pos = 4};    /** @brief Device address. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DCFG_PFIVL              = {.msk = 0x00001800U, .pos = 11};   /** @brief Periodic (micro)frame interval. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DCFG_PERSCHIVL          = {.msk = 0x03000000U, .pos = 24};   /** @brief Periodic scheduling interval. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DCTL_RWUSIG             = {.msk = 0x00000001U, .pos = 0};    /** @brief Remote wakeup signaling. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DCTL_SDIS               = {.msk = 0x00000002U, .pos = 1};    /** @brief Soft disconnect. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DCTL_GINSTS             = {.msk = 0x00000004U, .pos = 2};    /** @brief Global IN NAK status. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DCTL_GONSTS             = {.msk = 0x00000008U, .pos = 3};    /** @brief Global OUT NAK status. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DCTL_TCTL               = {.msk = 0x00000070U, .pos = 4};    /** @brief Test control. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DCTL_SGINAK             = {.msk = 0x00000080U, .pos = 7};    /** @brief Set global IN NAK. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DCTL_CGINAK             = {.msk = 0x00000100U, .pos = 8};    /** @brief Clear global IN NAK. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DCTL_SGONAK             = {.msk = 0x00000200U, .pos = 9};    /** @brief Set global OUT NAK. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DCTL_CGONAK             = {.msk = 0x00000400U, .pos = 10};   /** @brief Clear global OUT NAK. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DCTL_POPRGDNE           = {.msk = 0x00000800U, .pos = 11};   /** @brief Power-on programming done. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DSTS_SUSPSTS            = {.msk = 0x00000001U, .pos = 0};    /** @brief Suspend status. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DSTS_ENUMSPD            = {.msk = 0x00000006U, .pos = 1};    /** @brief Enumerated speed. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DSTS_EERR               = {.msk = 0x00000008U, .pos = 3};    /** @brief Erratic error. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DSTS_FNSOF              = {.msk = 0x003FFF00U, .pos = 8};    /** @brief Frame number of the received SOF. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_XFRCM           = {.msk = 0x00000001U, .pos = 0};    /** @brief Transfer completed interrupt mask. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_EPDM            = {.msk = 0x00000002U, .pos = 1};    /** @brief Endpoint disabled interrupt mask. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_TOM             = {.msk = 0x00000008U, .pos = 3};    /** @brief Timeout condition mask (nonisochronous endpoints). */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_ITTXFEMSK       = {.msk = 0x00000010U, .pos = 4};    /** @brief IN token received when txfifo empty mask. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_INEPNMM         = {.msk = 0x00000020U, .pos = 5};    /** @brief IN token received with EP mismatch mask. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_INEPNEM         = {.msk = 0x00000040U, .pos = 6};    /** @brief IN endpoint NAK effective mask. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_TXFURM          = {.msk = 0x00000100U, .pos = 8};    /** @brief FIFO underrun mask. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_BIM             = {.msk = 0x00000200U, .pos = 9};    /** @brief BNA interrupt mask. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPMSK_XFRCM           = {.msk = 0x00000001U, .pos = 0};    /** @brief Transfer completed interrupt mask. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPMSK_EPDM            = {.msk = 0x00000002U, .pos = 1};    /** @brief Endpoint disabled interrupt mask. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPMSK_STUPM           = {.msk = 0x00000008U, .pos = 3};    /** @brief SETUP phase done mask. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPMSK_OTEPDM          = {.msk = 0x00000010U, .pos = 4};    /** @brief OUT token received when endpoint disabled mask. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPMSK_B2BSTUP         = {.msk = 0x00000040U, .pos = 6};    /** @brief Back-to-back SETUP packets received mask. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPMSK_OPEM            = {.msk = 0x00000100U, .pos = 8};    /** @brief OUT packet error mask. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPMSK_BOIM            = {.msk = 0x00000200U, .pos = 9};    /** @brief BNA interrupt mask. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DAINT_IEPINT            = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief IN endpoint interrupt bits. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DAINT_OEPINT            = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief OUT endpoint interrupt bits. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DAINTMSK_IEPM           = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief IN EP interrupt mask bits. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DAINTMSK_OEPM           = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief OUT EP interrupt mask bits. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DVBUSDIS_VBUSDT         = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Device VBUS discharge time. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DVBUSPULSE_DVBUSP       = {.msk = 0x00000FFFU, .pos = 0};    /** @brief Device VBUS pulsing time. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DTHRCTL_NONISOTHREN     = {.msk = 0x00000001U, .pos = 0};    /** @brief Nonisochronous IN endpoints threshold enable. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DTHRCTL_ISOTHREN        = {.msk = 0x00000002U, .pos = 1};    /** @brief ISO IN endpoint threshold enable. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DTHRCTL_TXTHRLEN        = {.msk = 0x000007FCU, .pos = 2};    /** @brief Transmit threshold length. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DTHRCTL_RXTHREN         = {.msk = 0x00010000U, .pos = 16};   /** @brief Receive threshold enable. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DTHRCTL_RXTHRLEN        = {.msk = 0x03FE0000U, .pos = 17};   /** @brief Receive threshold length. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DTHRCTL_ARPEN           = {.msk = 0x08000000U, .pos = 27};   /** @brief Arbiter parking enable. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPEMPMSK_INEPTXFEM    = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief IN EP tx FIFO empty interrupt mask bits. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DEACHINT_IEP1INT        = {.msk = 0x00000002U, .pos = 1};    /** @brief IN endpoint 1interrupt bit. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DEACHINT_OEP1INT        = {.msk = 0x00020000U, .pos = 17};   /** @brief OUT endpoint 1 interrupt bit. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DEACHINTMSK_IEP1INTM    = {.msk = 0x00000002U, .pos = 1};    /** @brief IN endpoint 1 interrupt mask bit. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DEACHINTMSK_OEP1INTM    = {.msk = 0x00020000U, .pos = 17};   /** @brief OUT endpoint 1 interrupt mask bit. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_MPSIZ          = {.msk = 0x000007FFU, .pos = 0};    /** @brief Maximum packet size. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_USBAEP         = {.msk = 0x00008000U, .pos = 15};   /** @brief USB active endpoint. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_EONUM_DPID     = {.msk = 0x00010000U, .pos = 16};   /** @brief Even/odd frame. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_NAKSTS         = {.msk = 0x00020000U, .pos = 17};   /** @brief NAK status. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_EPTYP          = {.msk = 0x000C0000U, .pos = 18};   /** @brief Endpoint type. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_STALL          = {.msk = 0x00200000U, .pos = 21};   /** @brief STALL handshake. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_TXFNUM         = {.msk = 0x03C00000U, .pos = 22};   /** @brief TxFIFO number. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_CNAK           = {.msk = 0x04000000U, .pos = 26};   /** @brief Clear NAK. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_SNAK           = {.msk = 0x08000000U, .pos = 27};   /** @brief Set NAK. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_SD0PID_SEVNFRM = {.msk = 0x10000000U, .pos = 28};   /** @brief Set DATA0 PID. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_SODDFRM        = {.msk = 0x20000000U, .pos = 29};   /** @brief Set odd frame. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_EPDIS          = {.msk = 0x40000000U, .pos = 30};   /** @brief Endpoint disable. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_EPENA          = {.msk = 0x80000000U, .pos = 31};   /** @brief Endpoint enable. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_XFRC           = {.msk = 0x00000001U, .pos = 0};    /** @brief Transfer completed interrupt. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_EPDISD         = {.msk = 0x00000002U, .pos = 1};    /** @brief Endpoint disabled interrupt. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_TOC            = {.msk = 0x00000008U, .pos = 3};    /** @brief Timeout condition. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_ITTXFE         = {.msk = 0x00000010U, .pos = 4};    /** @brief IN token received when txfifo is empty. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_INEPNE         = {.msk = 0x00000040U, .pos = 6};    /** @brief IN endpoint NAK effective. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_TXFE           = {.msk = 0x00000080U, .pos = 7};    /** @brief Transmit FIFO empty. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_TXFIFOUDRN     = {.msk = 0x00000100U, .pos = 8};    /** @brief Transmit fifo underrun. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_BNA            = {.msk = 0x00000200U, .pos = 9};    /** @brief Buffer not available interrupt. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_PKTDRPSTS      = {.msk = 0x00000800U, .pos = 11};   /** @brief Packet dropped status. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_BERR           = {.msk = 0x00001000U, .pos = 12};   /** @brief Babble error interrupt. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_NAK            = {.msk = 0x00002000U, .pos = 13};   /** @brief NAK interrupt. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPTSIZx_XFRSIZ        = {.msk = 0x0000007FU, .pos = 0};    /** @brief Transfer size. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DIEPTSIZx_PKTCNT        = {.msk = 0x00180000U, .pos = 19};   /** @brief Packet count. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DTXFSTSx_INEPTFSAV      = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief IN endpoint txfifo space avail. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_MPSIZ          = {.msk = 0x00000003U, .pos = 0};    /** @brief Maximum packet size. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_USBAEP         = {.msk = 0x00008000U, .pos = 15};   /** @brief USB active endpoint. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_NAKSTS         = {.msk = 0x00020000U, .pos = 17};   /** @brief NAK status. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_EPTYP          = {.msk = 0x000C0000U, .pos = 18};   /** @brief Endpoint type. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_SNPM           = {.msk = 0x00100000U, .pos = 20};   /** @brief Snoop mode. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_STALL          = {.msk = 0x00200000U, .pos = 21};   /** @brief STALL handshake. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_CNAK           = {.msk = 0x04000000U, .pos = 26};   /** @brief Clear NAK. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_SNAK           = {.msk = 0x08000000U, .pos = 27};   /** @brief Set NAK. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_EPDIS          = {.msk = 0x40000000U, .pos = 30};   /** @brief Endpoint disable. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_EPENA          = {.msk = 0x80000000U, .pos = 31};   /** @brief Endpoint enable. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPINTx_XFRC           = {.msk = 0x00000001U, .pos = 0};    /** @brief Transfer completed interrupt. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPINTx_EPDISD         = {.msk = 0x00000002U, .pos = 1};    /** @brief Endpoint disabled interrupt. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPINTx_STUP           = {.msk = 0x00000008U, .pos = 3};    /** @brief SETUP phase done. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPINTx_OTEPDIS        = {.msk = 0x00000010U, .pos = 4};    /** @brief OUT token received when endpoint disabled. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPINTx_B2BSTUP        = {.msk = 0x00000040U, .pos = 6};    /** @brief Back-to-back SETUP packets received. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPINTx_NYET           = {.msk = 0x00004000U, .pos = 14};   /** @brief NYET interrupt. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPTSIZx_XFRSIZ        = {.msk = 0x0000007FU, .pos = 0};    /** @brief Transfer size. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPTSIZx_PKTCNT        = {.msk = 0x00080000U, .pos = 19};   /** @brief Packet count. */
  static const field32_t OTGx_HS_DEVICE_OTG_HS_DOEPTSIZx_STUPCNT       = {.msk = 0x60000000U, .pos = 29};   /** @brief SETUP packet count. */

  /************************************************************************************************
   * OTGx_HS_PWRCLK Definitions
   ************************************************************************************************/

  /**** Enumerated OTGx_HS_PWRCLK Register Definitions ****/

  static const rw_reg32_t OTGx_HS_PWRCLK_OTG_HS_PCGCR[3] = {
    [1] = (rw_reg32_t)0x40040E00U,   /** @brief Power and clock gating control register. */
    [2] = (rw_reg32_t)0x40080E00U,   /** @brief Power and clock gating control register. */
  };

  /**** OTGx_HS_PWRCLK Register Field Definitions ****/

  static const field32_t OTGx_HS_PWRCLK_OTG_HS_PCGCR_STPPCLK  = {.msk = 0x00000001U, .pos = 0};   /** @brief Stop PHY clock. */
  static const field32_t OTGx_HS_PWRCLK_OTG_HS_PCGCR_GATEHCLK = {.msk = 0x00000002U, .pos = 1};   /** @brief Gate HCLK. */
  static const field32_t OTGx_HS_PWRCLK_OTG_HS_PCGCR_PHYSUSP  = {.msk = 0x00000010U, .pos = 4};   /** @brief PHY suspended. */

  /************************************************************************************************
   * ETHERNET_MAC Definitions
   ************************************************************************************************/

  /**** ETHERNET_MAC Register Definitions ****/

  static const rw_reg32_t ETHERNET_MAC_DMAMR                              = (rw_reg32_t)0x40029000U;   /** @brief DMA mode register. */
  static const rw_reg32_t ETHERNET_MAC_DMASBMR                            = (rw_reg32_t)0x40029004U;   /** @brief System bus mode register. */
  static const ro_reg32_t ETHERNET_MAC_DMAISR                             = (ro_reg32_t)0x40029008U;   /** @brief Interrupt status register. */
  static const ro_reg32_t ETHERNET_MAC_DMADSR                             = (ro_reg32_t)0x4002900CU;   /** @brief Debug status register. */
  static const rw_reg32_t ETHERNET_MAC_DMACCR                             = (rw_reg32_t)0x40029100U;   /** @brief Channel control register. */
  static const rw_reg32_t ETHERNET_MAC_DMACTXCR                           = (rw_reg32_t)0x40029104U;   /** @brief Channel transmit control register. */
  static const rw_reg32_t ETHERNET_MAC_DMACRXCR                           = (rw_reg32_t)0x40029108U;   /** @brief Channel receive control register. */
  static const rw_reg32_t ETHERNET_MAC_DMACTXDLAR                         = (rw_reg32_t)0x40029114U;   /** @brief Channel tx descriptor list address register. */
  static const rw_reg32_t ETHERNET_MAC_DMACRXDLAR                         = (rw_reg32_t)0x4002911CU;   /** @brief Channel rx descriptor list address register. */
  static const rw_reg32_t ETHERNET_MAC_DMACTXDTPR                         = (rw_reg32_t)0x40029120U;   /** @brief Channel tx descriptor tail pointer register. */
  static const rw_reg32_t ETHERNET_MAC_DMACRXDTPR                         = (rw_reg32_t)0x40029128U;   /** @brief Channel rx descriptor tail pointer register. */
  static const rw_reg32_t ETHERNET_MAC_DMACTXRLR                          = (rw_reg32_t)0x4002912CU;   /** @brief Channel tx descriptor ring length register. */
  static const rw_reg32_t ETHERNET_MAC_DMACRXRLR                          = (rw_reg32_t)0x40029130U;   /** @brief Channel rx descriptor ring length register. */
  static const rw_reg32_t ETHERNET_MAC_DMACIER                            = (rw_reg32_t)0x40029134U;   /** @brief Channel interrupt enable register. */
  static const rw_reg32_t ETHERNET_MAC_DMACRXIWTR                         = (rw_reg32_t)0x40029138U;   /** @brief Channel rx interrupt watchdog timer register. */
  static const ro_reg32_t ETHERNET_MAC_DMACCATXDR                         = (ro_reg32_t)0x40029144U;   /** @brief Channel current application transmit descriptor register. */
  static const ro_reg32_t ETHERNET_MAC_DMACCARXDR                         = (ro_reg32_t)0x4002914CU;   /** @brief Channel current application receive descriptor register. */
  static const ro_reg32_t ETHERNET_MAC_DMACCATXBR                         = (ro_reg32_t)0x40029154U;   /** @brief Channel current application transmit buffer register. */
  static const ro_reg32_t ETHERNET_MAC_DMACCARXBR                         = (ro_reg32_t)0x4002915CU;   /** @brief Channel current application receive buffer register. */
  static const rw_reg32_t ETHERNET_MAC_DMACSR                             = (rw_reg32_t)0x40029160U;   /** @brief Channel status register. */
  static const ro_reg32_t ETHERNET_MAC_DMACMFCR                           = (ro_reg32_t)0x4002916CU;   /** @brief Channel missed frame count register. */
  static const rw_reg32_t ETHERNET_MAC_MTLOMR                             = (rw_reg32_t)0x40028C00U;   /** @brief Operating mode register. */
  static const ro_reg32_t ETHERNET_MAC_MTLISR                             = (ro_reg32_t)0x40028C20U;   /** @brief Interrupt status register. */
  static const rw_reg32_t ETHERNET_MAC_MTLTXQOMR                          = (rw_reg32_t)0x40028D00U;   /** @brief Tx queue operating mode register. */
  static const ro_reg32_t ETHERNET_MAC_MTLTXQUR                           = (ro_reg32_t)0x40028D04U;   /** @brief Tx queue underflow register. */
  static const ro_reg32_t ETHERNET_MAC_MTLTXQDR                           = (ro_reg32_t)0x40028D08U;   /** @brief Tx queue debug register. */
  static const rw_reg32_t ETHERNET_MAC_MTLQICSR                           = (rw_reg32_t)0x40028D2CU;   /** @brief Queue interrupt control status register. */
  static const rw_reg32_t ETHERNET_MAC_MTLRXQOMR                          = (rw_reg32_t)0x40028D30U;   /** @brief Rx queue operating mode register. */
  static const ro_reg32_t ETHERNET_MAC_MTLRXQMPOCR                        = (ro_reg32_t)0x40028D34U;   /** @brief Rx queue missed packet and overflow counter register. */
  static const ro_reg32_t ETHERNET_MAC_MTLRXQDR                           = (ro_reg32_t)0x40028D38U;   /** @brief Rx queue debug register. */
  static const rw_reg32_t ETHERNET_MAC_MACCR                              = (rw_reg32_t)0x40028000U;   /** @brief Operating mode configuration register. */
  static const rw_reg32_t ETHERNET_MAC_MACECR                             = (rw_reg32_t)0x40028004U;   /** @brief Extended operating mode configuration register. */
  static const rw_reg32_t ETHERNET_MAC_MACPFR                             = (rw_reg32_t)0x40028008U;   /** @brief Packet filtering control register. */
  static const rw_reg32_t ETHERNET_MAC_MACWTR                             = (rw_reg32_t)0x4002800CU;   /** @brief Watchdog timeout register. */
  static const rw_reg32_t ETHERNET_MAC_MACVTR                             = (rw_reg32_t)0x40028050U;   /** @brief VLAN tag register. */
  static const rw_reg32_t ETHERNET_MAC_MACVHTR                            = (rw_reg32_t)0x40028058U;   /** @brief VLAN hash table register. */
  static const rw_reg32_t ETHERNET_MAC_MACVIR                             = (rw_reg32_t)0x40028060U;   /** @brief VLAN inclusion register. */
  static const rw_reg32_t ETHERNET_MAC_MACIVIR                            = (rw_reg32_t)0x40028064U;   /** @brief Inner VLAN inclusion register. */
  static const rw_reg32_t ETHERNET_MAC_MACQTXFCR                          = (rw_reg32_t)0x40028070U;   /** @brief Tx queue flow control register. */
  static const rw_reg32_t ETHERNET_MAC_MACRXFCR                           = (rw_reg32_t)0x40028090U;   /** @brief Rx flow control register. */
  static const ro_reg32_t ETHERNET_MAC_MACISR                             = (ro_reg32_t)0x400280B0U;   /** @brief Interrupt status register. */
  static const rw_reg32_t ETHERNET_MAC_MACIER                             = (rw_reg32_t)0x400280B4U;   /** @brief Interrupt enable register. */
  static const ro_reg32_t ETHERNET_MAC_MACRXTXSR                          = (ro_reg32_t)0x400280B8U;   /** @brief Rx tx status register. */
  static const rw_reg32_t ETHERNET_MAC_MACPCSR                            = (rw_reg32_t)0x400280C0U;   /** @brief PMT control status register. */
  static const rw_reg32_t ETHERNET_MAC_MACRWKPFR                          = (rw_reg32_t)0x400280C4U;   /** @brief Remove wakeup packet filter register. */
  static const rw_reg32_t ETHERNET_MAC_MACLCSR                            = (rw_reg32_t)0x400280D0U;   /** @brief LPI control status register. */
  static const rw_reg32_t ETHERNET_MAC_MACLTCR                            = (rw_reg32_t)0x400280D4U;   /** @brief LPI timers control register. */
  static const rw_reg32_t ETHERNET_MAC_MACLETR                            = (rw_reg32_t)0x400280D8U;   /** @brief LPI entry timer register. */
  static const rw_reg32_t ETHERNET_MAC_MAC1USTCR                          = (rw_reg32_t)0x400280DCU;   /** @brief 1-microsecond-tick counter register. */
  static const ro_reg32_t ETHERNET_MAC_MACVR                              = (ro_reg32_t)0x40028110U;   /** @brief Version register. */
  static const rw_reg32_t ETHERNET_MAC_MACMDIOAR                          = (rw_reg32_t)0x40028200U;   /** @brief MDIO address register. */
  static const rw_reg32_t ETHERNET_MAC_MACMDIODR                          = (rw_reg32_t)0x40028204U;   /** @brief MDIO data register. */
  static const rw_reg32_t ETHERNET_MAC_MACARPAR                           = (rw_reg32_t)0x40028AE0U;   /** @brief ARP address register. */
  static const rw_reg32_t ETHERNET_MAC_MMC_CONTROL                        = (rw_reg32_t)0x40028700U;   /** @brief MMC control register. */
  static const ro_reg32_t ETHERNET_MAC_MMC_RX_INTERRUPT                   = (ro_reg32_t)0x40028704U;   /** @brief MMC rx interrupt register. */
  static const ro_reg32_t ETHERNET_MAC_MMC_TX_INTERRUPT                   = (ro_reg32_t)0x40028708U;   /** @brief MMC tx interrupt register. */
  static const rw_reg32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK              = (rw_reg32_t)0x4002870CU;   /** @brief MMC rx interrupt mask register. */
  static const rw_reg32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK              = (rw_reg32_t)0x40028710U;   /** @brief MMC tx interrupt mask register. */
  static const ro_reg32_t ETHERNET_MAC_TX_SINGLE_COLLISION_GOOD_PACKETS   = (ro_reg32_t)0x4002874CU;   /** @brief Tx single collision good packets register. */
  static const ro_reg32_t ETHERNET_MAC_TX_MULTIPLE_COLLISION_GOOD_PACKETS = (ro_reg32_t)0x40028750U;   /** @brief Tx multiple collision good packets register. */
  static const ro_reg32_t ETHERNET_MAC_TX_PACKET_COUNT_GOOD               = (ro_reg32_t)0x40028768U;   /** @brief Tx packet count good register. */
  static const ro_reg32_t ETHERNET_MAC_RX_CRC_ERROR_PACKETS               = (ro_reg32_t)0x40028794U;   /** @brief Rx CRC error packets register. */
  static const ro_reg32_t ETHERNET_MAC_RX_ALIGNMENT_ERROR_PACKETS         = (ro_reg32_t)0x40028798U;   /** @brief Rx alignment error packets register. */
  static const ro_reg32_t ETHERNET_MAC_RX_UNICAST_PACKETS_GOOD            = (ro_reg32_t)0x400287C4U;   /** @brief Rx unicast packets good register. */
  static const ro_reg32_t ETHERNET_MAC_TX_LPI_USEC_CNTR                   = (ro_reg32_t)0x400287ECU;   /** @brief Tx LPI microsecond timer register. */
  static const ro_reg32_t ETHERNET_MAC_TX_LPI_TRAN_CNTR                   = (ro_reg32_t)0x400287F0U;   /** @brief Tx LPI transition counter register. */
  static const ro_reg32_t ETHERNET_MAC_RX_LPI_USEC_CNTR                   = (ro_reg32_t)0x400287F4U;   /** @brief Rx LPI microsecond counter register. */
  static const ro_reg32_t ETHERNET_MAC_RX_LPI_TRAN_CNTR                   = (ro_reg32_t)0x400287F8U;   /** @brief Rx LPI transition counter register. */
  static const ro_reg32_t ETHERNET_MAC_MACDR                              = (ro_reg32_t)0x40028114U;   /** @brief Debug register. */
  static const rw_reg32_t ETHERNET_MAC_MACTSCR                            = (rw_reg32_t)0x40028B00U;   /** @brief Timestamp control register. */
  static const rw_reg32_t ETHERNET_MAC_MACSSIR                            = (rw_reg32_t)0x40028B04U;   /** @brief Sub-second increment register. */
  static const ro_reg32_t ETHERNET_MAC_MACSTSR                            = (ro_reg32_t)0x40028B08U;   /** @brief System time seconds register. */
  static const ro_reg32_t ETHERNET_MAC_MACSTNR                            = (ro_reg32_t)0x40028B0CU;   /** @brief System time nanoseconds register. */
  static const rw_reg32_t ETHERNET_MAC_MACSTSUR                           = (rw_reg32_t)0x40028B10U;   /** @brief System time seconds update register. */
  static const rw_reg32_t ETHERNET_MAC_MACSTNUR                           = (rw_reg32_t)0x40028B14U;   /** @brief System time nanoseconds update register. */
  static const rw_reg32_t ETHERNET_MAC_MACTSAR                            = (rw_reg32_t)0x40028B18U;   /** @brief Timestamp addend register. */
  static const ro_reg32_t ETHERNET_MAC_MACTSSR                            = (ro_reg32_t)0x40028B20U;   /** @brief Timestamp status register. */
  static const ro_reg32_t ETHERNET_MAC_MACTXTSSNR                         = (ro_reg32_t)0x40028B30U;   /** @brief Tx timestamp status nanoseconds register. */
  static const ro_reg32_t ETHERNET_MAC_MACTXTSSSR                         = (ro_reg32_t)0x40028B34U;   /** @brief Tx timestamp status seconds register. */
  static const rw_reg32_t ETHERNET_MAC_MACACR                             = (rw_reg32_t)0x40028B40U;   /** @brief Auxiliary control register. */
  static const ro_reg32_t ETHERNET_MAC_MACATSNR                           = (ro_reg32_t)0x40028B48U;   /** @brief Auxiliary timestamp nanoseconds register. */
  static const ro_reg32_t ETHERNET_MAC_MACATSSR                           = (ro_reg32_t)0x40028B4CU;   /** @brief Auxiliary timestamp seconds register. */
  static const rw_reg32_t ETHERNET_MAC_MACTSIACR                          = (rw_reg32_t)0x40028B50U;   /** @brief Timestamp ingress asymmetric correction register. */
  static const rw_reg32_t ETHERNET_MAC_MACTSEACR                          = (rw_reg32_t)0x40028B54U;   /** @brief Timestamp egress asymmetric correction register. */
  static const rw_reg32_t ETHERNET_MAC_MACTSICNR                          = (rw_reg32_t)0x40028B58U;   /** @brief Timestamp ingress correction nanosecond register. */
  static const rw_reg32_t ETHERNET_MAC_MACTSECNR                          = (rw_reg32_t)0x40028B5CU;   /** @brief Timestamp egress correction nanosecond register. */
  static const rw_reg32_t ETHERNET_MAC_MACPPSCR                           = (rw_reg32_t)0x40028B70U;   /** @brief PPS control register. */
  static const rw_reg32_t ETHERNET_MAC_MACPPSTTSR                         = (rw_reg32_t)0x40028B80U;   /** @brief PPS target time seconds register. */
  static const rw_reg32_t ETHERNET_MAC_MACPPSTTNR                         = (rw_reg32_t)0x40028B84U;   /** @brief PPS target time nanoseconds register. */
  static const rw_reg32_t ETHERNET_MAC_MACPPSIR                           = (rw_reg32_t)0x40028B88U;   /** @brief PPS interval register. */
  static const rw_reg32_t ETHERNET_MAC_MACPPSWR                           = (rw_reg32_t)0x40028B8CU;   /** @brief PPS width register. */
  static const rw_reg32_t ETHERNET_MAC_MACPOCR                            = (rw_reg32_t)0x40028BC0U;   /** @brief PTP offload control register. */
  static const rw_reg32_t ETHERNET_MAC_MACLMIR                            = (rw_reg32_t)0x40028BD0U;   /** @brief Log message interval register. */

  /**** Enumerated ETHERNET_MAC Register Definitions ****/

  static const rw_reg32_t ETHERNET_MAC_MACHTxR[2] = {
    [0] = (rw_reg32_t)0x40028010U,   /** @brief Hash table 0 register. */
    [1] = (rw_reg32_t)0x40028014U,   /** @brief Hash table 1 register. */
  };

  static const ro_reg32_t ETHERNET_MAC_MACHWFxR[3] = {
    [1] = (ro_reg32_t)0x40028120U,   /** @brief HW feature 1 register. */
    [2] = (ro_reg32_t)0x40028124U,   /** @brief HW feature 2 register. */
  };

  static const rw_reg32_t ETHERNET_MAC_MACAxHR[4] = {
    [0] = (rw_reg32_t)0x40028300U,   /** @brief Address 0 high register. */
    [1] = (rw_reg32_t)0x40028308U,   /** @brief Address 1 high register. */
    [2] = (rw_reg32_t)0x40028310U,   /** @brief Address 2 high register. */
    [3] = (rw_reg32_t)0x40028318U,   /** @brief Address 3 high register. */
  };

  static const rw_reg32_t ETHERNET_MAC_MACAxLR[4] = {
    [0] = (rw_reg32_t)0x40028304U,   /** @brief Address 0 low register. */
    [1] = (rw_reg32_t)0x4002830CU,   /** @brief Address 1 low register. */
    [2] = (rw_reg32_t)0x40028314U,   /** @brief Address 2 low register. */
    [3] = (rw_reg32_t)0x4002831CU,   /** @brief Address 3 low register. */
  };

  static const rw_reg32_t ETHERNET_MAC_MACL3L4CxR[2] = {
    [0] = (rw_reg32_t)0x40028900U,   /** @brief L3 and L4 control 0 register. */
    [1] = (rw_reg32_t)0x40028930U,   /** @brief L3 and L4 control 1 register. */
  };

  static const rw_reg32_t ETHERNET_MAC_MACL4AxR[2] = {
    [0] = (rw_reg32_t)0x40028904U,   /** @brief Layer4 address filter 0 register. */
    [1] = (rw_reg32_t)0x40028934U,   /** @brief Layer 4 address filter 1 register. */
  };

  static const rw_reg32_t ETHERNET_MAC_MACL3AxR[32] = {
    [0]  = (rw_reg32_t)0x40028910U,   /** @brief MACL3A00R. */
    [10] = (rw_reg32_t)0x40028914U,   /** @brief Layer3 address 1 filter 0 register. */
    [11] = (rw_reg32_t)0x40028944U,   /** @brief Layer3 address 1 filter 1 register. */
    [21] = (rw_reg32_t)0x40028948U,   /** @brief Layer3 address 2 filter 1 register. */
    [31] = (rw_reg32_t)0x4002894CU,   /** @brief Layer3 address 3 filter 1 register. */
  };

  static const rw_reg32_t ETHERNET_MAC_MACL3Ax[31] = {
    [20] = (rw_reg32_t)0x40028918U,   /** @brief Layer3 address 2 filter 0 register. */
    [30] = (rw_reg32_t)0x4002891CU,   /** @brief Layer3 address 3 filter 0 register. */
  };

  static const rw_reg32_t ETHERNET_MAC_MACL3A0xR[2] = {
    [1] = (rw_reg32_t)0x40028940U,   /** @brief Layer3 address 0 filter 1 register. */
  };

  static const rw_reg32_t ETHERNET_MAC_MACSPIxR[3] = {
    [0] = (rw_reg32_t)0x40028BC4U,   /** @brief PTP source port identity 0 register. */
    [1] = (rw_reg32_t)0x40028BC8U,   /** @brief PTP source port identity 1 register. */
    [2] = (rw_reg32_t)0x40028BCCU,   /** @brief PTP source port identity 2 register. */
  };

  /**** ETHERNET_MAC Register Field Definitions ****/

  static const field32_t ETHERNET_MAC_DMAMR_SWR                         = {.msk = 0x00000001U, .pos = 0};    /** @brief Software reset. */
  static const field32_t ETHERNET_MAC_DMAMR_DA                          = {.msk = 0x00000002U, .pos = 1};    /** @brief DMA tx or rx arbitration scheme. */
  static const field32_t ETHERNET_MAC_DMAMR_TXPR                        = {.msk = 0x00000800U, .pos = 11};   /** @brief Transmit priority. */
  static const field32_t ETHERNET_MAC_DMAMR_PR                          = {.msk = 0x00007000U, .pos = 12};   /** @brief Priority ratio. */
  static const field32_t ETHERNET_MAC_DMAMR_INTM                        = {.msk = 0x00010000U, .pos = 16};   /** @brief Interrupt mode. */
  static const field32_t ETHERNET_MAC_DMASBMR_FB                        = {.msk = 0x00000001U, .pos = 0};    /** @brief Fixed burst length. */
  static const field32_t ETHERNET_MAC_DMASBMR_AAL                       = {.msk = 0x00001000U, .pos = 12};   /** @brief Address-Aligned beats. */
  static const field32_t ETHERNET_MAC_DMASBMR_MB                        = {.msk = 0x00004000U, .pos = 14};   /** @brief Mixed burst. */
  static const field32_t ETHERNET_MAC_DMASBMR_RB                        = {.msk = 0x00008000U, .pos = 15};   /** @brief Rebuild incrx burst. */
  static const field32_t ETHERNET_MAC_DMAISR_DC0IS                      = {.msk = 0x00000001U, .pos = 0};    /** @brief DMA channel interrupt status. */
  static const field32_t ETHERNET_MAC_DMAISR_MTLIS                      = {.msk = 0x00010000U, .pos = 16};   /** @brief MTL interrupt status. */
  static const field32_t ETHERNET_MAC_DMAISR_MACIS                      = {.msk = 0x00020000U, .pos = 17};   /** @brief MAC interrupt status. */
  static const field32_t ETHERNET_MAC_DMADSR_AXWHSTS                    = {.msk = 0x00000001U, .pos = 0};    /** @brief AHB master write channel. */
  static const field32_t ETHERNET_MAC_DMADSR_RPS0                       = {.msk = 0x00000F00U, .pos = 8};    /** @brief DMA channel receive process state. */
  static const field32_t ETHERNET_MAC_DMADSR_TPS0                       = {.msk = 0x0000F000U, .pos = 12};   /** @brief DMA channel transmit process state. */
  static const field32_t ETHERNET_MAC_DMACCR_MSS                        = {.msk = 0x00003FFFU, .pos = 0};    /** @brief Maximum segment size. */
  static const field32_t ETHERNET_MAC_DMACCR_PBLX8                      = {.msk = 0x00010000U, .pos = 16};   /** @brief 8xPBL mode. */
  static const field32_t ETHERNET_MAC_DMACCR_DSL                        = {.msk = 0x001C0000U, .pos = 18};   /** @brief Descriptor skip length. */
  static const field32_t ETHERNET_MAC_DMACTXCR_ST                       = {.msk = 0x00000001U, .pos = 0};    /** @brief Start or stop transmission command. */
  static const field32_t ETHERNET_MAC_DMACTXCR_OSF                      = {.msk = 0x00000010U, .pos = 4};    /** @brief Operate on second packet. */
  static const field32_t ETHERNET_MAC_DMACTXCR_TSE                      = {.msk = 0x00001000U, .pos = 12};   /** @brief TCP segmentation enabled. */
  static const field32_t ETHERNET_MAC_DMACTXCR_TXPBL                    = {.msk = 0x003F0000U, .pos = 16};   /** @brief Transmit programmable burst length. */
  static const field32_t ETHERNET_MAC_DMACRXCR_SR                       = {.msk = 0x00000001U, .pos = 0};    /** @brief Start or stop receive command. */
  static const field32_t ETHERNET_MAC_DMACRXCR_RBSZ                     = {.msk = 0x00007FFEU, .pos = 1};    /** @brief Receive buffer size. */
  static const field32_t ETHERNET_MAC_DMACRXCR_RXPBL                    = {.msk = 0x003F0000U, .pos = 16};   /** @brief RXPBL. */
  static const field32_t ETHERNET_MAC_DMACRXCR_RPF                      = {.msk = 0x80000000U, .pos = 31};   /** @brief DMA rx channel packet flush. */
  static const field32_t ETHERNET_MAC_DMACTXDLAR_TDESLA                 = {.msk = 0xFFFFFFFCU, .pos = 2};    /** @brief Start of transmit list. */
  static const field32_t ETHERNET_MAC_DMACRXDLAR_RDESLA                 = {.msk = 0xFFFFFFFCU, .pos = 2};    /** @brief Start of receive list. */
  static const field32_t ETHERNET_MAC_DMACTXDTPR_TDT                    = {.msk = 0xFFFFFFFCU, .pos = 2};    /** @brief Transmit descriptor tail pointer. */
  static const field32_t ETHERNET_MAC_DMACRXDTPR_RDT                    = {.msk = 0xFFFFFFFCU, .pos = 2};    /** @brief Receive descriptor tail pointer. */
  static const field32_t ETHERNET_MAC_DMACTXRLR_TDRL                    = {.msk = 0x000003FFU, .pos = 0};    /** @brief Transmit descriptor ring length. */
  static const field32_t ETHERNET_MAC_DMACRXRLR_RDRL                    = {.msk = 0x000003FFU, .pos = 0};    /** @brief Receive descriptor ring length. */
  static const field32_t ETHERNET_MAC_DMACIER_TIE                       = {.msk = 0x00000001U, .pos = 0};    /** @brief Transmit interrupt enable. */
  static const field32_t ETHERNET_MAC_DMACIER_TXSE                      = {.msk = 0x00000002U, .pos = 1};    /** @brief Transmit stopped enable. */
  static const field32_t ETHERNET_MAC_DMACIER_TBUE                      = {.msk = 0x00000004U, .pos = 2};    /** @brief Transmit buffer unavailable enable. */
  static const field32_t ETHERNET_MAC_DMACIER_RIE                       = {.msk = 0x00000040U, .pos = 6};    /** @brief Receive interrupt enable. */
  static const field32_t ETHERNET_MAC_DMACIER_RBUE                      = {.msk = 0x00000080U, .pos = 7};    /** @brief Receive buffer unavailable enable. */
  static const field32_t ETHERNET_MAC_DMACIER_RSE                       = {.msk = 0x00000100U, .pos = 8};    /** @brief Receive stopped enable. */
  static const field32_t ETHERNET_MAC_DMACIER_RWTE                      = {.msk = 0x00000200U, .pos = 9};    /** @brief Receive watchdog timeout enable. */
  static const field32_t ETHERNET_MAC_DMACIER_ETIE                      = {.msk = 0x00000400U, .pos = 10};   /** @brief Early transmit interrupt enable. */
  static const field32_t ETHERNET_MAC_DMACIER_ERIE                      = {.msk = 0x00000800U, .pos = 11};   /** @brief Early receive interrupt enable. */
  static const field32_t ETHERNET_MAC_DMACIER_FBEE                      = {.msk = 0x00001000U, .pos = 12};   /** @brief Fatal bus error enable. */
  static const field32_t ETHERNET_MAC_DMACIER_CDEE                      = {.msk = 0x00002000U, .pos = 13};   /** @brief Context descriptor error enable. */
  static const field32_t ETHERNET_MAC_DMACIER_AIE                       = {.msk = 0x00004000U, .pos = 14};   /** @brief Abnormal interrupt summary enable. */
  static const field32_t ETHERNET_MAC_DMACIER_NIE                       = {.msk = 0x00008000U, .pos = 15};   /** @brief Normal interrupt summary enable. */
  static const field32_t ETHERNET_MAC_DMACRXIWTR_RWT                    = {.msk = 0x000000FFU, .pos = 0};    /** @brief Receive interrupt watchdog timer count. */
  static const field32_t ETHERNET_MAC_DMACSR_TI                         = {.msk = 0x00000001U, .pos = 0};    /** @brief Transmit interrupt. */
  static const field32_t ETHERNET_MAC_DMACSR_TPS                        = {.msk = 0x00000002U, .pos = 1};    /** @brief Transmit process stopped. */
  static const field32_t ETHERNET_MAC_DMACSR_TBU                        = {.msk = 0x00000004U, .pos = 2};    /** @brief Transmit buffer unavailable. */
  static const field32_t ETHERNET_MAC_DMACSR_RI                         = {.msk = 0x00000040U, .pos = 6};    /** @brief Receive interrupt. */
  static const field32_t ETHERNET_MAC_DMACSR_RBU                        = {.msk = 0x00000080U, .pos = 7};    /** @brief Receive buffer unavailable. */
  static const field32_t ETHERNET_MAC_DMACSR_RPS                        = {.msk = 0x00000100U, .pos = 8};    /** @brief Receive process stopped. */
  static const field32_t ETHERNET_MAC_DMACSR_RWT                        = {.msk = 0x00000200U, .pos = 9};    /** @brief Receive watchdog timeout. */
  static const field32_t ETHERNET_MAC_DMACSR_ET                         = {.msk = 0x00000400U, .pos = 10};   /** @brief Early transmit interrupt. */
  static const field32_t ETHERNET_MAC_DMACSR_ER                         = {.msk = 0x00000800U, .pos = 11};   /** @brief Early receive interrupt. */
  static const field32_t ETHERNET_MAC_DMACSR_FBE                        = {.msk = 0x00001000U, .pos = 12};   /** @brief Fatal bus error. */
  static const field32_t ETHERNET_MAC_DMACSR_CDE                        = {.msk = 0x00002000U, .pos = 13};   /** @brief Context descriptor error. */
  static const field32_t ETHERNET_MAC_DMACSR_AIS                        = {.msk = 0x00004000U, .pos = 14};   /** @brief Abnormal interrupt summary. */
  static const field32_t ETHERNET_MAC_DMACSR_NIS                        = {.msk = 0x00008000U, .pos = 15};   /** @brief Normal interrupt summary. */
  static const field32_t ETHERNET_MAC_DMACSR_TEB                        = {.msk = 0x00070000U, .pos = 16};   /** @brief Tx DMA error bits. */
  static const field32_t ETHERNET_MAC_DMACSR_REB                        = {.msk = 0x00380000U, .pos = 19};   /** @brief Rx DMA error bits. */
  static const field32_t ETHERNET_MAC_DMACMFCR_MFC                      = {.msk = 0x000007FFU, .pos = 0};    /** @brief Dropped packet counters. */
  static const field32_t ETHERNET_MAC_DMACMFCR_MFCO                     = {.msk = 0x00008000U, .pos = 15};   /** @brief Overflow status of the MFC counter. */
  static const field32_t ETHERNET_MAC_MTLOMR_DTXSTS                     = {.msk = 0x00000002U, .pos = 1};    /** @brief DTXSTS. */
  static const field32_t ETHERNET_MAC_MTLOMR_CNTPRST                    = {.msk = 0x00000100U, .pos = 8};    /** @brief CNTPRST. */
  static const field32_t ETHERNET_MAC_MTLOMR_CNTCLR                     = {.msk = 0x00000200U, .pos = 9};    /** @brief CNTCLR. */
  static const field32_t ETHERNET_MAC_MTLISR_Q0IS                       = {.msk = 0x00000001U, .pos = 0};    /** @brief Queue interrupt status. */
  static const field32_t ETHERNET_MAC_MTLTXQOMR_FTQ                     = {.msk = 0x00000001U, .pos = 0};    /** @brief Flush transmit queue. */
  static const field32_t ETHERNET_MAC_MTLTXQOMR_TSF                     = {.msk = 0x00000002U, .pos = 1};    /** @brief Transmit store and forward. */
  static const field32_t ETHERNET_MAC_MTLTXQOMR_TXQEN                   = {.msk = 0x0000000CU, .pos = 2};    /** @brief Transmit queue enable. */
  static const field32_t ETHERNET_MAC_MTLTXQOMR_TTC                     = {.msk = 0x00000070U, .pos = 4};    /** @brief Transmit threshold control. */
  static const field32_t ETHERNET_MAC_MTLTXQOMR_TQS                     = {.msk = 0x01FF0000U, .pos = 16};   /** @brief Transmit queue size. */
  static const field32_t ETHERNET_MAC_MTLTXQUR_UFFRMCNT                 = {.msk = 0x000007FFU, .pos = 0};    /** @brief Underflow packet counter. */
  static const field32_t ETHERNET_MAC_MTLTXQUR_UFCNTOVF                 = {.msk = 0x00000800U, .pos = 11};   /** @brief UFCNTOVF. */
  static const field32_t ETHERNET_MAC_MTLTXQDR_TXQPAUSED                = {.msk = 0x00000001U, .pos = 0};    /** @brief TXQPAUSED. */
  static const field32_t ETHERNET_MAC_MTLTXQDR_TRCSTS                   = {.msk = 0x00000006U, .pos = 1};    /** @brief TRCSTS. */
  static const field32_t ETHERNET_MAC_MTLTXQDR_TWCSTS                   = {.msk = 0x00000008U, .pos = 3};    /** @brief TWCSTS. */
  static const field32_t ETHERNET_MAC_MTLTXQDR_TXQSTS                   = {.msk = 0x00000010U, .pos = 4};    /** @brief TXQSTS. */
  static const field32_t ETHERNET_MAC_MTLTXQDR_TXSTSFSTS                = {.msk = 0x00000020U, .pos = 5};    /** @brief TXSTSFSTS. */
  static const field32_t ETHERNET_MAC_MTLTXQDR_PTXQ                     = {.msk = 0x00070000U, .pos = 16};   /** @brief PTXQ. */
  static const field32_t ETHERNET_MAC_MTLTXQDR_STXSTSF                  = {.msk = 0x00700000U, .pos = 20};   /** @brief STXSTSF. */
  static const field32_t ETHERNET_MAC_MTLQICSR_TXUNFIS                  = {.msk = 0x00000001U, .pos = 0};    /** @brief TXUNFIS. */
  static const field32_t ETHERNET_MAC_MTLQICSR_TXUIE                    = {.msk = 0x00000100U, .pos = 8};    /** @brief TXUIE. */
  static const field32_t ETHERNET_MAC_MTLQICSR_RXOVFIS                  = {.msk = 0x00010000U, .pos = 16};   /** @brief RXOVFIS. */
  static const field32_t ETHERNET_MAC_MTLQICSR_RXOIE                    = {.msk = 0x01000000U, .pos = 24};   /** @brief RXOIE. */
  static const field32_t ETHERNET_MAC_MTLRXQOMR_RTC                     = {.msk = 0x00000003U, .pos = 0};    /** @brief RTC. */
  static const field32_t ETHERNET_MAC_MTLRXQOMR_FUP                     = {.msk = 0x00000008U, .pos = 3};    /** @brief FUP. */
  static const field32_t ETHERNET_MAC_MTLRXQOMR_FEP                     = {.msk = 0x00000010U, .pos = 4};    /** @brief FEP. */
  static const field32_t ETHERNET_MAC_MTLRXQOMR_RSF                     = {.msk = 0x00000020U, .pos = 5};    /** @brief RSF. */
  static const field32_t ETHERNET_MAC_MTLRXQOMR_DIS_TCP_EF              = {.msk = 0x00000040U, .pos = 6};    /** @brief DIS_TCP_EF. */
  static const field32_t ETHERNET_MAC_MTLRXQOMR_EHFC                    = {.msk = 0x00000080U, .pos = 7};    /** @brief EHFC. */
  static const field32_t ETHERNET_MAC_MTLRXQOMR_RFA                     = {.msk = 0x00000700U, .pos = 8};    /** @brief RFA. */
  static const field32_t ETHERNET_MAC_MTLRXQOMR_RFD                     = {.msk = 0x0001C000U, .pos = 14};   /** @brief RFD. */
  static const field32_t ETHERNET_MAC_MTLRXQOMR_RQS                     = {.msk = 0x00700000U, .pos = 20};   /** @brief RQS. */
  static const field32_t ETHERNET_MAC_MTLRXQMPOCR_OVFPKTCNT             = {.msk = 0x000007FFU, .pos = 0};    /** @brief OVFPKTCNT. */
  static const field32_t ETHERNET_MAC_MTLRXQMPOCR_OVFCNTOVF             = {.msk = 0x00000800U, .pos = 11};   /** @brief OVFCNTOVF. */
  static const field32_t ETHERNET_MAC_MTLRXQMPOCR_MISPKTCNT             = {.msk = 0x07FF0000U, .pos = 16};   /** @brief MISPKTCNT. */
  static const field32_t ETHERNET_MAC_MTLRXQMPOCR_MISCNTOVF             = {.msk = 0x08000000U, .pos = 27};   /** @brief MISCNTOVF. */
  static const field32_t ETHERNET_MAC_MTLRXQDR_RWCSTS                   = {.msk = 0x00000001U, .pos = 0};    /** @brief RWCSTS. */
  static const field32_t ETHERNET_MAC_MTLRXQDR_RRCSTS                   = {.msk = 0x00000006U, .pos = 1};    /** @brief RRCSTS. */
  static const field32_t ETHERNET_MAC_MTLRXQDR_RXQSTS                   = {.msk = 0x00000030U, .pos = 4};    /** @brief RXQSTS. */
  static const field32_t ETHERNET_MAC_MTLRXQDR_PRXQ                     = {.msk = 0x3FFF0000U, .pos = 16};   /** @brief PRXQ. */
  static const field32_t ETHERNET_MAC_MACCR_RE                          = {.msk = 0x00000001U, .pos = 0};    /** @brief Receiver enable. */
  static const field32_t ETHERNET_MAC_MACCR_TE                          = {.msk = 0x00000002U, .pos = 1};    /** @brief TE. */
  static const field32_t ETHERNET_MAC_MACCR_PRELEN                      = {.msk = 0x0000000CU, .pos = 2};    /** @brief PRELEN. */
  static const field32_t ETHERNET_MAC_MACCR_DC                          = {.msk = 0x00000010U, .pos = 4};    /** @brief DC. */
  static const field32_t ETHERNET_MAC_MACCR_BL                          = {.msk = 0x00000060U, .pos = 5};    /** @brief BL. */
  static const field32_t ETHERNET_MAC_MACCR_DR                          = {.msk = 0x00000100U, .pos = 8};    /** @brief DR. */
  static const field32_t ETHERNET_MAC_MACCR_DCRS                        = {.msk = 0x00000200U, .pos = 9};    /** @brief DCRS. */
  static const field32_t ETHERNET_MAC_MACCR_DO                          = {.msk = 0x00000400U, .pos = 10};   /** @brief DO. */
  static const field32_t ETHERNET_MAC_MACCR_ECRSFD                      = {.msk = 0x00000800U, .pos = 11};   /** @brief ECRSFD. */
  static const field32_t ETHERNET_MAC_MACCR_LM                          = {.msk = 0x00001000U, .pos = 12};   /** @brief LM. */
  static const field32_t ETHERNET_MAC_MACCR_DM                          = {.msk = 0x00002000U, .pos = 13};   /** @brief DM. */
  static const field32_t ETHERNET_MAC_MACCR_FES                         = {.msk = 0x00004000U, .pos = 14};   /** @brief FES. */
  static const field32_t ETHERNET_MAC_MACCR_JE                          = {.msk = 0x00010000U, .pos = 16};   /** @brief JE. */
  static const field32_t ETHERNET_MAC_MACCR_JD                          = {.msk = 0x00020000U, .pos = 17};   /** @brief JD. */
  static const field32_t ETHERNET_MAC_MACCR_WD                          = {.msk = 0x00080000U, .pos = 19};   /** @brief WD. */
  static const field32_t ETHERNET_MAC_MACCR_ACS                         = {.msk = 0x00100000U, .pos = 20};   /** @brief ACS. */
  static const field32_t ETHERNET_MAC_MACCR_CST                         = {.msk = 0x00200000U, .pos = 21};   /** @brief CST. */
  static const field32_t ETHERNET_MAC_MACCR_S2KP                        = {.msk = 0x00400000U, .pos = 22};   /** @brief S2KP. */
  static const field32_t ETHERNET_MAC_MACCR_GPSLCE                      = {.msk = 0x00800000U, .pos = 23};   /** @brief GPSLCE. */
  static const field32_t ETHERNET_MAC_MACCR_IPG                         = {.msk = 0x07000000U, .pos = 24};   /** @brief IPG. */
  static const field32_t ETHERNET_MAC_MACCR_IPC                         = {.msk = 0x08000000U, .pos = 27};   /** @brief IPC. */
  static const field32_t ETHERNET_MAC_MACCR_SARC                        = {.msk = 0x70000000U, .pos = 28};   /** @brief SARC. */
  static const field32_t ETHERNET_MAC_MACCR_ARPEN                       = {.msk = 0x80000000U, .pos = 31};   /** @brief ARPEN. */
  static const field32_t ETHERNET_MAC_MACECR_GPSL                       = {.msk = 0x00003FFFU, .pos = 0};    /** @brief GPSL. */
  static const field32_t ETHERNET_MAC_MACECR_DCRCC                      = {.msk = 0x00010000U, .pos = 16};   /** @brief DCRCC. */
  static const field32_t ETHERNET_MAC_MACECR_SPEN                       = {.msk = 0x00020000U, .pos = 17};   /** @brief SPEN. */
  static const field32_t ETHERNET_MAC_MACECR_USP                        = {.msk = 0x00040000U, .pos = 18};   /** @brief USP. */
  static const field32_t ETHERNET_MAC_MACECR_EIPGEN                     = {.msk = 0x01000000U, .pos = 24};   /** @brief EIPGEN. */
  static const field32_t ETHERNET_MAC_MACECR_EIPG                       = {.msk = 0x3E000000U, .pos = 25};   /** @brief EIPG. */
  static const field32_t ETHERNET_MAC_MACPFR_PR                         = {.msk = 0x00000001U, .pos = 0};    /** @brief PR. */
  static const field32_t ETHERNET_MAC_MACPFR_HUC                        = {.msk = 0x00000002U, .pos = 1};    /** @brief HUC. */
  static const field32_t ETHERNET_MAC_MACPFR_HMC                        = {.msk = 0x00000004U, .pos = 2};    /** @brief HMC. */
  static const field32_t ETHERNET_MAC_MACPFR_DAIF                       = {.msk = 0x00000008U, .pos = 3};    /** @brief DAIF. */
  static const field32_t ETHERNET_MAC_MACPFR_PM                         = {.msk = 0x00000010U, .pos = 4};    /** @brief PM. */
  static const field32_t ETHERNET_MAC_MACPFR_DBF                        = {.msk = 0x00000020U, .pos = 5};    /** @brief DBF. */
  static const field32_t ETHERNET_MAC_MACPFR_PCF                        = {.msk = 0x000000C0U, .pos = 6};    /** @brief PCF. */
  static const field32_t ETHERNET_MAC_MACPFR_SAIF                       = {.msk = 0x00000100U, .pos = 8};    /** @brief SAIF. */
  static const field32_t ETHERNET_MAC_MACPFR_SAF                        = {.msk = 0x00000200U, .pos = 9};    /** @brief SAF. */
  static const field32_t ETHERNET_MAC_MACPFR_HPF                        = {.msk = 0x00000400U, .pos = 10};   /** @brief HPF. */
  static const field32_t ETHERNET_MAC_MACPFR_VTFE                       = {.msk = 0x00010000U, .pos = 16};   /** @brief VTFE. */
  static const field32_t ETHERNET_MAC_MACPFR_IPFE                       = {.msk = 0x00100000U, .pos = 20};   /** @brief IPFE. */
  static const field32_t ETHERNET_MAC_MACPFR_DNTU                       = {.msk = 0x00200000U, .pos = 21};   /** @brief DNTU. */
  static const field32_t ETHERNET_MAC_MACPFR_RA                         = {.msk = 0x80000000U, .pos = 31};   /** @brief RA. */
  static const field32_t ETHERNET_MAC_MACWTR_WTO                        = {.msk = 0x0000000FU, .pos = 0};    /** @brief WTO. */
  static const field32_t ETHERNET_MAC_MACWTR_PWE                        = {.msk = 0x00000100U, .pos = 8};    /** @brief PWE. */
  static const field32_t ETHERNET_MAC_MACVTR_VL                         = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief VL. */
  static const field32_t ETHERNET_MAC_MACVTR_ETV                        = {.msk = 0x00010000U, .pos = 16};   /** @brief ETV. */
  static const field32_t ETHERNET_MAC_MACVTR_VTIM                       = {.msk = 0x00020000U, .pos = 17};   /** @brief VTIM. */
  static const field32_t ETHERNET_MAC_MACVTR_ESVL                       = {.msk = 0x00040000U, .pos = 18};   /** @brief ESVL. */
  static const field32_t ETHERNET_MAC_MACVTR_ERSVLM                     = {.msk = 0x00080000U, .pos = 19};   /** @brief ERSVLM. */
  static const field32_t ETHERNET_MAC_MACVTR_DOVLTC                     = {.msk = 0x00100000U, .pos = 20};   /** @brief DOVLTC. */
  static const field32_t ETHERNET_MAC_MACVTR_EVLS                       = {.msk = 0x00600000U, .pos = 21};   /** @brief EVLS. */
  static const field32_t ETHERNET_MAC_MACVTR_EVLRXS                     = {.msk = 0x01000000U, .pos = 24};   /** @brief EVLRXS. */
  static const field32_t ETHERNET_MAC_MACVTR_VTHM                       = {.msk = 0x02000000U, .pos = 25};   /** @brief VTHM. */
  static const field32_t ETHERNET_MAC_MACVTR_EDVLP                      = {.msk = 0x04000000U, .pos = 26};   /** @brief EDVLP. */
  static const field32_t ETHERNET_MAC_MACVTR_ERIVLT                     = {.msk = 0x08000000U, .pos = 27};   /** @brief ERIVLT. */
  static const field32_t ETHERNET_MAC_MACVTR_EIVLS                      = {.msk = 0x30000000U, .pos = 28};   /** @brief EIVLS. */
  static const field32_t ETHERNET_MAC_MACVTR_EIVLRXS                    = {.msk = 0x80000000U, .pos = 31};   /** @brief EIVLRXS. */
  static const field32_t ETHERNET_MAC_MACVHTR_VLHT                      = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief VLHT. */
  static const field32_t ETHERNET_MAC_MACVIR_VLT                        = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief VLT. */
  static const field32_t ETHERNET_MAC_MACVIR_VLC                        = {.msk = 0x00030000U, .pos = 16};   /** @brief VLC. */
  static const field32_t ETHERNET_MAC_MACVIR_VLP                        = {.msk = 0x00040000U, .pos = 18};   /** @brief VLP. */
  static const field32_t ETHERNET_MAC_MACVIR_CSVL                       = {.msk = 0x00080000U, .pos = 19};   /** @brief CSVL. */
  static const field32_t ETHERNET_MAC_MACVIR_VLTI                       = {.msk = 0x00100000U, .pos = 20};   /** @brief VLTI. */
  static const field32_t ETHERNET_MAC_MACIVIR_VLT                       = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief VLT. */
  static const field32_t ETHERNET_MAC_MACIVIR_VLC                       = {.msk = 0x00030000U, .pos = 16};   /** @brief VLC. */
  static const field32_t ETHERNET_MAC_MACIVIR_VLP                       = {.msk = 0x00040000U, .pos = 18};   /** @brief VLP. */
  static const field32_t ETHERNET_MAC_MACIVIR_CSVL                      = {.msk = 0x00080000U, .pos = 19};   /** @brief CSVL. */
  static const field32_t ETHERNET_MAC_MACIVIR_VLTI                      = {.msk = 0x00100000U, .pos = 20};   /** @brief VLTI. */
  static const field32_t ETHERNET_MAC_MACQTXFCR_FCB_BPA                 = {.msk = 0x00000001U, .pos = 0};    /** @brief FCB_BPA. */
  static const field32_t ETHERNET_MAC_MACQTXFCR_TFE                     = {.msk = 0x00000002U, .pos = 1};    /** @brief TFE. */
  static const field32_t ETHERNET_MAC_MACQTXFCR_PLT                     = {.msk = 0x00000070U, .pos = 4};    /** @brief PLT. */
  static const field32_t ETHERNET_MAC_MACQTXFCR_DZPQ                    = {.msk = 0x00000080U, .pos = 7};    /** @brief DZPQ. */
  static const field32_t ETHERNET_MAC_MACQTXFCR_PT                      = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief PT. */
  static const field32_t ETHERNET_MAC_MACRXFCR_RFE                      = {.msk = 0x00000001U, .pos = 0};    /** @brief RFE. */
  static const field32_t ETHERNET_MAC_MACRXFCR_UP                       = {.msk = 0x00000002U, .pos = 1};    /** @brief UP. */
  static const field32_t ETHERNET_MAC_MACISR_PHYIS                      = {.msk = 0x00000008U, .pos = 3};    /** @brief PHYIS. */
  static const field32_t ETHERNET_MAC_MACISR_PMTIS                      = {.msk = 0x00000010U, .pos = 4};    /** @brief PMTIS. */
  static const field32_t ETHERNET_MAC_MACISR_LPIIS                      = {.msk = 0x00000020U, .pos = 5};    /** @brief LPIIS. */
  static const field32_t ETHERNET_MAC_MACISR_MMCIS                      = {.msk = 0x00000100U, .pos = 8};    /** @brief MMCIS. */
  static const field32_t ETHERNET_MAC_MACISR_MMCRXIS                    = {.msk = 0x00000200U, .pos = 9};    /** @brief MMCRXIS. */
  static const field32_t ETHERNET_MAC_MACISR_MMCTXIS                    = {.msk = 0x00000400U, .pos = 10};   /** @brief MMCTXIS. */
  static const field32_t ETHERNET_MAC_MACISR_TSIS                       = {.msk = 0x00001000U, .pos = 12};   /** @brief TSIS. */
  static const field32_t ETHERNET_MAC_MACISR_TXSTSIS                    = {.msk = 0x00002000U, .pos = 13};   /** @brief TXSTSIS. */
  static const field32_t ETHERNET_MAC_MACISR_RXSTSIS                    = {.msk = 0x00004000U, .pos = 14};   /** @brief RXSTSIS. */
  static const field32_t ETHERNET_MAC_MACIER_PHYIE                      = {.msk = 0x00000008U, .pos = 3};    /** @brief PHYIE. */
  static const field32_t ETHERNET_MAC_MACIER_PMTIE                      = {.msk = 0x00000010U, .pos = 4};    /** @brief PMTIE. */
  static const field32_t ETHERNET_MAC_MACIER_LPIIE                      = {.msk = 0x00000020U, .pos = 5};    /** @brief LPIIE. */
  static const field32_t ETHERNET_MAC_MACIER_TSIE                       = {.msk = 0x00001000U, .pos = 12};   /** @brief TSIE. */
  static const field32_t ETHERNET_MAC_MACIER_TXSTSIE                    = {.msk = 0x00002000U, .pos = 13};   /** @brief TXSTSIE. */
  static const field32_t ETHERNET_MAC_MACIER_RXSTSIE                    = {.msk = 0x00004000U, .pos = 14};   /** @brief RXSTSIE. */
  static const field32_t ETHERNET_MAC_MACRXTXSR_TJT                     = {.msk = 0x00000001U, .pos = 0};    /** @brief TJT. */
  static const field32_t ETHERNET_MAC_MACRXTXSR_NCARR                   = {.msk = 0x00000002U, .pos = 1};    /** @brief NCARR. */
  static const field32_t ETHERNET_MAC_MACRXTXSR_LCARR                   = {.msk = 0x00000004U, .pos = 2};    /** @brief LCARR. */
  static const field32_t ETHERNET_MAC_MACRXTXSR_EXDEF                   = {.msk = 0x00000008U, .pos = 3};    /** @brief EXDEF. */
  static const field32_t ETHERNET_MAC_MACRXTXSR_LCOL                    = {.msk = 0x00000010U, .pos = 4};    /** @brief LCOL. */
  static const field32_t ETHERNET_MAC_MACRXTXSR_EXCOL                   = {.msk = 0x00000020U, .pos = 5};    /** @brief LCOL. */
  static const field32_t ETHERNET_MAC_MACRXTXSR_RWT                     = {.msk = 0x00000100U, .pos = 8};    /** @brief RWT. */
  static const field32_t ETHERNET_MAC_MACPCSR_PWRDWN                    = {.msk = 0x00000001U, .pos = 0};    /** @brief PWRDWN. */
  static const field32_t ETHERNET_MAC_MACPCSR_MGKPKTEN                  = {.msk = 0x00000002U, .pos = 1};    /** @brief MGKPKTEN. */
  static const field32_t ETHERNET_MAC_MACPCSR_RWKPKTEN                  = {.msk = 0x00000004U, .pos = 2};    /** @brief RWKPKTEN. */
  static const field32_t ETHERNET_MAC_MACPCSR_MGKPRCVD                  = {.msk = 0x00000020U, .pos = 5};    /** @brief MGKPRCVD. */
  static const field32_t ETHERNET_MAC_MACPCSR_RWKPRCVD                  = {.msk = 0x00000040U, .pos = 6};    /** @brief RWKPRCVD. */
  static const field32_t ETHERNET_MAC_MACPCSR_GLBLUCAST                 = {.msk = 0x00000200U, .pos = 9};    /** @brief GLBLUCAST. */
  static const field32_t ETHERNET_MAC_MACPCSR_RWKPFE                    = {.msk = 0x00000400U, .pos = 10};   /** @brief RWKPFE. */
  static const field32_t ETHERNET_MAC_MACPCSR_RWKPTR                    = {.msk = 0x1F000000U, .pos = 24};   /** @brief RWKPTR. */
  static const field32_t ETHERNET_MAC_MACPCSR_RWKFILTRST                = {.msk = 0x80000000U, .pos = 31};   /** @brief RWKFILTRST. */
  static const field32_t ETHERNET_MAC_MACLCSR_TLPIEN                    = {.msk = 0x00000001U, .pos = 0};    /** @brief TLPIEN. */
  static const field32_t ETHERNET_MAC_MACLCSR_TLPIEX                    = {.msk = 0x00000002U, .pos = 1};    /** @brief TLPIEX. */
  static const field32_t ETHERNET_MAC_MACLCSR_RLPIEN                    = {.msk = 0x00000004U, .pos = 2};    /** @brief RLPIEN. */
  static const field32_t ETHERNET_MAC_MACLCSR_RLPIEX                    = {.msk = 0x00000008U, .pos = 3};    /** @brief RLPIEX. */
  static const field32_t ETHERNET_MAC_MACLCSR_TLPIST                    = {.msk = 0x00000100U, .pos = 8};    /** @brief TLPIST. */
  static const field32_t ETHERNET_MAC_MACLCSR_RLPIST                    = {.msk = 0x00000200U, .pos = 9};    /** @brief RLPIST. */
  static const field32_t ETHERNET_MAC_MACLCSR_LPIEN                     = {.msk = 0x00010000U, .pos = 16};   /** @brief LPIEN. */
  static const field32_t ETHERNET_MAC_MACLCSR_PLS                       = {.msk = 0x00020000U, .pos = 17};   /** @brief PLS. */
  static const field32_t ETHERNET_MAC_MACLCSR_PLSEN                     = {.msk = 0x00040000U, .pos = 18};   /** @brief PLSEN. */
  static const field32_t ETHERNET_MAC_MACLCSR_LPITXA                    = {.msk = 0x00080000U, .pos = 19};   /** @brief LPITXA. */
  static const field32_t ETHERNET_MAC_MACLCSR_LPITE                     = {.msk = 0x00100000U, .pos = 20};   /** @brief LPITE. */
  static const field32_t ETHERNET_MAC_MACLCSR_LPITCSE                   = {.msk = 0x00200000U, .pos = 21};   /** @brief LPITCSE. */
  static const field32_t ETHERNET_MAC_MACLTCR_TWT                       = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief TWT. */
  static const field32_t ETHERNET_MAC_MACLTCR_LST                       = {.msk = 0x03FF0000U, .pos = 16};   /** @brief LST. */
  static const field32_t ETHERNET_MAC_MACLETR_LPIET                     = {.msk = 0x0001FFFFU, .pos = 0};    /** @brief LPIET. */
  static const field32_t ETHERNET_MAC_MAC1USTCR_TIC_1US_CNTR            = {.msk = 0x00000FFFU, .pos = 0};    /** @brief TIC_1US_CNTR. */
  static const field32_t ETHERNET_MAC_MACVR_SNPSVER                     = {.msk = 0x000000FFU, .pos = 0};    /** @brief SNPSVER. */
  static const field32_t ETHERNET_MAC_MACVR_USERVER                     = {.msk = 0x0000FF00U, .pos = 8};    /** @brief USERVER. */
  static const field32_t ETHERNET_MAC_MACHWFxR_RXFIFOSIZE               = {.msk = 0x0000001FU, .pos = 0};    /** @brief RXFIFOSIZE. */
  static const field32_t ETHERNET_MAC_MACHWFxR_TXFIFOSIZE               = {.msk = 0x000007C0U, .pos = 6};    /** @brief TXFIFOSIZE. */
  static const field32_t ETHERNET_MAC_MACHWFxR_OSTEN                    = {.msk = 0x00000800U, .pos = 11};   /** @brief OSTEN. */
  static const field32_t ETHERNET_MAC_MACHWFxR_PTOEN                    = {.msk = 0x00001000U, .pos = 12};   /** @brief PTOEN. */
  static const field32_t ETHERNET_MAC_MACHWFxR_ADVTHWORD                = {.msk = 0x00002000U, .pos = 13};   /** @brief ADVTHWORD. */
  static const field32_t ETHERNET_MAC_MACHWFxR_DCBEN                    = {.msk = 0x00010000U, .pos = 16};   /** @brief DCBEN. */
  static const field32_t ETHERNET_MAC_MACHWFxR_SPHEN                    = {.msk = 0x00020000U, .pos = 17};   /** @brief SPHEN. */
  static const field32_t ETHERNET_MAC_MACHWFxR_TSOEN                    = {.msk = 0x00040000U, .pos = 18};   /** @brief TSOEN. */
  static const field32_t ETHERNET_MAC_MACHWFxR_DBGMEMA                  = {.msk = 0x00080000U, .pos = 19};   /** @brief DBGMEMA. */
  static const field32_t ETHERNET_MAC_MACHWFxR_AVSEL                    = {.msk = 0x00100000U, .pos = 20};   /** @brief AVSEL. */
  static const field32_t ETHERNET_MAC_MACHWFxR_HASHTBLSZ                = {.msk = 0x03000000U, .pos = 24};   /** @brief HASHTBLSZ. */
  static const field32_t ETHERNET_MAC_MACHWFxR_L3L4FNUM                 = {.msk = 0x78000000U, .pos = 27};   /** @brief L3L4FNUM. */
  static const field32_t ETHERNET_MAC_MACMDIOAR_MB                      = {.msk = 0x00000001U, .pos = 0};    /** @brief MB. */
  static const field32_t ETHERNET_MAC_MACMDIOAR_C45E                    = {.msk = 0x00000002U, .pos = 1};    /** @brief C45E. */
  static const field32_t ETHERNET_MAC_MACMDIOAR_GOC                     = {.msk = 0x0000000CU, .pos = 2};    /** @brief GOC. */
  static const field32_t ETHERNET_MAC_MACMDIOAR_SKAP                    = {.msk = 0x00000010U, .pos = 4};    /** @brief SKAP. */
  static const field32_t ETHERNET_MAC_MACMDIOAR_CR                      = {.msk = 0x00000F00U, .pos = 8};    /** @brief CR. */
  static const field32_t ETHERNET_MAC_MACMDIOAR_NTC                     = {.msk = 0x00007000U, .pos = 12};   /** @brief NTC. */
  static const field32_t ETHERNET_MAC_MACMDIOAR_RDA                     = {.msk = 0x001F0000U, .pos = 16};   /** @brief RDA. */
  static const field32_t ETHERNET_MAC_MACMDIOAR_PA                      = {.msk = 0x03E00000U, .pos = 21};   /** @brief PA. */
  static const field32_t ETHERNET_MAC_MACMDIOAR_BTB                     = {.msk = 0x04000000U, .pos = 26};   /** @brief BTB. */
  static const field32_t ETHERNET_MAC_MACMDIOAR_PSE                     = {.msk = 0x08000000U, .pos = 27};   /** @brief PSE. */
  static const field32_t ETHERNET_MAC_MACMDIODR_MD                      = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief MD. */
  static const field32_t ETHERNET_MAC_MACMDIODR_RA                      = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief RA. */
  static const field32_t ETHERNET_MAC_MACAxHR_ADDRHI                    = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief ADDRHI. */
  static const field32_t ETHERNET_MAC_MACAxHR_AE                        = {.msk = 0x80000000U, .pos = 31};   /** @brief AE. */
  static const field32_t ETHERNET_MAC_MMC_CONTROL_CNTRST                = {.msk = 0x00000001U, .pos = 0};    /** @brief CNTRST. */
  static const field32_t ETHERNET_MAC_MMC_CONTROL_CNTSTOPRO             = {.msk = 0x00000002U, .pos = 1};    /** @brief CNTSTOPRO. */
  static const field32_t ETHERNET_MAC_MMC_CONTROL_RSTONRD               = {.msk = 0x00000004U, .pos = 2};    /** @brief RSTONRD. */
  static const field32_t ETHERNET_MAC_MMC_CONTROL_CNTFREEZ              = {.msk = 0x00000008U, .pos = 3};    /** @brief CNTFREEZ. */
  static const field32_t ETHERNET_MAC_MMC_CONTROL_CNTPRST               = {.msk = 0x00000010U, .pos = 4};    /** @brief CNTPRST. */
  static const field32_t ETHERNET_MAC_MMC_CONTROL_CNTPRSTLVL            = {.msk = 0x00000020U, .pos = 5};    /** @brief CNTPRSTLVL. */
  static const field32_t ETHERNET_MAC_MMC_CONTROL_UCDBC                 = {.msk = 0x00000100U, .pos = 8};    /** @brief UCDBC. */
  static const field32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXCRCERPIS       = {.msk = 0x00000020U, .pos = 5};    /** @brief RXCRCERPIS. */
  static const field32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXALGNERPIS      = {.msk = 0x00000040U, .pos = 6};    /** @brief RXALGNERPIS. */
  static const field32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXUCGPIS         = {.msk = 0x00020000U, .pos = 17};   /** @brief RXUCGPIS. */
  static const field32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXLPIUSCIS       = {.msk = 0x04000000U, .pos = 26};   /** @brief RXLPIUSCIS. */
  static const field32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXLPITRCIS       = {.msk = 0x08000000U, .pos = 27};   /** @brief RXLPITRCIS. */
  static const field32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXSCOLGPIS       = {.msk = 0x00004000U, .pos = 14};   /** @brief TXSCOLGPIS. */
  static const field32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXMCOLGPIS       = {.msk = 0x00008000U, .pos = 15};   /** @brief TXMCOLGPIS. */
  static const field32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXGPKTIS         = {.msk = 0x00200000U, .pos = 21};   /** @brief TXGPKTIS. */
  static const field32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXLPIUSCIS       = {.msk = 0x04000000U, .pos = 26};   /** @brief TXLPIUSCIS. */
  static const field32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXLPITRCIS       = {.msk = 0x08000000U, .pos = 27};   /** @brief TXLPITRCIS. */
  static const field32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXCRCERPIM  = {.msk = 0x00000020U, .pos = 5};    /** @brief RXCRCERPIM. */
  static const field32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXALGNERPIM = {.msk = 0x00000040U, .pos = 6};    /** @brief RXALGNERPIM. */
  static const field32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXUCGPIM    = {.msk = 0x00020000U, .pos = 17};   /** @brief RXUCGPIM. */
  static const field32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXLPIUSCIM  = {.msk = 0x04000000U, .pos = 26};   /** @brief RXLPIUSCIM. */
  static const field32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXLPITRCIM  = {.msk = 0x08000000U, .pos = 27};   /** @brief RXLPITRCIM. */
  static const field32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXSCOLGPIM  = {.msk = 0x00004000U, .pos = 14};   /** @brief TXSCOLGPIM. */
  static const field32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXMCOLGPIM  = {.msk = 0x00008000U, .pos = 15};   /** @brief TXMCOLGPIM. */
  static const field32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXGPKTIM    = {.msk = 0x00200000U, .pos = 21};   /** @brief TXGPKTIM. */
  static const field32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXLPIUSCIM  = {.msk = 0x04000000U, .pos = 26};   /** @brief TXLPIUSCIM. */
  static const field32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXLPITRCIM  = {.msk = 0x08000000U, .pos = 27};   /** @brief TXLPITRCIM. */
  static const field32_t ETHERNET_MAC_MACL3L4CxR_L3SAM0                 = {.msk = 0x00000004U, .pos = 2};    /** @brief L3SAM0. */
  static const field32_t ETHERNET_MAC_MACL3L4CxR_L3SAIM0                = {.msk = 0x00000008U, .pos = 3};    /** @brief L3SAIM0. */
  static const field32_t ETHERNET_MAC_MACL3L4CxR_L3DAM0                 = {.msk = 0x00000010U, .pos = 4};    /** @brief L3DAM0. */
  static const field32_t ETHERNET_MAC_MACL3L4CxR_L3DAIM0                = {.msk = 0x00000020U, .pos = 5};    /** @brief L3DAIM0. */
  static const field32_t ETHERNET_MAC_MACL3L4CxR_L3HSBM0                = {.msk = 0x000007C0U, .pos = 6};    /** @brief L3HSBM0. */
  static const field32_t ETHERNET_MAC_MACL3L4CxR_L3HDBM0                = {.msk = 0x0000F800U, .pos = 11};   /** @brief L3HDBM0. */
  static const field32_t ETHERNET_MAC_MACL3L4CxR_L4SPM0                 = {.msk = 0x00040000U, .pos = 18};   /** @brief L4SPM0. */
  static const field32_t ETHERNET_MAC_MACL3L4CxR_L4SPIM0                = {.msk = 0x00080000U, .pos = 19};   /** @brief L4SPIM0. */
  static const field32_t ETHERNET_MAC_MACL3L4CxR_L4DPM0                 = {.msk = 0x00100000U, .pos = 20};   /** @brief L4DPM0. */
  static const field32_t ETHERNET_MAC_MACL3L4CxR_L4DPIM0                = {.msk = 0x00200000U, .pos = 21};   /** @brief L4DPIM0. */
  static const field32_t ETHERNET_MAC_MACL4AxR_L4SP0                    = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief L4SP0. */
  static const field32_t ETHERNET_MAC_MACL4AxR_L4DP0                    = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief L4DP0. */
  static const field32_t ETHERNET_MAC_MACDR_RPESTS                      = {.msk = 0x00000001U, .pos = 0};    /** @brief RPESTS. */
  static const field32_t ETHERNET_MAC_MACDR_RFCFCSTS                    = {.msk = 0x00000006U, .pos = 1};    /** @brief RFCFCSTS. */
  static const field32_t ETHERNET_MAC_MACDR_TPESTS                      = {.msk = 0x00010000U, .pos = 16};   /** @brief TPESTS. */
  static const field32_t ETHERNET_MAC_MACDR_TFCSTS                      = {.msk = 0x00060000U, .pos = 17};   /** @brief TFCSTS. */
  static const field32_t ETHERNET_MAC_MACTSCR_TSENA                     = {.msk = 0x00000001U, .pos = 0};    /** @brief TSENA. */
  static const field32_t ETHERNET_MAC_MACTSCR_TSCFUPDT                  = {.msk = 0x00000002U, .pos = 1};    /** @brief TSCFUPDT. */
  static const field32_t ETHERNET_MAC_MACTSCR_TSINIT                    = {.msk = 0x00000004U, .pos = 2};    /** @brief TSINIT. */
  static const field32_t ETHERNET_MAC_MACTSCR_TSUPDT                    = {.msk = 0x00000008U, .pos = 3};    /** @brief TSUPDT. */
  static const field32_t ETHERNET_MAC_MACTSCR_TSADDREG                  = {.msk = 0x00000020U, .pos = 5};    /** @brief TSADDREG. */
  static const field32_t ETHERNET_MAC_MACTSCR_TSENALL                   = {.msk = 0x00000100U, .pos = 8};    /** @brief TSENALL. */
  static const field32_t ETHERNET_MAC_MACTSCR_TSCTRLSSR                 = {.msk = 0x00000200U, .pos = 9};    /** @brief TSCTRLSSR. */
  static const field32_t ETHERNET_MAC_MACTSCR_TSVER2ENA                 = {.msk = 0x00000400U, .pos = 10};   /** @brief TSVER2ENA. */
  static const field32_t ETHERNET_MAC_MACTSCR_TSIPENA                   = {.msk = 0x00000800U, .pos = 11};   /** @brief TSIPENA. */
  static const field32_t ETHERNET_MAC_MACTSCR_TSEVNTENA                 = {.msk = 0x00004000U, .pos = 14};   /** @brief TSEVNTENA. */
  static const field32_t ETHERNET_MAC_MACTSCR_TSMSTRENA                 = {.msk = 0x00008000U, .pos = 15};   /** @brief TSMSTRENA. */
  static const field32_t ETHERNET_MAC_MACTSCR_SNAPTYPSEL                = {.msk = 0x00030000U, .pos = 16};   /** @brief SNAPTYPSEL. */
  static const field32_t ETHERNET_MAC_MACTSCR_TSENMACADDR               = {.msk = 0x00040000U, .pos = 18};   /** @brief TSENMACADDR. */
  static const field32_t ETHERNET_MAC_MACTSCR_CSC                       = {.msk = 0x00080000U, .pos = 19};   /** @brief CSC. */
  static const field32_t ETHERNET_MAC_MACTSCR_TXTSSTSM                  = {.msk = 0x01000000U, .pos = 24};   /** @brief TXTSSTSM. */
  static const field32_t ETHERNET_MAC_MACSSIR_SNSINC                    = {.msk = 0x0000FF00U, .pos = 8};    /** @brief SNSINC. */
  static const field32_t ETHERNET_MAC_MACSSIR_SSINC                     = {.msk = 0x00FF0000U, .pos = 16};   /** @brief SSINC. */
  static const field32_t ETHERNET_MAC_MACSTNR_TSSS                      = {.msk = 0x7FFFFFFFU, .pos = 0};    /** @brief TSSS. */
  static const field32_t ETHERNET_MAC_MACSTNUR_TSSS                     = {.msk = 0x7FFFFFFFU, .pos = 0};    /** @brief TSSS. */
  static const field32_t ETHERNET_MAC_MACSTNUR_ADDSUB                   = {.msk = 0x80000000U, .pos = 31};   /** @brief ADDSUB. */
  static const field32_t ETHERNET_MAC_MACTSSR_TSSOVF                    = {.msk = 0x00000001U, .pos = 0};    /** @brief TSSOVF. */
  static const field32_t ETHERNET_MAC_MACTSSR_TSTARGT0                  = {.msk = 0x00000002U, .pos = 1};    /** @brief TSTARGT0. */
  static const field32_t ETHERNET_MAC_MACTSSR_AUXTSTRIG                 = {.msk = 0x00000004U, .pos = 2};    /** @brief AUXTSTRIG. */
  static const field32_t ETHERNET_MAC_MACTSSR_TSTRGTERR0                = {.msk = 0x00000008U, .pos = 3};    /** @brief TSTRGTERR0. */
  static const field32_t ETHERNET_MAC_MACTSSR_TXTSSIS                   = {.msk = 0x00008000U, .pos = 15};   /** @brief TXTSSIS. */
  static const field32_t ETHERNET_MAC_MACTSSR_ATSSTN                    = {.msk = 0x000F0000U, .pos = 16};   /** @brief ATSSTN. */
  static const field32_t ETHERNET_MAC_MACTSSR_ATSSTM                    = {.msk = 0x01000000U, .pos = 24};   /** @brief ATSSTM. */
  static const field32_t ETHERNET_MAC_MACTSSR_ATSNS                     = {.msk = 0x3E000000U, .pos = 25};   /** @brief ATSNS. */
  static const field32_t ETHERNET_MAC_MACTXTSSNR_TXTSSLO                = {.msk = 0x7FFFFFFFU, .pos = 0};    /** @brief TXTSSLO. */
  static const field32_t ETHERNET_MAC_MACTXTSSNR_TXTSSMIS               = {.msk = 0x80000000U, .pos = 31};   /** @brief TXTSSMIS. */
  static const field32_t ETHERNET_MAC_MACACR_ATSFC                      = {.msk = 0x00000001U, .pos = 0};    /** @brief ATSFC. */
  static const field32_t ETHERNET_MAC_MACATSNR_AUXTSLO                  = {.msk = 0x7FFFFFFFU, .pos = 0};    /** @brief AUXTSLO. */
  static const field32_t ETHERNET_MAC_MACPPSCR_PPSCTRL                  = {.msk = 0x0000000FU, .pos = 0};    /** @brief PPSCTRL. */
  static const field32_t ETHERNET_MAC_MACPPSCR_PPSEN0                   = {.msk = 0x00000010U, .pos = 4};    /** @brief PPSEN0. */
  static const field32_t ETHERNET_MAC_MACPPSCR_TRGTMODSEL0              = {.msk = 0x00000060U, .pos = 5};    /** @brief TRGTMODSEL0. */
  static const field32_t ETHERNET_MAC_MACPPSTTSR_TSTRH0                 = {.msk = 0x7FFFFFFFU, .pos = 0};    /** @brief TSTRH0. */
  static const field32_t ETHERNET_MAC_MACPPSTTNR_TTSL0                  = {.msk = 0x7FFFFFFFU, .pos = 0};    /** @brief TTSL0. */
  static const field32_t ETHERNET_MAC_MACPPSTTNR_TRGTBUSY0              = {.msk = 0x80000000U, .pos = 31};   /** @brief TRGTBUSY0. */
  static const field32_t ETHERNET_MAC_MACPOCR_PTOEN                     = {.msk = 0x00000001U, .pos = 0};    /** @brief PTOEN. */
  static const field32_t ETHERNET_MAC_MACPOCR_ASYNCEN                   = {.msk = 0x00000002U, .pos = 1};    /** @brief ASYNCEN. */
  static const field32_t ETHERNET_MAC_MACPOCR_APDREQEN                  = {.msk = 0x00000004U, .pos = 2};    /** @brief APDREQEN. */
  static const field32_t ETHERNET_MAC_MACPOCR_ASYNCTRIG                 = {.msk = 0x00000010U, .pos = 4};    /** @brief ASYNCTRIG. */
  static const field32_t ETHERNET_MAC_MACPOCR_APDREQTRIG                = {.msk = 0x00000020U, .pos = 5};    /** @brief APDREQTRIG. */
  static const field32_t ETHERNET_MAC_MACPOCR_DRRDIS                    = {.msk = 0x00000040U, .pos = 6};    /** @brief DRRDIS. */
  static const field32_t ETHERNET_MAC_MACPOCR_DN                        = {.msk = 0x0000FF00U, .pos = 8};    /** @brief DN. */
  static const field32_t ETHERNET_MAC_MACLMIR_LSI                       = {.msk = 0x000000FFU, .pos = 0};    /** @brief LSI. */
  static const field32_t ETHERNET_MAC_MACLMIR_DRSYNCR                   = {.msk = 0x00000700U, .pos = 8};    /** @brief DRSYNCR. */
  static const field32_t ETHERNET_MAC_MACLMIR_LMPDRI                    = {.msk = 0xFF000000U, .pos = 24};   /** @brief LMPDRI. */

  /**** Enumerated ETHERNET_MAC Register Field Definitions ****/

  static field32_t const ETHERNET_MAC_MACL3L4CxR_LxPEN0[5] = {
    [3] = {.msk = 0x00000001U, .pos = 0},    /** @brief L3PEN0. */
    [4] = {.msk = 0x00010000U, .pos = 16},   /** @brief L4PEN0. */
  };

  static field32_t const ETHERNET_MAC_MACTSCR_TSIPVxENA[7] = {
    [4] = {.msk = 0x00002000U, .pos = 13},   /** @brief TSIPV4ENA. */
    [6] = {.msk = 0x00001000U, .pos = 12},   /** @brief TSIPV6ENA. */
  };

  static field32_t const ETHERNET_MAC_MACACR_ATSENx[4] = {
    [0] = {.msk = 0x00000010U, .pos = 4},   /** @brief ATSEN0. */
    [1] = {.msk = 0x00000020U, .pos = 5},   /** @brief ATSEN1. */
    [2] = {.msk = 0x00000040U, .pos = 6},   /** @brief ATSEN2. */
    [3] = {.msk = 0x00000080U, .pos = 7},   /** @brief ATSEN3. */
  };

  /************************************************************************************************
   * DMAx Definitions
   ************************************************************************************************/

  /**** Enumerated DMAx Register Definitions ****/

  static const ro_reg32_t DMAx_LISR[3] = {
    [1] = (ro_reg32_t)0x40020000U,   /** @brief Low interrupt status register. */
    [2] = (ro_reg32_t)0x40020400U,   /** @brief Low interrupt status register. */
  };

  static const ro_reg32_t DMAx_HISR[3] = {
    [1] = (ro_reg32_t)0x40020004U,   /** @brief High interrupt status register. */
    [2] = (ro_reg32_t)0x40020404U,   /** @brief High interrupt status register. */
  };

  static const rw_reg32_t DMAx_LIFCR[3] = {
    [1] = (rw_reg32_t)0x40020008U,   /** @brief Low interrupt flag clear register. */
    [2] = (rw_reg32_t)0x40020408U,   /** @brief Low interrupt flag clear register. */
  };

  static const rw_reg32_t DMAx_HIFCR[3] = {
    [1] = (rw_reg32_t)0x4002000CU,   /** @brief High interrupt flag clear register. */
    [2] = (rw_reg32_t)0x4002040CU,   /** @brief High interrupt flag clear register. */
  };

  static const rw_reg32_t DMAx_SxCR[3][8] = {
    [1] = {
      [0] = (rw_reg32_t)0x40020010U,   /** @brief Stream x configuration register. */
      [1] = (rw_reg32_t)0x40020028U,   /** @brief Stream x configuration register. */
      [2] = (rw_reg32_t)0x40020040U,   /** @brief Stream x configuration register. */
      [3] = (rw_reg32_t)0x40020058U,   /** @brief Stream x configuration register. */
      [4] = (rw_reg32_t)0x40020070U,   /** @brief Stream x configuration register. */
      [5] = (rw_reg32_t)0x40020088U,   /** @brief Stream x configuration register. */
      [6] = (rw_reg32_t)0x400200A0U,   /** @brief Stream x configuration register. */
      [7] = (rw_reg32_t)0x400200B8U,   /** @brief Stream x configuration register. */
    },
    [2] = {
      [0] = (rw_reg32_t)0x40020410U,   /** @brief Stream x configuration register. */
      [1] = (rw_reg32_t)0x40020428U,   /** @brief Stream x configuration register. */
      [2] = (rw_reg32_t)0x40020440U,   /** @brief Stream x configuration register. */
      [3] = (rw_reg32_t)0x40020458U,   /** @brief Stream x configuration register. */
      [4] = (rw_reg32_t)0x40020470U,   /** @brief Stream x configuration register. */
      [5] = (rw_reg32_t)0x40020488U,   /** @brief Stream x configuration register. */
      [6] = (rw_reg32_t)0x400204A0U,   /** @brief Stream x configuration register. */
      [7] = (rw_reg32_t)0x400204B8U,   /** @brief Stream x configuration register. */
    },
  };

  static const rw_reg32_t DMAx_SxNDTR[3][8] = {
    [1] = {
      [0] = (rw_reg32_t)0x40020014U,   /** @brief Stream x number of data register. */
      [1] = (rw_reg32_t)0x4002002CU,   /** @brief Stream x number of data register. */
      [2] = (rw_reg32_t)0x40020044U,   /** @brief Stream x number of data register. */
      [3] = (rw_reg32_t)0x4002005CU,   /** @brief Stream x number of data register. */
      [4] = (rw_reg32_t)0x40020074U,   /** @brief Stream x number of data register. */
      [5] = (rw_reg32_t)0x4002008CU,   /** @brief Stream x number of data register. */
      [6] = (rw_reg32_t)0x400200A4U,   /** @brief Stream x number of data register. */
      [7] = (rw_reg32_t)0x400200BCU,   /** @brief Stream x number of data register. */
    },
    [2] = {
      [0] = (rw_reg32_t)0x40020414U,   /** @brief Stream x number of data register. */
      [1] = (rw_reg32_t)0x4002042CU,   /** @brief Stream x number of data register. */
      [2] = (rw_reg32_t)0x40020444U,   /** @brief Stream x number of data register. */
      [3] = (rw_reg32_t)0x4002045CU,   /** @brief Stream x number of data register. */
      [4] = (rw_reg32_t)0x40020474U,   /** @brief Stream x number of data register. */
      [5] = (rw_reg32_t)0x4002048CU,   /** @brief Stream x number of data register. */
      [6] = (rw_reg32_t)0x400204A4U,   /** @brief Stream x number of data register. */
      [7] = (rw_reg32_t)0x400204BCU,   /** @brief Stream x number of data register. */
    },
  };

  static const rw_reg32_t DMAx_SxPAR[3][8] = {
    [1] = {
      [0] = (rw_reg32_t)0x40020018U,   /** @brief Stream x peripheral address register. */
      [1] = (rw_reg32_t)0x40020030U,   /** @brief Stream x peripheral address register. */
      [2] = (rw_reg32_t)0x40020048U,   /** @brief Stream x peripheral address register. */
      [3] = (rw_reg32_t)0x40020060U,   /** @brief Stream x peripheral address register. */
      [4] = (rw_reg32_t)0x40020078U,   /** @brief Stream x peripheral address register. */
      [5] = (rw_reg32_t)0x40020090U,   /** @brief Stream x peripheral address register. */
      [6] = (rw_reg32_t)0x400200A8U,   /** @brief Stream x peripheral address register. */
      [7] = (rw_reg32_t)0x400200C0U,   /** @brief Stream x peripheral address register. */
    },
    [2] = {
      [0] = (rw_reg32_t)0x40020418U,   /** @brief Stream x peripheral address register. */
      [1] = (rw_reg32_t)0x40020430U,   /** @brief Stream x peripheral address register. */
      [2] = (rw_reg32_t)0x40020448U,   /** @brief Stream x peripheral address register. */
      [3] = (rw_reg32_t)0x40020460U,   /** @brief Stream x peripheral address register. */
      [4] = (rw_reg32_t)0x40020478U,   /** @brief Stream x peripheral address register. */
      [5] = (rw_reg32_t)0x40020490U,   /** @brief Stream x peripheral address register. */
      [6] = (rw_reg32_t)0x400204A8U,   /** @brief Stream x peripheral address register. */
      [7] = (rw_reg32_t)0x400204C0U,   /** @brief Stream x peripheral address register. */
    },
  };

  static const rw_reg32_t DMAx_SxM0AR[3][8] = {
    [1] = {
      [0] = (rw_reg32_t)0x4002001CU,   /** @brief Stream x memory 0 address register. */
      [1] = (rw_reg32_t)0x40020034U,   /** @brief Stream x memory 0 address register. */
      [2] = (rw_reg32_t)0x4002004CU,   /** @brief Stream x memory 0 address register. */
      [3] = (rw_reg32_t)0x40020064U,   /** @brief Stream x memory 0 address register. */
      [4] = (rw_reg32_t)0x4002007CU,   /** @brief Stream x memory 0 address register. */
      [5] = (rw_reg32_t)0x40020094U,   /** @brief Stream x memory 0 address register. */
      [6] = (rw_reg32_t)0x400200ACU,   /** @brief Stream x memory 0 address register. */
      [7] = (rw_reg32_t)0x400200C4U,   /** @brief Stream x memory 0 address register. */
    },
    [2] = {
      [0] = (rw_reg32_t)0x4002041CU,   /** @brief Stream x memory 0 address register. */
      [1] = (rw_reg32_t)0x40020434U,   /** @brief Stream x memory 0 address register. */
      [2] = (rw_reg32_t)0x4002044CU,   /** @brief Stream x memory 0 address register. */
      [3] = (rw_reg32_t)0x40020464U,   /** @brief Stream x memory 0 address register. */
      [4] = (rw_reg32_t)0x4002047CU,   /** @brief Stream x memory 0 address register. */
      [5] = (rw_reg32_t)0x40020494U,   /** @brief Stream x memory 0 address register. */
      [6] = (rw_reg32_t)0x400204ACU,   /** @brief Stream x memory 0 address register. */
      [7] = (rw_reg32_t)0x400204C4U,   /** @brief Stream x memory 0 address register. */
    },
  };

  static const rw_reg32_t DMAx_SxFCR[3][8] = {
    [1] = {
      [0] = (rw_reg32_t)0x40020024U,   /** @brief Stream x FIFO control register. */
      [1] = (rw_reg32_t)0x4002003CU,   /** @brief Stream x FIFO control register. */
      [2] = (rw_reg32_t)0x40020054U,   /** @brief Stream x FIFO control register. */
      [3] = (rw_reg32_t)0x4002006CU,   /** @brief Stream x FIFO control register. */
      [4] = (rw_reg32_t)0x40020084U,   /** @brief Stream x FIFO control register. */
      [5] = (rw_reg32_t)0x4002009CU,   /** @brief Stream x FIFO control register. */
      [6] = (rw_reg32_t)0x400200B4U,   /** @brief Stream x FIFO control register. */
      [7] = (rw_reg32_t)0x400200CCU,   /** @brief Stream x FIFO control register. */
    },
    [2] = {
      [0] = (rw_reg32_t)0x40020424U,   /** @brief Stream x FIFO control register. */
      [1] = (rw_reg32_t)0x4002043CU,   /** @brief Stream x FIFO control register. */
      [2] = (rw_reg32_t)0x40020454U,   /** @brief Stream x FIFO control register. */
      [3] = (rw_reg32_t)0x4002046CU,   /** @brief Stream x FIFO control register. */
      [4] = (rw_reg32_t)0x40020484U,   /** @brief Stream x FIFO control register. */
      [5] = (rw_reg32_t)0x4002049CU,   /** @brief Stream x FIFO control register. */
      [6] = (rw_reg32_t)0x400204B4U,   /** @brief Stream x FIFO control register. */
      [7] = (rw_reg32_t)0x400204CCU,   /** @brief Stream x FIFO control register. */
    },
  };

  static const rw_reg32_t DMAx_SxM1AR[3][8] = {
    [1] = {
      [1] = (rw_reg32_t)0x40020038U,   /** @brief Stream x memory 1 address register. */
      [2] = (rw_reg32_t)0x40020050U,   /** @brief Stream x memory 1 address register. */
      [3] = (rw_reg32_t)0x40020068U,   /** @brief Stream x memory 1 address register. */
      [4] = (rw_reg32_t)0x40020080U,   /** @brief Stream x memory 1 address register. */
      [5] = (rw_reg32_t)0x40020098U,   /** @brief Stream x memory 1 address register. */
      [6] = (rw_reg32_t)0x400200B0U,   /** @brief Stream x memory 1 address register. */
      [7] = (rw_reg32_t)0x400200C8U,   /** @brief Stream x memory 1 address register. */
    },
    [2] = {
      [1] = (rw_reg32_t)0x40020438U,   /** @brief Stream x memory 1 address register. */
      [2] = (rw_reg32_t)0x40020450U,   /** @brief Stream x memory 1 address register. */
      [3] = (rw_reg32_t)0x40020468U,   /** @brief Stream x memory 1 address register. */
      [4] = (rw_reg32_t)0x40020480U,   /** @brief Stream x memory 1 address register. */
      [5] = (rw_reg32_t)0x40020498U,   /** @brief Stream x memory 1 address register. */
      [6] = (rw_reg32_t)0x400204B0U,   /** @brief Stream x memory 1 address register. */
      [7] = (rw_reg32_t)0x400204C8U,   /** @brief Stream x memory 1 address register. */
    },
  };

  /**** DMAx Register Field Definitions ****/

  static const field32_t DMAx_SxCR_MBURST = {.msk = 0x01800000U, .pos = 23};   /** @brief Memory burst transfer configuration. */
  static const field32_t DMAx_SxCR_PBURST = {.msk = 0x00600000U, .pos = 21};   /** @brief Peripheral burst transfer configuration. */
  static const field32_t DMAx_SxCR_TRBUFF = {.msk = 0x00100000U, .pos = 20};   /** @brief Bufferable transfer enable. */
  static const field32_t DMAx_SxCR_CT     = {.msk = 0x00080000U, .pos = 19};   /** @brief Current target (only in double buffer mode). */
  static const field32_t DMAx_SxCR_DBM    = {.msk = 0x00040000U, .pos = 18};   /** @brief Double buffer mode. */
  static const field32_t DMAx_SxCR_PL     = {.msk = 0x00030000U, .pos = 16};   /** @brief Priority level. */
  static const field32_t DMAx_SxCR_PINCOS = {.msk = 0x00008000U, .pos = 15};   /** @brief Peripheral increment offset size. */
  static const field32_t DMAx_SxCR_MSIZE  = {.msk = 0x00006000U, .pos = 13};   /** @brief Memory data size. */
  static const field32_t DMAx_SxCR_PSIZE  = {.msk = 0x00001800U, .pos = 11};   /** @brief Peripheral data size. */
  static const field32_t DMAx_SxCR_MINC   = {.msk = 0x00000400U, .pos = 10};   /** @brief Memory increment mode. */
  static const field32_t DMAx_SxCR_PINC   = {.msk = 0x00000200U, .pos = 9};    /** @brief Peripheral increment mode. */
  static const field32_t DMAx_SxCR_CIRC   = {.msk = 0x00000100U, .pos = 8};    /** @brief Circular mode. */
  static const field32_t DMAx_SxCR_DIR    = {.msk = 0x000000C0U, .pos = 6};    /** @brief Data transfer direction. */
  static const field32_t DMAx_SxCR_PFCTRL = {.msk = 0x00000020U, .pos = 5};    /** @brief Peripheral flow controller. */
  static const field32_t DMAx_SxCR_TCIE   = {.msk = 0x00000010U, .pos = 4};    /** @brief Transfer complete interrupt enable. */
  static const field32_t DMAx_SxCR_HTIE   = {.msk = 0x00000008U, .pos = 3};    /** @brief Half transfer interrupt enable. */
  static const field32_t DMAx_SxCR_TEIE   = {.msk = 0x00000004U, .pos = 2};    /** @brief Transfer error interrupt enable. */
  static const field32_t DMAx_SxCR_DMEIE  = {.msk = 0x00000002U, .pos = 1};    /** @brief Direct mode error interrupt enable. */
  static const field32_t DMAx_SxCR_EN     = {.msk = 0x00000001U, .pos = 0};    /** @brief Stream enable / flag stream ready when read low. */
  static const field32_t DMAx_SxNDTR_NDT  = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Number of data items to transfer. */
  static const field32_t DMAx_SxFCR_FEIE  = {.msk = 0x00000080U, .pos = 7};    /** @brief FIFO error interrupt enable. */
  static const field32_t DMAx_SxFCR_FS    = {.msk = 0x00000038U, .pos = 3};    /** @brief FIFO status. */
  static const field32_t DMAx_SxFCR_DMDIS = {.msk = 0x00000004U, .pos = 2};    /** @brief Direct mode disable. */
  static const field32_t DMAx_SxFCR_FTH   = {.msk = 0x00000003U, .pos = 0};    /** @brief FIFO threshold selection. */

  /**** Enumerated DMAx Register Field Definitions ****/

  static field32_t const DMAx_LISR_TCIFx[4] = {
    [0] = {.msk = 0x00000020U, .pos = 5},    /** @brief Stream x transfer complete interrupt flag (x = 3..0). */
    [1] = {.msk = 0x00000800U, .pos = 11},   /** @brief Stream x transfer complete interrupt flag (x = 3..0). */
    [2] = {.msk = 0x00200000U, .pos = 21},   /** @brief Stream x transfer complete interrupt flag (x = 3..0). */
    [3] = {.msk = 0x08000000U, .pos = 27},   /** @brief Stream x transfer complete interrupt flag (x = 3..0). */
  };

  static field32_t const DMAx_LISR_HTIFx[4] = {
    [0] = {.msk = 0x00000010U, .pos = 4},    /** @brief Stream x half transfer interrupt flag (x=3..0). */
    [1] = {.msk = 0x00000400U, .pos = 10},   /** @brief Stream x half transfer interrupt flag (x=3..0). */
    [2] = {.msk = 0x00100000U, .pos = 20},   /** @brief Stream x half transfer interrupt flag (x=3..0). */
    [3] = {.msk = 0x04000000U, .pos = 26},   /** @brief Stream x half transfer interrupt flag (x=3..0). */
  };

  static field32_t const DMAx_LISR_TEIFx[4] = {
    [0] = {.msk = 0x00000008U, .pos = 3},    /** @brief Stream x transfer error interrupt flag (x=3..0). */
    [1] = {.msk = 0x00000200U, .pos = 9},    /** @brief Stream x transfer error interrupt flag (x=3..0). */
    [2] = {.msk = 0x00080000U, .pos = 19},   /** @brief Stream x transfer error interrupt flag (x=3..0). */
    [3] = {.msk = 0x02000000U, .pos = 25},   /** @brief Stream x transfer error interrupt flag (x=3..0). */
  };

  static field32_t const DMAx_LISR_DMEIFx[4] = {
    [0] = {.msk = 0x00000004U, .pos = 2},    /** @brief Stream x direct mode error interrupt flag (x=3..0). */
    [1] = {.msk = 0x00000100U, .pos = 8},    /** @brief Stream x direct mode error interrupt flag (x=3..0). */
    [2] = {.msk = 0x00040000U, .pos = 18},   /** @brief Stream x direct mode error interrupt flag (x=3..0). */
    [3] = {.msk = 0x01000000U, .pos = 24},   /** @brief Stream x direct mode error interrupt flag (x=3..0). */
  };

  static field32_t const DMAx_LISR_FEIFx[4] = {
    [0] = {.msk = 0x00000001U, .pos = 0},    /** @brief Stream x FIFO error interrupt flag (x=3..0). */
    [1] = {.msk = 0x00000040U, .pos = 6},    /** @brief Stream x FIFO error interrupt flag (x=3..0). */
    [2] = {.msk = 0x00010000U, .pos = 16},   /** @brief Stream x FIFO error interrupt flag (x=3..0). */
    [3] = {.msk = 0x00400000U, .pos = 22},   /** @brief Stream x FIFO error interrupt flag (x=3..0). */
  };

  static field32_t const DMAx_LIFCR_CTCIFx[4] = {
    [0] = {.msk = 0x00000020U, .pos = 5},    /** @brief Stream x clear transfer complete interrupt flag (x = 3..0). */
    [1] = {.msk = 0x00000800U, .pos = 11},   /** @brief Stream x clear transfer complete interrupt flag (x = 3..0). */
    [2] = {.msk = 0x00200000U, .pos = 21},   /** @brief Stream x clear transfer complete interrupt flag (x = 3..0). */
    [3] = {.msk = 0x08000000U, .pos = 27},   /** @brief Stream x clear transfer complete interrupt flag (x = 3..0). */
  };

  static field32_t const DMAx_LIFCR_CHTIFx[4] = {
    [0] = {.msk = 0x00000010U, .pos = 4},    /** @brief Stream x clear half transfer interrupt flag (x = 3..0). */
    [1] = {.msk = 0x00000400U, .pos = 10},   /** @brief Stream x clear half transfer interrupt flag (x = 3..0). */
    [2] = {.msk = 0x00100000U, .pos = 20},   /** @brief Stream x clear half transfer interrupt flag (x = 3..0). */
    [3] = {.msk = 0x04000000U, .pos = 26},   /** @brief Stream x clear half transfer interrupt flag (x = 3..0). */
  };

  static field32_t const DMAx_LIFCR_CTEIFx[4] = {
    [0] = {.msk = 0x00000008U, .pos = 3},    /** @brief Stream x clear transfer error interrupt flag (x = 3..0). */
    [1] = {.msk = 0x00000200U, .pos = 9},    /** @brief Stream x clear transfer error interrupt flag (x = 3..0). */
    [2] = {.msk = 0x00080000U, .pos = 19},   /** @brief Stream x clear transfer error interrupt flag (x = 3..0). */
    [3] = {.msk = 0x02000000U, .pos = 25},   /** @brief Stream x clear transfer error interrupt flag (x = 3..0). */
  };

  static field32_t const DMAx_LIFCR_CDMEIFx[4] = {
    [0] = {.msk = 0x00000004U, .pos = 2},    /** @brief Stream x clear direct mode error interrupt flag (x = 3..0). */
    [1] = {.msk = 0x00000100U, .pos = 8},    /** @brief Stream x clear direct mode error interrupt flag (x = 3..0). */
    [2] = {.msk = 0x00040000U, .pos = 18},   /** @brief Stream x clear direct mode error interrupt flag (x = 3..0). */
    [3] = {.msk = 0x01000000U, .pos = 24},   /** @brief Stream x clear direct mode error interrupt flag (x = 3..0). */
  };

  static field32_t const DMAx_LIFCR_CFEIFx[4] = {
    [0] = {.msk = 0x00000001U, .pos = 0},    /** @brief Stream x clear FIFO error interrupt flag (x = 3..0). */
    [1] = {.msk = 0x00000040U, .pos = 6},    /** @brief Stream x clear FIFO error interrupt flag (x = 3..0). */
    [2] = {.msk = 0x00010000U, .pos = 16},   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0). */
    [3] = {.msk = 0x00400000U, .pos = 22},   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0). */
  };

  /************************************************************************************************
   * HRTIM_MASTER Definitions
   ************************************************************************************************/

  /**** HRTIM_MASTER Register Definitions ****/

  static const rw_reg32_t HRTIM_MASTER_MCR    = (rw_reg32_t)0x40017400U;   /** @brief Master timer control register. */
  static const ro_reg32_t HRTIM_MASTER_MISR   = (ro_reg32_t)0x40017404U;   /** @brief Master timer interrupt status register. */
  static const rw_reg32_t HRTIM_MASTER_MICR   = (rw_reg32_t)0x40017408U;   /** @brief Master timer interrupt clear register. */
  static const rw_reg32_t HRTIM_MASTER_MDIER4 = (rw_reg32_t)0x4001740CU;   /** @brief MDIER4. */
  static const rw_reg32_t HRTIM_MASTER_MCNTR  = (rw_reg32_t)0x40017410U;   /** @brief Master timer counter register. */
  static const rw_reg32_t HRTIM_MASTER_MPER   = (rw_reg32_t)0x40017414U;   /** @brief Master timer period register. */
  static const rw_reg32_t HRTIM_MASTER_MREP   = (rw_reg32_t)0x40017418U;   /** @brief Master timer repetition register. */

  /**** Enumerated HRTIM_MASTER Register Definitions ****/

  static const rw_reg32_t HRTIM_MASTER_MCMPxR[5] = {
    [1] = (rw_reg32_t)0x4001741CU,   /** @brief Master timer compare 1 register. */
    [2] = (rw_reg32_t)0x40017424U,   /** @brief Master timer compare 2 register. */
    [3] = (rw_reg32_t)0x40017428U,   /** @brief Master timer compare 3 register. */
    [4] = (rw_reg32_t)0x4001742CU,   /** @brief Master timer compare 4 register. */
  };

  /**** HRTIM_MASTER Register Field Definitions ****/

  static const field32_t HRTIM_MASTER_MCR_BRSTDMA   = {.msk = 0xC0000000U, .pos = 30};   /** @brief Burst DMA update. */
  static const field32_t HRTIM_MASTER_MCR_MREPU     = {.msk = 0x20000000U, .pos = 29};   /** @brief Master timer repetition update. */
  static const field32_t HRTIM_MASTER_MCR_PREEN     = {.msk = 0x08000000U, .pos = 27};   /** @brief Preload enable. */
  static const field32_t HRTIM_MASTER_MCR_DACSYNC   = {.msk = 0x06000000U, .pos = 25};   /** @brief AC synchronization. */
  static const field32_t HRTIM_MASTER_MCR_TECEN     = {.msk = 0x00200000U, .pos = 21};   /** @brief Timer E counter enable. */
  static const field32_t HRTIM_MASTER_MCR_TDCEN     = {.msk = 0x00100000U, .pos = 20};   /** @brief Timer D counter enable. */
  static const field32_t HRTIM_MASTER_MCR_TCCEN     = {.msk = 0x00080000U, .pos = 19};   /** @brief Timer C counter enable. */
  static const field32_t HRTIM_MASTER_MCR_TBCEN     = {.msk = 0x00040000U, .pos = 18};   /** @brief Timer B counter enable. */
  static const field32_t HRTIM_MASTER_MCR_TACEN     = {.msk = 0x00020000U, .pos = 17};   /** @brief Timer A counter enable. */
  static const field32_t HRTIM_MASTER_MCR_MCEN      = {.msk = 0x00010000U, .pos = 16};   /** @brief Master counter enable. */
  static const field32_t HRTIM_MASTER_MCR_SYNC_SRC  = {.msk = 0x0000C000U, .pos = 14};   /** @brief Synchronization source. */
  static const field32_t HRTIM_MASTER_MCR_SYNC_OUT  = {.msk = 0x00003000U, .pos = 12};   /** @brief Synchronization output. */
  static const field32_t HRTIM_MASTER_MCR_SYNCSTRTM = {.msk = 0x00000800U, .pos = 11};   /** @brief Synchronization starts master. */
  static const field32_t HRTIM_MASTER_MCR_SYNCRSTM  = {.msk = 0x00000400U, .pos = 10};   /** @brief Synchronization resets master. */
  static const field32_t HRTIM_MASTER_MCR_SYNC_IN   = {.msk = 0x00000300U, .pos = 8};    /** @brief Ynchronization input. */
  static const field32_t HRTIM_MASTER_MCR_HALF      = {.msk = 0x00000020U, .pos = 5};    /** @brief Half mode enable. */
  static const field32_t HRTIM_MASTER_MCR_RETRIG    = {.msk = 0x00000010U, .pos = 4};    /** @brief Master re-triggerable mode. */
  static const field32_t HRTIM_MASTER_MCR_CONT      = {.msk = 0x00000008U, .pos = 3};    /** @brief Master continuous mode. */
  static const field32_t HRTIM_MASTER_MCR_CK_PSC    = {.msk = 0x00000007U, .pos = 0};    /** @brief HRTIM master clock prescaler. */
  static const field32_t HRTIM_MASTER_MISR_MUPD     = {.msk = 0x00000040U, .pos = 6};    /** @brief Master update interrupt flag. */
  static const field32_t HRTIM_MASTER_MISR_SYNC     = {.msk = 0x00000020U, .pos = 5};    /** @brief Sync input interrupt flag. */
  static const field32_t HRTIM_MASTER_MISR_MREP     = {.msk = 0x00000010U, .pos = 4};    /** @brief Master repetition interrupt flag. */
  static const field32_t HRTIM_MASTER_MICR_MUPDC    = {.msk = 0x00000040U, .pos = 6};    /** @brief Master update interrupt flag clear. */
  static const field32_t HRTIM_MASTER_MICR_SYNCC    = {.msk = 0x00000020U, .pos = 5};    /** @brief Sync input interrupt flag clear. */
  static const field32_t HRTIM_MASTER_MICR_MREPC    = {.msk = 0x00000010U, .pos = 4};    /** @brief Repetition interrupt flag clear. */
  static const field32_t HRTIM_MASTER_MDIER4_MUPDDE = {.msk = 0x00400000U, .pos = 22};   /** @brief MUPDDE. */
  static const field32_t HRTIM_MASTER_MDIER4_SYNCDE = {.msk = 0x00200000U, .pos = 21};   /** @brief SYNCDE. */
  static const field32_t HRTIM_MASTER_MDIER4_MREPDE = {.msk = 0x00100000U, .pos = 20};   /** @brief MREPDE. */
  static const field32_t HRTIM_MASTER_MDIER4_MUPDIE = {.msk = 0x00000040U, .pos = 6};    /** @brief MUPDIE. */
  static const field32_t HRTIM_MASTER_MDIER4_SYNCIE = {.msk = 0x00000020U, .pos = 5};    /** @brief SYNCIE. */
  static const field32_t HRTIM_MASTER_MDIER4_MREPIE = {.msk = 0x00000010U, .pos = 4};    /** @brief MREPIE. */
  static const field32_t HRTIM_MASTER_MCNTR_MCNT    = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Counter value. */
  static const field32_t HRTIM_MASTER_MPER_MPER     = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Master timer period value. */
  static const field32_t HRTIM_MASTER_MREP_MREP     = {.msk = 0x000000FFU, .pos = 0};    /** @brief Master timer repetition counter value. */
  static const field32_t HRTIM_MASTER_MCMPxR_MCMP1  = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Master timer compare 1 value. */

  /**** Enumerated HRTIM_MASTER Register Field Definitions ****/

  static field32_t const HRTIM_MASTER_MISR_MCMPx[5] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief Master compare 1 interrupt flag. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief Master compare 2 interrupt flag. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief Master compare 3 interrupt flag. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief Master compare 4 interrupt flag. */
  };

  static field32_t const HRTIM_MASTER_MICR_MCMPxC[5] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief Master compare 1 interrupt flag clear. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief Master compare 2 interrupt flag clear. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief Master compare 3 interrupt flag clear. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief Master compare 4 interrupt flag clear. */
  };

  static field32_t const HRTIM_MASTER_MDIER4_MCMPxDE[5] = {
    [1] = {.msk = 0x00010000U, .pos = 16},   /** @brief MCMP1DE. */
    [2] = {.msk = 0x00020000U, .pos = 17},   /** @brief MCMP2DE. */
    [3] = {.msk = 0x00040000U, .pos = 18},   /** @brief MCMP3DE. */
    [4] = {.msk = 0x00080000U, .pos = 19},   /** @brief MCMP4DE. */
  };

  static field32_t const HRTIM_MASTER_MDIER4_MCMPxIE[5] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief MCMP1IE. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief MCMP2IE. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief MCMP3IE. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief MCMP4IE. */
  };

  /************************************************************************************************
   * HRTIM_TIMA Definitions
   ************************************************************************************************/

  /**** HRTIM_TIMA Register Definitions ****/

  static const rw_reg32_t HRTIM_TIMA_TIMACR    = (rw_reg32_t)0x40017480U;   /** @brief Timerx control register. */
  static const ro_reg32_t HRTIM_TIMA_TIMAISR   = (ro_reg32_t)0x40017484U;   /** @brief Timerx interrupt status register. */
  static const rw_reg32_t HRTIM_TIMA_TIMAICR   = (rw_reg32_t)0x40017488U;   /** @brief Timerx interrupt clear register. */
  static const rw_reg32_t HRTIM_TIMA_TIMADIER5 = (rw_reg32_t)0x4001748CU;   /** @brief TIMxDIER5. */
  static const rw_reg32_t HRTIM_TIMA_CNTAR     = (rw_reg32_t)0x40017490U;   /** @brief Timerx counter register. */
  static const rw_reg32_t HRTIM_TIMA_PERAR     = (rw_reg32_t)0x40017494U;   /** @brief Timerx period register. */
  static const rw_reg32_t HRTIM_TIMA_REPAR     = (rw_reg32_t)0x40017498U;   /** @brief Timerx repetition register. */
  static const rw_reg32_t HRTIM_TIMA_CMP1CAR   = (rw_reg32_t)0x400174A0U;   /** @brief Timerx compare 1 compound register. */
  static const rw_reg32_t HRTIM_TIMA_DTAR      = (rw_reg32_t)0x400174B8U;   /** @brief Timerx deadtime register. */
  static const rw_reg32_t HRTIM_TIMA_RSTAR     = (rw_reg32_t)0x400174D4U;   /** @brief TimerA reset register. */
  static const rw_reg32_t HRTIM_TIMA_CHPAR     = (rw_reg32_t)0x400174D8U;   /** @brief Timerx chopper register. */
  static const rw_reg32_t HRTIM_TIMA_OUTAR     = (rw_reg32_t)0x400174E4U;   /** @brief Timerx output register. */
  static const rw_reg32_t HRTIM_TIMA_FLTAR     = (rw_reg32_t)0x400174E8U;   /** @brief Timerx fault register. */

  /**** Enumerated HRTIM_TIMA Register Definitions ****/

  static const rw_reg32_t HRTIM_TIMA_CMPxAR[5] = {
    [1] = (rw_reg32_t)0x4001749CU,   /** @brief Timerx compare 1 register. */
    [2] = (rw_reg32_t)0x400174A4U,   /** @brief Timerx compare 2 register. */
    [3] = (rw_reg32_t)0x400174A8U,   /** @brief Timerx compare 3 register. */
    [4] = (rw_reg32_t)0x400174ACU,   /** @brief Timerx compare 4 register. */
  };

  static const ro_reg32_t HRTIM_TIMA_CPTxAR[3] = {
    [1] = (ro_reg32_t)0x400174B0U,   /** @brief Timerx capture 1 register. */
    [2] = (ro_reg32_t)0x400174B4U,   /** @brief Timerx capture 2 register. */
  };

  static const rw_reg32_t HRTIM_TIMA_SETAxR[3] = {
    [1] = (rw_reg32_t)0x400174BCU,   /** @brief Timerx output1 set register. */
    [2] = (rw_reg32_t)0x400174C4U,   /** @brief Timerx output2 set register. */
  };

  static const rw_reg32_t HRTIM_TIMA_RSTAxR[3] = {
    [1] = (rw_reg32_t)0x400174C0U,   /** @brief Timerx output1 reset register. */
    [2] = (rw_reg32_t)0x400174C8U,   /** @brief Timerx output2 reset register. */
  };

  static const rw_reg32_t HRTIM_TIMA_EEFARx[3] = {
    [1] = (rw_reg32_t)0x400174CCU,   /** @brief Timerx external event filtering register 1. */
    [2] = (rw_reg32_t)0x400174D0U,   /** @brief Timerx external event filtering register 2. */
  };

  static const rw_reg32_t HRTIM_TIMA_CPTxACR[3] = {
    [1] = (rw_reg32_t)0x400174DCU,   /** @brief Timerx capture 2 control register. */
    [2] = (rw_reg32_t)0x400174E0U,   /** @brief CPT2xCR. */
  };

  /**** HRTIM_TIMA Register Field Definitions ****/

  static const field32_t HRTIM_TIMA_TIMACR_UPDGAT      = {.msk = 0xF0000000U, .pos = 28};   /** @brief Update gating. */
  static const field32_t HRTIM_TIMA_TIMACR_PREEN       = {.msk = 0x08000000U, .pos = 27};   /** @brief Preload enable. */
  static const field32_t HRTIM_TIMA_TIMACR_DACSYNC     = {.msk = 0x06000000U, .pos = 25};   /** @brief AC synchronization. */
  static const field32_t HRTIM_TIMA_TIMACR_MSTU        = {.msk = 0x01000000U, .pos = 24};   /** @brief Master timer update. */
  static const field32_t HRTIM_TIMA_TIMACR_TEU         = {.msk = 0x00800000U, .pos = 23};   /** @brief TEU. */
  static const field32_t HRTIM_TIMA_TIMACR_TDU         = {.msk = 0x00400000U, .pos = 22};   /** @brief TDU. */
  static const field32_t HRTIM_TIMA_TIMACR_TCU         = {.msk = 0x00200000U, .pos = 21};   /** @brief TCU. */
  static const field32_t HRTIM_TIMA_TIMACR_TBU         = {.msk = 0x00100000U, .pos = 20};   /** @brief TBU. */
  static const field32_t HRTIM_TIMA_TIMACR_TXRSTU      = {.msk = 0x00040000U, .pos = 18};   /** @brief Timerx reset update. */
  static const field32_t HRTIM_TIMA_TIMACR_TXREPU      = {.msk = 0x00020000U, .pos = 17};   /** @brief Timer x repetition update. */
  static const field32_t HRTIM_TIMA_TIMACR_SYNCSTRTX   = {.msk = 0x00000800U, .pos = 11};   /** @brief Synchronization starts timer x. */
  static const field32_t HRTIM_TIMA_TIMACR_SYNCRSTX    = {.msk = 0x00000400U, .pos = 10};   /** @brief Synchronization resets timer x. */
  static const field32_t HRTIM_TIMA_TIMACR_PSHPLL      = {.msk = 0x00000040U, .pos = 6};    /** @brief Push-Pull mode enable. */
  static const field32_t HRTIM_TIMA_TIMACR_HALF        = {.msk = 0x00000020U, .pos = 5};    /** @brief Half mode enable. */
  static const field32_t HRTIM_TIMA_TIMACR_RETRIG      = {.msk = 0x00000010U, .pos = 4};    /** @brief Re-triggerable mode. */
  static const field32_t HRTIM_TIMA_TIMACR_CONT        = {.msk = 0x00000008U, .pos = 3};    /** @brief Continuous mode. */
  static const field32_t HRTIM_TIMA_TIMACR_CK_PSCX     = {.msk = 0x00000007U, .pos = 0};    /** @brief HRTIM timer x clock prescaler. */
  static const field32_t HRTIM_TIMA_TIMAISR_IPPSTAT    = {.msk = 0x00020000U, .pos = 17};   /** @brief Idle push pull status. */
  static const field32_t HRTIM_TIMA_TIMAISR_CPPSTAT    = {.msk = 0x00010000U, .pos = 16};   /** @brief Current push pull status. */
  static const field32_t HRTIM_TIMA_TIMAISR_DLYPRT     = {.msk = 0x00004000U, .pos = 14};   /** @brief Delayed protection flag. */
  static const field32_t HRTIM_TIMA_TIMAISR_RST        = {.msk = 0x00002000U, .pos = 13};   /** @brief Reset interrupt flag. */
  static const field32_t HRTIM_TIMA_TIMAISR_UPD        = {.msk = 0x00000040U, .pos = 6};    /** @brief Update interrupt flag. */
  static const field32_t HRTIM_TIMA_TIMAISR_REP        = {.msk = 0x00000010U, .pos = 4};    /** @brief Repetition interrupt flag. */
  static const field32_t HRTIM_TIMA_TIMAICR_DLYPRTC    = {.msk = 0x00004000U, .pos = 14};   /** @brief Delayed protection flag clear. */
  static const field32_t HRTIM_TIMA_TIMAICR_RSTC       = {.msk = 0x00002000U, .pos = 13};   /** @brief Reset interrupt flag clear. */
  static const field32_t HRTIM_TIMA_TIMAICR_UPDC       = {.msk = 0x00000040U, .pos = 6};    /** @brief Update interrupt flag clear. */
  static const field32_t HRTIM_TIMA_TIMAICR_REPC       = {.msk = 0x00000010U, .pos = 4};    /** @brief Repetition interrupt flag clear. */
  static const field32_t HRTIM_TIMA_TIMADIER5_DLYPRTDE = {.msk = 0x40000000U, .pos = 30};   /** @brief DLYPRTDE. */
  static const field32_t HRTIM_TIMA_TIMADIER5_RSTDE    = {.msk = 0x20000000U, .pos = 29};   /** @brief RSTDE. */
  static const field32_t HRTIM_TIMA_TIMADIER5_SETX2DE  = {.msk = 0x08000000U, .pos = 27};   /** @brief SETx2DE. */
  static const field32_t HRTIM_TIMA_TIMADIER5_SET1XDE  = {.msk = 0x02000000U, .pos = 25};   /** @brief SET1xDE. */
  static const field32_t HRTIM_TIMA_TIMADIER5_UPDDE    = {.msk = 0x00400000U, .pos = 22};   /** @brief UPDDE. */
  static const field32_t HRTIM_TIMA_TIMADIER5_REPDE    = {.msk = 0x00100000U, .pos = 20};   /** @brief REPDE. */
  static const field32_t HRTIM_TIMA_TIMADIER5_DLYPRTIE = {.msk = 0x00004000U, .pos = 14};   /** @brief DLYPRTIE. */
  static const field32_t HRTIM_TIMA_TIMADIER5_RSTIE    = {.msk = 0x00002000U, .pos = 13};   /** @brief RSTIE. */
  static const field32_t HRTIM_TIMA_TIMADIER5_SETX2IE  = {.msk = 0x00000800U, .pos = 11};   /** @brief SETx2IE. */
  static const field32_t HRTIM_TIMA_TIMADIER5_SET1XIE  = {.msk = 0x00000200U, .pos = 9};    /** @brief SET1xIE. */
  static const field32_t HRTIM_TIMA_TIMADIER5_UPDIE    = {.msk = 0x00000040U, .pos = 6};    /** @brief UPDIE. */
  static const field32_t HRTIM_TIMA_TIMADIER5_REPIE    = {.msk = 0x00000010U, .pos = 4};    /** @brief REPIE. */
  static const field32_t HRTIM_TIMA_CNTAR_CNTX         = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timerx counter value. */
  static const field32_t HRTIM_TIMA_PERAR_PERX         = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timerx period value. */
  static const field32_t HRTIM_TIMA_REPAR_REPX         = {.msk = 0x000000FFU, .pos = 0};    /** @brief Timerx repetition counter value. */
  static const field32_t HRTIM_TIMA_CMPxAR_CMP1X       = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timerx compare 1 value. */
  static const field32_t HRTIM_TIMA_CMP1CAR_REPX       = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Timerx repetition value (aliased from hrtim_repx register). */
  static const field32_t HRTIM_TIMA_CMP1CAR_CMP1X      = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timerx compare 1 value. */
  static const field32_t HRTIM_TIMA_CPTxAR_CPT1X       = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timerx capture 1 value. */
  static const field32_t HRTIM_TIMA_DTAR_DTFLKX        = {.msk = 0x80000000U, .pos = 31};   /** @brief Deadtime falling lock. */
  static const field32_t HRTIM_TIMA_DTAR_DTFSLKX       = {.msk = 0x40000000U, .pos = 30};   /** @brief Deadtime falling sign lock. */
  static const field32_t HRTIM_TIMA_DTAR_SDTFX         = {.msk = 0x02000000U, .pos = 25};   /** @brief Sign deadtime falling value. */
  static const field32_t HRTIM_TIMA_DTAR_DTFX          = {.msk = 0x01FF0000U, .pos = 16};   /** @brief Deadtime falling value. */
  static const field32_t HRTIM_TIMA_DTAR_DTRLKX        = {.msk = 0x00008000U, .pos = 15};   /** @brief Deadtime rising lock. */
  static const field32_t HRTIM_TIMA_DTAR_DTRSLKX       = {.msk = 0x00004000U, .pos = 14};   /** @brief Deadtime rising sign lock. */
  static const field32_t HRTIM_TIMA_DTAR_DTPRSC        = {.msk = 0x00001C00U, .pos = 10};   /** @brief Deadtime prescaler. */
  static const field32_t HRTIM_TIMA_DTAR_SDTRX         = {.msk = 0x00000200U, .pos = 9};    /** @brief Sign deadtime rising value. */
  static const field32_t HRTIM_TIMA_DTAR_DTRX          = {.msk = 0x000001FFU, .pos = 0};    /** @brief Deadtime rising value. */
  static const field32_t HRTIM_TIMA_SETAxR_UPDATE      = {.msk = 0x80000000U, .pos = 31};   /** @brief Registers update (transfer preload to active). */
  static const field32_t HRTIM_TIMA_SETAxR_MSTPER      = {.msk = 0x00000080U, .pos = 7};    /** @brief Master period. */
  static const field32_t HRTIM_TIMA_SETAxR_PER         = {.msk = 0x00000004U, .pos = 2};    /** @brief Timer A period. */
  static const field32_t HRTIM_TIMA_SETAxR_RESYNC      = {.msk = 0x00000002U, .pos = 1};    /** @brief Timer A resynchronizaton. */
  static const field32_t HRTIM_TIMA_SETAxR_SST         = {.msk = 0x00000001U, .pos = 0};    /** @brief Software set trigger. */
  static const field32_t HRTIM_TIMA_RSTAxR_UPDATE      = {.msk = 0x80000000U, .pos = 31};   /** @brief UPDATE. */
  static const field32_t HRTIM_TIMA_RSTAxR_MSTPER      = {.msk = 0x00000080U, .pos = 7};    /** @brief MSTPER. */
  static const field32_t HRTIM_TIMA_RSTAxR_PER         = {.msk = 0x00000004U, .pos = 2};    /** @brief PER. */
  static const field32_t HRTIM_TIMA_RSTAxR_RESYNC      = {.msk = 0x00000002U, .pos = 1};    /** @brief RESYNC. */
  static const field32_t HRTIM_TIMA_RSTAxR_SRT         = {.msk = 0x00000001U, .pos = 0};    /** @brief SRT. */
  static const field32_t HRTIM_TIMA_RSTAR_MSTPER       = {.msk = 0x00000010U, .pos = 4};    /** @brief Master timer period. */
  static const field32_t HRTIM_TIMA_RSTAR_UPDT         = {.msk = 0x00000002U, .pos = 1};    /** @brief Timer A update reset. */
  static const field32_t HRTIM_TIMA_CHPAR_STRTPW       = {.msk = 0x00000780U, .pos = 7};    /** @brief STRTPW. */
  static const field32_t HRTIM_TIMA_CHPAR_CHPDTY       = {.msk = 0x00000070U, .pos = 4};    /** @brief Timerx chopper duty cycle value. */
  static const field32_t HRTIM_TIMA_CHPAR_CHPFRQ       = {.msk = 0x0000000FU, .pos = 0};    /** @brief Timerx carrier frequency value. */
  static const field32_t HRTIM_TIMA_CPTxACR_TE1RST     = {.msk = 0x20000000U, .pos = 29};   /** @brief Timer E output 1 reset. */
  static const field32_t HRTIM_TIMA_CPTxACR_TE1SET     = {.msk = 0x10000000U, .pos = 28};   /** @brief Timer E output 1 set. */
  static const field32_t HRTIM_TIMA_CPTxACR_TD1RST     = {.msk = 0x02000000U, .pos = 25};   /** @brief Timer D output 1 reset. */
  static const field32_t HRTIM_TIMA_CPTxACR_TD1SET     = {.msk = 0x01000000U, .pos = 24};   /** @brief Timer D output 1 set. */
  static const field32_t HRTIM_TIMA_CPTxACR_TC1RST     = {.msk = 0x00200000U, .pos = 21};   /** @brief Timer C output 1 reset. */
  static const field32_t HRTIM_TIMA_CPTxACR_TC1SET     = {.msk = 0x00100000U, .pos = 20};   /** @brief Timer C output 1 set. */
  static const field32_t HRTIM_TIMA_CPTxACR_TB1RST     = {.msk = 0x00020000U, .pos = 17};   /** @brief Timer B output 1 reset. */
  static const field32_t HRTIM_TIMA_CPTxACR_TB1SET     = {.msk = 0x00010000U, .pos = 16};   /** @brief Timer B output 1 set. */
  static const field32_t HRTIM_TIMA_CPTxACR_UDPCPT     = {.msk = 0x00000002U, .pos = 1};    /** @brief Update capture. */
  static const field32_t HRTIM_TIMA_CPTxACR_SWCPT      = {.msk = 0x00000001U, .pos = 0};    /** @brief Software capture. */
  static const field32_t HRTIM_TIMA_OUTAR_DLYPRT       = {.msk = 0x00001C00U, .pos = 10};   /** @brief Delayed protection. */
  static const field32_t HRTIM_TIMA_OUTAR_DLYPRTEN     = {.msk = 0x00000200U, .pos = 9};    /** @brief Delayed protection enable. */
  static const field32_t HRTIM_TIMA_OUTAR_DTEN         = {.msk = 0x00000100U, .pos = 8};    /** @brief Deadtime enable. */
  static const field32_t HRTIM_TIMA_FLTAR_FLTLCK       = {.msk = 0x80000000U, .pos = 31};   /** @brief Fault sources lock. */

  /**** Enumerated HRTIM_TIMA Register Field Definitions ****/

  static field32_t const HRTIM_TIMA_TIMACR_DELCMPx[5] = {
    [2] = {.msk = 0x00003000U, .pos = 12},   /** @brief Delayed CMP2 mode. */
    [4] = {.msk = 0x0000C000U, .pos = 14},   /** @brief Delayed CMP4 mode. */
  };

  static field32_t const HRTIM_TIMA_TIMAISR_OxSTAT[3] = {
    [1] = {.msk = 0x00040000U, .pos = 18},   /** @brief Output 1 state. */
    [2] = {.msk = 0x00080000U, .pos = 19},   /** @brief Output 2 state. */
  };

  static field32_t const HRTIM_TIMA_TIMAISR_RSTXx[3] = {
    [1] = {.msk = 0x00000400U, .pos = 10},   /** @brief Output 1 reset interrupt flag. */
    [2] = {.msk = 0x00001000U, .pos = 12},   /** @brief Output 2 reset interrupt flag. */
  };

  static field32_t const HRTIM_TIMA_TIMAISR_SETXx[3] = {
    [1] = {.msk = 0x00000200U, .pos = 9},    /** @brief Output 1 set interrupt flag. */
    [2] = {.msk = 0x00000800U, .pos = 11},   /** @brief Output 2 set interrupt flag. */
  };

  static field32_t const HRTIM_TIMA_TIMAISR_CPTx[3] = {
    [1] = {.msk = 0x00000080U, .pos = 7},   /** @brief Capture1 interrupt flag. */
    [2] = {.msk = 0x00000100U, .pos = 8},   /** @brief Capture2 interrupt flag. */
  };

  static field32_t const HRTIM_TIMA_TIMAISR_CMPx[5] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief Compare 1 interrupt flag. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief Compare 2 interrupt flag. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief Compare 3 interrupt flag. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief Compare 4 interrupt flag. */
  };

  static field32_t const HRTIM_TIMA_TIMAICR_RSTXxC[3] = {
    [1] = {.msk = 0x00000400U, .pos = 10},   /** @brief Output 1 reset flag clear. */
    [2] = {.msk = 0x00001000U, .pos = 12},   /** @brief Output 2 reset flag clear. */
  };

  static field32_t const HRTIM_TIMA_TIMAICR_SETxXC[3] = {
    [1] = {.msk = 0x00000200U, .pos = 9},    /** @brief Output 1 set flag clear. */
    [2] = {.msk = 0x00000800U, .pos = 11},   /** @brief Output 2 set flag clear. */
  };

  static field32_t const HRTIM_TIMA_TIMAICR_CPTxC[3] = {
    [1] = {.msk = 0x00000080U, .pos = 7},   /** @brief Capture1 interrupt flag clear. */
    [2] = {.msk = 0x00000100U, .pos = 8},   /** @brief Capture2 interrupt flag clear. */
  };

  static field32_t const HRTIM_TIMA_TIMAICR_CMPxC[5] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief Compare 1 interrupt flag clear. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief Compare 2 interrupt flag clear. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief Compare 3 interrupt flag clear. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief Compare 4 interrupt flag clear. */
  };

  static field32_t const HRTIM_TIMA_TIMADIER5_RSTXxDE[3] = {
    [1] = {.msk = 0x04000000U, .pos = 26},   /** @brief RSTx1DE. */
    [2] = {.msk = 0x10000000U, .pos = 28},   /** @brief RSTx2DE. */
  };

  static field32_t const HRTIM_TIMA_TIMADIER5_CPTxDE[3] = {
    [1] = {.msk = 0x00800000U, .pos = 23},   /** @brief CPT1DE. */
    [2] = {.msk = 0x01000000U, .pos = 24},   /** @brief CPT2DE. */
  };

  static field32_t const HRTIM_TIMA_TIMADIER5_CMPxDE[5] = {
    [1] = {.msk = 0x00010000U, .pos = 16},   /** @brief CMP1DE. */
    [2] = {.msk = 0x00020000U, .pos = 17},   /** @brief CMP2DE. */
    [3] = {.msk = 0x00040000U, .pos = 18},   /** @brief CMP3DE. */
    [4] = {.msk = 0x00080000U, .pos = 19},   /** @brief CMP4DE. */
  };

  static field32_t const HRTIM_TIMA_TIMADIER5_RSTXxIE[3] = {
    [1] = {.msk = 0x00000400U, .pos = 10},   /** @brief RSTx1IE. */
    [2] = {.msk = 0x00001000U, .pos = 12},   /** @brief RSTx2IE. */
  };

  static field32_t const HRTIM_TIMA_TIMADIER5_CPTxIE[3] = {
    [1] = {.msk = 0x00000080U, .pos = 7},   /** @brief CPT1IE. */
    [2] = {.msk = 0x00000100U, .pos = 8},   /** @brief CPT2IE. */
  };

  static field32_t const HRTIM_TIMA_TIMADIER5_CMPxIE[5] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief CMP1IE. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief CMP2IE. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief CMP3IE. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief CMP4IE. */
  };

  static field32_t const HRTIM_TIMA_SETAxR_EXTEVNTx[11] = {
    [1]  = {.msk = 0x00200000U, .pos = 21},   /** @brief External event 1. */
    [2]  = {.msk = 0x00400000U, .pos = 22},   /** @brief External event 2. */
    [3]  = {.msk = 0x00800000U, .pos = 23},   /** @brief External event 3. */
    [4]  = {.msk = 0x01000000U, .pos = 24},   /** @brief External event 4. */
    [5]  = {.msk = 0x02000000U, .pos = 25},   /** @brief External event 5. */
    [6]  = {.msk = 0x04000000U, .pos = 26},   /** @brief External event 6. */
    [7]  = {.msk = 0x08000000U, .pos = 27},   /** @brief External event 7. */
    [8]  = {.msk = 0x10000000U, .pos = 28},   /** @brief External event 8. */
    [9]  = {.msk = 0x20000000U, .pos = 29},   /** @brief External event 9. */
    [10] = {.msk = 0x40000000U, .pos = 30},   /** @brief External event 10. */
  };

  static field32_t const HRTIM_TIMA_SETAxR_TIMEVNTx[10] = {
    [1]  = {.msk = 0x00001000U, .pos = 12},   /** @brief Timer event 1. */
    [2]  = {.msk = 0x00002000U, .pos = 13},   /** @brief Timer event 2. */
    [3]  = {.msk = 0x00004000U, .pos = 14},   /** @brief Timer event 3. */
    [4]  = {.msk = 0x00008000U, .pos = 15},   /** @brief Timer event 4. */
    [5]  = {.msk = 0x00010000U, .pos = 16},   /** @brief Timer event 5. */
    [6]  = {.msk = 0x00020000U, .pos = 17},   /** @brief Timer event 6. */
    [7]  = {.msk = 0x00040000U, .pos = 18},   /** @brief Timer event 7. */
    [8]  = {.msk = 0x00080000U, .pos = 19},   /** @brief Timer event 8. */
    [9]  = {.msk = 0x00100000U, .pos = 20},   /** @brief Timer event 9. */
  };

  static field32_t const HRTIM_TIMA_SETAxR_MSTCMPx[5] = {
    [1] = {.msk = 0x00000100U, .pos = 8},    /** @brief Master compare 1. */
    [2] = {.msk = 0x00000200U, .pos = 9},    /** @brief Master compare 2. */
    [3] = {.msk = 0x00000400U, .pos = 10},   /** @brief Master compare 3. */
    [4] = {.msk = 0x00000800U, .pos = 11},   /** @brief Master compare 4. */
  };

  static field32_t const HRTIM_TIMA_EEFARx_EExFLTR[6] = {
    [1] = {.msk = 0x0000001EU, .pos = 1},    /** @brief External event 1 filter. */
    [2] = {.msk = 0x00000780U, .pos = 7},    /** @brief External event 2 filter. */
    [3] = {.msk = 0x0001E000U, .pos = 13},   /** @brief External event 3 filter. */
    [4] = {.msk = 0x00780000U, .pos = 19},   /** @brief External event 4 filter. */
    [5] = {.msk = 0x1E000000U, .pos = 25},   /** @brief External event 5 filter. */
  };

  static field32_t const HRTIM_TIMA_EEFARx_EExLTCH[6] = {
    [1] = {.msk = 0x00000001U, .pos = 0},    /** @brief External event 1 latch. */
    [2] = {.msk = 0x00000040U, .pos = 6},    /** @brief External event 2 latch. */
    [3] = {.msk = 0x00001000U, .pos = 12},   /** @brief External event 3 latch. */
    [4] = {.msk = 0x00040000U, .pos = 18},   /** @brief External event 4 latch. */
    [5] = {.msk = 0x01000000U, .pos = 24},   /** @brief External event 5 latch. */
  };

  static field32_t const HRTIM_TIMA_RSTAR_TIMECMPx[5] = {
    [1] = {.msk = 0x10000000U, .pos = 28},   /** @brief Timer E compare 1. */
    [2] = {.msk = 0x20000000U, .pos = 29},   /** @brief Timer E compare 2. */
    [4] = {.msk = 0x40000000U, .pos = 30},   /** @brief Timer E compare 4. */
  };

  static field32_t const HRTIM_TIMA_RSTAR_TIMDCMPx[5] = {
    [1] = {.msk = 0x02000000U, .pos = 25},   /** @brief Timer D compare 1. */
    [2] = {.msk = 0x04000000U, .pos = 26},   /** @brief Timer D compare 2. */
    [4] = {.msk = 0x08000000U, .pos = 27},   /** @brief Timer D compare 4. */
  };

  static field32_t const HRTIM_TIMA_RSTAR_TIMCCMPx[5] = {
    [1] = {.msk = 0x00400000U, .pos = 22},   /** @brief Timer C compare 1. */
    [2] = {.msk = 0x00800000U, .pos = 23},   /** @brief Timer C compare 2. */
    [4] = {.msk = 0x01000000U, .pos = 24},   /** @brief Timer C compare 4. */
  };

  static field32_t const HRTIM_TIMA_RSTAR_TIMBCMPx[5] = {
    [1] = {.msk = 0x00080000U, .pos = 19},   /** @brief Timer B compare 1. */
    [2] = {.msk = 0x00100000U, .pos = 20},   /** @brief Timer B compare 2. */
    [4] = {.msk = 0x00200000U, .pos = 21},   /** @brief Timer B compare 4. */
  };

  static field32_t const HRTIM_TIMA_CPTxACR_TECMPx[3] = {
    [1] = {.msk = 0x40000000U, .pos = 30},   /** @brief Timer E compare 1. */
    [2] = {.msk = 0x80000000U, .pos = 31},   /** @brief Timer E compare 2. */
  };

  static field32_t const HRTIM_TIMA_CPTxACR_TDCMPx[3] = {
    [1] = {.msk = 0x04000000U, .pos = 26},   /** @brief Timer D compare 1. */
    [2] = {.msk = 0x08000000U, .pos = 27},   /** @brief Timer D compare 2. */
  };

  static field32_t const HRTIM_TIMA_CPTxACR_TCCMPx[3] = {
    [1] = {.msk = 0x00400000U, .pos = 22},   /** @brief Timer C compare 1. */
    [2] = {.msk = 0x00800000U, .pos = 23},   /** @brief Timer C compare 2. */
  };

  static field32_t const HRTIM_TIMA_CPTxACR_TBCMPx[3] = {
    [1] = {.msk = 0x00040000U, .pos = 18},   /** @brief Timer B compare 1. */
    [2] = {.msk = 0x00080000U, .pos = 19},   /** @brief Timer B compare 2. */
  };

  static field32_t const HRTIM_TIMA_CPTxACR_EXEVxCPT[11] = {
    [1]  = {.msk = 0x00000004U, .pos = 2},    /** @brief External event 1 capture. */
    [2]  = {.msk = 0x00000008U, .pos = 3},    /** @brief External event 2 capture. */
    [3]  = {.msk = 0x00000010U, .pos = 4},    /** @brief External event 3 capture. */
    [4]  = {.msk = 0x00000020U, .pos = 5},    /** @brief External event 4 capture. */
    [5]  = {.msk = 0x00000040U, .pos = 6},    /** @brief External event 5 capture. */
    [6]  = {.msk = 0x00000080U, .pos = 7},    /** @brief External event 6 capture. */
    [7]  = {.msk = 0x00000100U, .pos = 8},    /** @brief External event 7 capture. */
    [8]  = {.msk = 0x00000200U, .pos = 9},    /** @brief External event 8 capture. */
    [9]  = {.msk = 0x00000400U, .pos = 10},   /** @brief External event 9 capture. */
    [10] = {.msk = 0x00000800U, .pos = 11},   /** @brief External event 10 capture. */
  };

  static field32_t const HRTIM_TIMA_OUTAR_DIDLx[3] = {
    [1] = {.msk = 0x00000080U, .pos = 7},    /** @brief Output 1 deadtime upon burst mode idle entry. */
    [2] = {.msk = 0x00800000U, .pos = 23},   /** @brief Output 2 deadtime upon burst mode idle entry. */
  };

  static field32_t const HRTIM_TIMA_OUTAR_CHPx[3] = {
    [1] = {.msk = 0x00000040U, .pos = 6},    /** @brief Output 1 chopper enable. */
    [2] = {.msk = 0x00400000U, .pos = 22},   /** @brief Output 2 chopper enable. */
  };

  static field32_t const HRTIM_TIMA_OUTAR_FAULTx[3] = {
    [1] = {.msk = 0x00000030U, .pos = 4},    /** @brief Output 1 fault state. */
    [2] = {.msk = 0x00300000U, .pos = 20},   /** @brief Output 2 fault state. */
  };

  static field32_t const HRTIM_TIMA_OUTAR_IDLESx[3] = {
    [1] = {.msk = 0x00000008U, .pos = 3},    /** @brief Output 1 idle state. */
    [2] = {.msk = 0x00080000U, .pos = 19},   /** @brief Output 2 idle state. */
  };

  static field32_t const HRTIM_TIMA_OUTAR_IDLEMx[3] = {
    [1] = {.msk = 0x00000004U, .pos = 2},    /** @brief Output 1 idle mode. */
    [2] = {.msk = 0x00040000U, .pos = 18},   /** @brief Output 2 idle mode. */
  };

  static field32_t const HRTIM_TIMA_OUTAR_POLx[3] = {
    [1] = {.msk = 0x00000002U, .pos = 1},    /** @brief Output 1 polarity. */
    [2] = {.msk = 0x00020000U, .pos = 17},   /** @brief Output 2 polarity. */
  };

  static field32_t const HRTIM_TIMA_FLTAR_FLTxEN[6] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief Fault 1 enable. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief Fault 2 enable. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief Fault 3 enable. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief Fault 4 enable. */
    [5] = {.msk = 0x00000010U, .pos = 4},   /** @brief Fault 5 enable. */
  };

  /************************************************************************************************
   * HRTIM_TIMB Definitions
   ************************************************************************************************/

  /**** HRTIM_TIMB Register Definitions ****/

  static const rw_reg32_t HRTIM_TIMB_TIMBCR    = (rw_reg32_t)0x40017500U;   /** @brief Timerx control register. */
  static const ro_reg32_t HRTIM_TIMB_TIMBISR   = (ro_reg32_t)0x40017504U;   /** @brief Timerx interrupt status register. */
  static const rw_reg32_t HRTIM_TIMB_TIMBICR   = (rw_reg32_t)0x40017508U;   /** @brief Timerx interrupt clear register. */
  static const rw_reg32_t HRTIM_TIMB_TIMBDIER5 = (rw_reg32_t)0x4001750CU;   /** @brief TIMxDIER5. */
  static const rw_reg32_t HRTIM_TIMB_CNTR      = (rw_reg32_t)0x40017510U;   /** @brief Timerx counter register. */
  static const rw_reg32_t HRTIM_TIMB_PERBR     = (rw_reg32_t)0x40017514U;   /** @brief Timerx period register. */
  static const rw_reg32_t HRTIM_TIMB_REPBR     = (rw_reg32_t)0x40017518U;   /** @brief Timerx repetition register. */
  static const rw_reg32_t HRTIM_TIMB_CMP1CBR   = (rw_reg32_t)0x40017520U;   /** @brief Timerx compare 1 compound register. */
  static const rw_reg32_t HRTIM_TIMB_DTBR      = (rw_reg32_t)0x40017538U;   /** @brief Timerx deadtime register. */
  static const rw_reg32_t HRTIM_TIMB_RSTBR     = (rw_reg32_t)0x40017554U;   /** @brief TimerA reset register. */
  static const rw_reg32_t HRTIM_TIMB_CHPBR     = (rw_reg32_t)0x40017558U;   /** @brief Timerx chopper register. */
  static const rw_reg32_t HRTIM_TIMB_OUTBR     = (rw_reg32_t)0x40017564U;   /** @brief Timerx output register. */
  static const rw_reg32_t HRTIM_TIMB_FLTBR     = (rw_reg32_t)0x40017568U;   /** @brief Timerx fault register. */

  /**** Enumerated HRTIM_TIMB Register Definitions ****/

  static const rw_reg32_t HRTIM_TIMB_CMPxBR[5] = {
    [1] = (rw_reg32_t)0x4001751CU,   /** @brief Timerx compare 1 register. */
    [2] = (rw_reg32_t)0x40017524U,   /** @brief Timerx compare 2 register. */
    [3] = (rw_reg32_t)0x40017528U,   /** @brief Timerx compare 3 register. */
    [4] = (rw_reg32_t)0x4001752CU,   /** @brief Timerx compare 4 register. */
  };

  static const ro_reg32_t HRTIM_TIMB_CPTxBR[3] = {
    [1] = (ro_reg32_t)0x40017530U,   /** @brief Timerx capture 1 register. */
    [2] = (ro_reg32_t)0x40017534U,   /** @brief Timerx capture 2 register. */
  };

  static const rw_reg32_t HRTIM_TIMB_SETBxR[3] = {
    [1] = (rw_reg32_t)0x4001753CU,   /** @brief Timerx output1 set register. */
    [2] = (rw_reg32_t)0x40017544U,   /** @brief Timerx output2 set register. */
  };

  static const rw_reg32_t HRTIM_TIMB_RSTBxR[3] = {
    [1] = (rw_reg32_t)0x40017540U,   /** @brief Timerx output1 reset register. */
    [2] = (rw_reg32_t)0x40017548U,   /** @brief Timerx output2 reset register. */
  };

  static const rw_reg32_t HRTIM_TIMB_EEFBRx[3] = {
    [1] = (rw_reg32_t)0x4001754CU,   /** @brief Timerx external event filtering register 1. */
    [2] = (rw_reg32_t)0x40017550U,   /** @brief Timerx external event filtering register 2. */
  };

  static const rw_reg32_t HRTIM_TIMB_CPTxBCR[3] = {
    [1] = (rw_reg32_t)0x4001755CU,   /** @brief Timerx capture 2 control register. */
    [2] = (rw_reg32_t)0x40017560U,   /** @brief CPT2xCR. */
  };

  /**** HRTIM_TIMB Register Field Definitions ****/

  static const field32_t HRTIM_TIMB_TIMBCR_UPDGAT      = {.msk = 0xF0000000U, .pos = 28};   /** @brief Update gating. */
  static const field32_t HRTIM_TIMB_TIMBCR_PREEN       = {.msk = 0x08000000U, .pos = 27};   /** @brief Preload enable. */
  static const field32_t HRTIM_TIMB_TIMBCR_DACSYNC     = {.msk = 0x06000000U, .pos = 25};   /** @brief AC synchronization. */
  static const field32_t HRTIM_TIMB_TIMBCR_MSTU        = {.msk = 0x01000000U, .pos = 24};   /** @brief Master timer update. */
  static const field32_t HRTIM_TIMB_TIMBCR_TEU         = {.msk = 0x00800000U, .pos = 23};   /** @brief TEU. */
  static const field32_t HRTIM_TIMB_TIMBCR_TDU         = {.msk = 0x00400000U, .pos = 22};   /** @brief TDU. */
  static const field32_t HRTIM_TIMB_TIMBCR_TCU         = {.msk = 0x00200000U, .pos = 21};   /** @brief TCU. */
  static const field32_t HRTIM_TIMB_TIMBCR_TBU         = {.msk = 0x00100000U, .pos = 20};   /** @brief TBU. */
  static const field32_t HRTIM_TIMB_TIMBCR_TXRSTU      = {.msk = 0x00040000U, .pos = 18};   /** @brief Timerx reset update. */
  static const field32_t HRTIM_TIMB_TIMBCR_TXREPU      = {.msk = 0x00020000U, .pos = 17};   /** @brief Timer x repetition update. */
  static const field32_t HRTIM_TIMB_TIMBCR_SYNCSTRTX   = {.msk = 0x00000800U, .pos = 11};   /** @brief Synchronization starts timer x. */
  static const field32_t HRTIM_TIMB_TIMBCR_SYNCRSTX    = {.msk = 0x00000400U, .pos = 10};   /** @brief Synchronization resets timer x. */
  static const field32_t HRTIM_TIMB_TIMBCR_PSHPLL      = {.msk = 0x00000040U, .pos = 6};    /** @brief Push-Pull mode enable. */
  static const field32_t HRTIM_TIMB_TIMBCR_HALF        = {.msk = 0x00000020U, .pos = 5};    /** @brief Half mode enable. */
  static const field32_t HRTIM_TIMB_TIMBCR_RETRIG      = {.msk = 0x00000010U, .pos = 4};    /** @brief Re-triggerable mode. */
  static const field32_t HRTIM_TIMB_TIMBCR_CONT        = {.msk = 0x00000008U, .pos = 3};    /** @brief Continuous mode. */
  static const field32_t HRTIM_TIMB_TIMBCR_CK_PSCX     = {.msk = 0x00000007U, .pos = 0};    /** @brief HRTIM timer x clock prescaler. */
  static const field32_t HRTIM_TIMB_TIMBISR_IPPSTAT    = {.msk = 0x00020000U, .pos = 17};   /** @brief Idle push pull status. */
  static const field32_t HRTIM_TIMB_TIMBISR_CPPSTAT    = {.msk = 0x00010000U, .pos = 16};   /** @brief Current push pull status. */
  static const field32_t HRTIM_TIMB_TIMBISR_DLYPRT     = {.msk = 0x00004000U, .pos = 14};   /** @brief Delayed protection flag. */
  static const field32_t HRTIM_TIMB_TIMBISR_RST        = {.msk = 0x00002000U, .pos = 13};   /** @brief Reset interrupt flag. */
  static const field32_t HRTIM_TIMB_TIMBISR_UPD        = {.msk = 0x00000040U, .pos = 6};    /** @brief Update interrupt flag. */
  static const field32_t HRTIM_TIMB_TIMBISR_REP        = {.msk = 0x00000010U, .pos = 4};    /** @brief Repetition interrupt flag. */
  static const field32_t HRTIM_TIMB_TIMBICR_DLYPRTC    = {.msk = 0x00004000U, .pos = 14};   /** @brief Delayed protection flag clear. */
  static const field32_t HRTIM_TIMB_TIMBICR_RSTC       = {.msk = 0x00002000U, .pos = 13};   /** @brief Reset interrupt flag clear. */
  static const field32_t HRTIM_TIMB_TIMBICR_UPDC       = {.msk = 0x00000040U, .pos = 6};    /** @brief Update interrupt flag clear. */
  static const field32_t HRTIM_TIMB_TIMBICR_REPC       = {.msk = 0x00000010U, .pos = 4};    /** @brief Repetition interrupt flag clear. */
  static const field32_t HRTIM_TIMB_TIMBDIER5_DLYPRTDE = {.msk = 0x40000000U, .pos = 30};   /** @brief DLYPRTDE. */
  static const field32_t HRTIM_TIMB_TIMBDIER5_RSTDE    = {.msk = 0x20000000U, .pos = 29};   /** @brief RSTDE. */
  static const field32_t HRTIM_TIMB_TIMBDIER5_SETX2DE  = {.msk = 0x08000000U, .pos = 27};   /** @brief SETx2DE. */
  static const field32_t HRTIM_TIMB_TIMBDIER5_SET1XDE  = {.msk = 0x02000000U, .pos = 25};   /** @brief SET1xDE. */
  static const field32_t HRTIM_TIMB_TIMBDIER5_UPDDE    = {.msk = 0x00400000U, .pos = 22};   /** @brief UPDDE. */
  static const field32_t HRTIM_TIMB_TIMBDIER5_REPDE    = {.msk = 0x00100000U, .pos = 20};   /** @brief REPDE. */
  static const field32_t HRTIM_TIMB_TIMBDIER5_DLYPRTIE = {.msk = 0x00004000U, .pos = 14};   /** @brief DLYPRTIE. */
  static const field32_t HRTIM_TIMB_TIMBDIER5_RSTIE    = {.msk = 0x00002000U, .pos = 13};   /** @brief RSTIE. */
  static const field32_t HRTIM_TIMB_TIMBDIER5_SETX2IE  = {.msk = 0x00000800U, .pos = 11};   /** @brief SETx2IE. */
  static const field32_t HRTIM_TIMB_TIMBDIER5_SET1XIE  = {.msk = 0x00000200U, .pos = 9};    /** @brief SET1xIE. */
  static const field32_t HRTIM_TIMB_TIMBDIER5_UPDIE    = {.msk = 0x00000040U, .pos = 6};    /** @brief UPDIE. */
  static const field32_t HRTIM_TIMB_TIMBDIER5_REPIE    = {.msk = 0x00000010U, .pos = 4};    /** @brief REPIE. */
  static const field32_t HRTIM_TIMB_CNTR_CNTX          = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timerx counter value. */
  static const field32_t HRTIM_TIMB_PERBR_PERX         = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timerx period value. */
  static const field32_t HRTIM_TIMB_REPBR_REPX         = {.msk = 0x000000FFU, .pos = 0};    /** @brief Timerx repetition counter value. */
  static const field32_t HRTIM_TIMB_CMPxBR_CMP1X       = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timerx compare 1 value. */
  static const field32_t HRTIM_TIMB_CMP1CBR_REPX       = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Timerx repetition value (aliased from hrtim_repx register). */
  static const field32_t HRTIM_TIMB_CMP1CBR_CMP1X      = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timerx compare 1 value. */
  static const field32_t HRTIM_TIMB_CPTxBR_CPT1X       = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timerx capture 1 value. */
  static const field32_t HRTIM_TIMB_DTBR_DTFLKX        = {.msk = 0x80000000U, .pos = 31};   /** @brief Deadtime falling lock. */
  static const field32_t HRTIM_TIMB_DTBR_DTFSLKX       = {.msk = 0x40000000U, .pos = 30};   /** @brief Deadtime falling sign lock. */
  static const field32_t HRTIM_TIMB_DTBR_SDTFX         = {.msk = 0x02000000U, .pos = 25};   /** @brief Sign deadtime falling value. */
  static const field32_t HRTIM_TIMB_DTBR_DTFX          = {.msk = 0x01FF0000U, .pos = 16};   /** @brief Deadtime falling value. */
  static const field32_t HRTIM_TIMB_DTBR_DTRLKX        = {.msk = 0x00008000U, .pos = 15};   /** @brief Deadtime rising lock. */
  static const field32_t HRTIM_TIMB_DTBR_DTRSLKX       = {.msk = 0x00004000U, .pos = 14};   /** @brief Deadtime rising sign lock. */
  static const field32_t HRTIM_TIMB_DTBR_DTPRSC        = {.msk = 0x00001C00U, .pos = 10};   /** @brief Deadtime prescaler. */
  static const field32_t HRTIM_TIMB_DTBR_SDTRX         = {.msk = 0x00000200U, .pos = 9};    /** @brief Sign deadtime rising value. */
  static const field32_t HRTIM_TIMB_DTBR_DTRX          = {.msk = 0x000001FFU, .pos = 0};    /** @brief Deadtime rising value. */
  static const field32_t HRTIM_TIMB_SETBxR_UPDATE      = {.msk = 0x80000000U, .pos = 31};   /** @brief Registers update (transfer preload to active). */
  static const field32_t HRTIM_TIMB_SETBxR_MSTPER      = {.msk = 0x00000080U, .pos = 7};    /** @brief Master period. */
  static const field32_t HRTIM_TIMB_SETBxR_PER         = {.msk = 0x00000004U, .pos = 2};    /** @brief Timer A period. */
  static const field32_t HRTIM_TIMB_SETBxR_RESYNC      = {.msk = 0x00000002U, .pos = 1};    /** @brief Timer A resynchronizaton. */
  static const field32_t HRTIM_TIMB_SETBxR_SST         = {.msk = 0x00000001U, .pos = 0};    /** @brief Software set trigger. */
  static const field32_t HRTIM_TIMB_RSTBxR_UPDATE      = {.msk = 0x80000000U, .pos = 31};   /** @brief UPDATE. */
  static const field32_t HRTIM_TIMB_RSTBxR_MSTPER      = {.msk = 0x00000080U, .pos = 7};    /** @brief MSTPER. */
  static const field32_t HRTIM_TIMB_RSTBxR_PER         = {.msk = 0x00000004U, .pos = 2};    /** @brief PER. */
  static const field32_t HRTIM_TIMB_RSTBxR_RESYNC      = {.msk = 0x00000002U, .pos = 1};    /** @brief RESYNC. */
  static const field32_t HRTIM_TIMB_RSTBxR_SRT         = {.msk = 0x00000001U, .pos = 0};    /** @brief SRT. */
  static const field32_t HRTIM_TIMB_RSTBR_MSTPER       = {.msk = 0x00000010U, .pos = 4};    /** @brief Master timer period. */
  static const field32_t HRTIM_TIMB_RSTBR_UPDT         = {.msk = 0x00000002U, .pos = 1};    /** @brief Timer A update reset. */
  static const field32_t HRTIM_TIMB_CHPBR_STRTPW       = {.msk = 0x00000780U, .pos = 7};    /** @brief STRTPW. */
  static const field32_t HRTIM_TIMB_CHPBR_CHPDTY       = {.msk = 0x00000070U, .pos = 4};    /** @brief Timerx chopper duty cycle value. */
  static const field32_t HRTIM_TIMB_CHPBR_CHPFRQ       = {.msk = 0x0000000FU, .pos = 0};    /** @brief Timerx carrier frequency value. */
  static const field32_t HRTIM_TIMB_CPTxBCR_TE1RST     = {.msk = 0x20000000U, .pos = 29};   /** @brief Timer E output 1 reset. */
  static const field32_t HRTIM_TIMB_CPTxBCR_TE1SET     = {.msk = 0x10000000U, .pos = 28};   /** @brief Timer E output 1 set. */
  static const field32_t HRTIM_TIMB_CPTxBCR_TD1RST     = {.msk = 0x02000000U, .pos = 25};   /** @brief Timer D output 1 reset. */
  static const field32_t HRTIM_TIMB_CPTxBCR_TD1SET     = {.msk = 0x01000000U, .pos = 24};   /** @brief Timer D output 1 set. */
  static const field32_t HRTIM_TIMB_CPTxBCR_TC1RST     = {.msk = 0x00200000U, .pos = 21};   /** @brief Timer C output 1 reset. */
  static const field32_t HRTIM_TIMB_CPTxBCR_TC1SET     = {.msk = 0x00100000U, .pos = 20};   /** @brief Timer C output 1 set. */
  static const field32_t HRTIM_TIMB_CPTxBCR_TA1RST     = {.msk = 0x00002000U, .pos = 13};   /** @brief Timer A output 1 reset. */
  static const field32_t HRTIM_TIMB_CPTxBCR_TA1SET     = {.msk = 0x00001000U, .pos = 12};   /** @brief Timer A output 1 set. */
  static const field32_t HRTIM_TIMB_CPTxBCR_UDPCPT     = {.msk = 0x00000002U, .pos = 1};    /** @brief Update capture. */
  static const field32_t HRTIM_TIMB_CPTxBCR_SWCPT      = {.msk = 0x00000001U, .pos = 0};    /** @brief Software capture. */
  static const field32_t HRTIM_TIMB_OUTBR_DLYPRT       = {.msk = 0x00001C00U, .pos = 10};   /** @brief Delayed protection. */
  static const field32_t HRTIM_TIMB_OUTBR_DLYPRTEN     = {.msk = 0x00000200U, .pos = 9};    /** @brief Delayed protection enable. */
  static const field32_t HRTIM_TIMB_OUTBR_DTEN         = {.msk = 0x00000100U, .pos = 8};    /** @brief Deadtime enable. */
  static const field32_t HRTIM_TIMB_FLTBR_FLTLCK       = {.msk = 0x80000000U, .pos = 31};   /** @brief Fault sources lock. */

  /**** Enumerated HRTIM_TIMB Register Field Definitions ****/

  static field32_t const HRTIM_TIMB_TIMBCR_DELCMPx[5] = {
    [2] = {.msk = 0x00003000U, .pos = 12},   /** @brief Delayed CMP2 mode. */
    [4] = {.msk = 0x0000C000U, .pos = 14},   /** @brief Delayed CMP4 mode. */
  };

  static field32_t const HRTIM_TIMB_TIMBISR_OxSTAT[3] = {
    [1] = {.msk = 0x00040000U, .pos = 18},   /** @brief Output 1 state. */
    [2] = {.msk = 0x00080000U, .pos = 19},   /** @brief Output 2 state. */
  };

  static field32_t const HRTIM_TIMB_TIMBISR_RSTXx[3] = {
    [1] = {.msk = 0x00000400U, .pos = 10},   /** @brief Output 1 reset interrupt flag. */
    [2] = {.msk = 0x00001000U, .pos = 12},   /** @brief Output 2 reset interrupt flag. */
  };

  static field32_t const HRTIM_TIMB_TIMBISR_SETXx[3] = {
    [1] = {.msk = 0x00000200U, .pos = 9},    /** @brief Output 1 set interrupt flag. */
    [2] = {.msk = 0x00000800U, .pos = 11},   /** @brief Output 2 set interrupt flag. */
  };

  static field32_t const HRTIM_TIMB_TIMBISR_CPTx[3] = {
    [1] = {.msk = 0x00000080U, .pos = 7},   /** @brief Capture1 interrupt flag. */
    [2] = {.msk = 0x00000100U, .pos = 8},   /** @brief Capture2 interrupt flag. */
  };

  static field32_t const HRTIM_TIMB_TIMBISR_CMPx[5] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief Compare 1 interrupt flag. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief Compare 2 interrupt flag. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief Compare 3 interrupt flag. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief Compare 4 interrupt flag. */
  };

  static field32_t const HRTIM_TIMB_TIMBICR_RSTXxC[3] = {
    [1] = {.msk = 0x00000400U, .pos = 10},   /** @brief Output 1 reset flag clear. */
    [2] = {.msk = 0x00001000U, .pos = 12},   /** @brief Output 2 reset flag clear. */
  };

  static field32_t const HRTIM_TIMB_TIMBICR_SETxXC[3] = {
    [1] = {.msk = 0x00000200U, .pos = 9},    /** @brief Output 1 set flag clear. */
    [2] = {.msk = 0x00000800U, .pos = 11},   /** @brief Output 2 set flag clear. */
  };

  static field32_t const HRTIM_TIMB_TIMBICR_CPTxC[3] = {
    [1] = {.msk = 0x00000080U, .pos = 7},   /** @brief Capture1 interrupt flag clear. */
    [2] = {.msk = 0x00000100U, .pos = 8},   /** @brief Capture2 interrupt flag clear. */
  };

  static field32_t const HRTIM_TIMB_TIMBICR_CMPxC[5] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief Compare 1 interrupt flag clear. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief Compare 2 interrupt flag clear. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief Compare 3 interrupt flag clear. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief Compare 4 interrupt flag clear. */
  };

  static field32_t const HRTIM_TIMB_TIMBDIER5_RSTXxDE[3] = {
    [1] = {.msk = 0x04000000U, .pos = 26},   /** @brief RSTx1DE. */
    [2] = {.msk = 0x10000000U, .pos = 28},   /** @brief RSTx2DE. */
  };

  static field32_t const HRTIM_TIMB_TIMBDIER5_CPTxDE[3] = {
    [1] = {.msk = 0x00800000U, .pos = 23},   /** @brief CPT1DE. */
    [2] = {.msk = 0x01000000U, .pos = 24},   /** @brief CPT2DE. */
  };

  static field32_t const HRTIM_TIMB_TIMBDIER5_CMPxDE[5] = {
    [1] = {.msk = 0x00010000U, .pos = 16},   /** @brief CMP1DE. */
    [2] = {.msk = 0x00020000U, .pos = 17},   /** @brief CMP2DE. */
    [3] = {.msk = 0x00040000U, .pos = 18},   /** @brief CMP3DE. */
    [4] = {.msk = 0x00080000U, .pos = 19},   /** @brief CMP4DE. */
  };

  static field32_t const HRTIM_TIMB_TIMBDIER5_RSTXxIE[3] = {
    [1] = {.msk = 0x00000400U, .pos = 10},   /** @brief RSTx1IE. */
    [2] = {.msk = 0x00001000U, .pos = 12},   /** @brief RSTx2IE. */
  };

  static field32_t const HRTIM_TIMB_TIMBDIER5_CPTxIE[3] = {
    [1] = {.msk = 0x00000080U, .pos = 7},   /** @brief CPT1IE. */
    [2] = {.msk = 0x00000100U, .pos = 8},   /** @brief CPT2IE. */
  };

  static field32_t const HRTIM_TIMB_TIMBDIER5_CMPxIE[5] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief CMP1IE. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief CMP2IE. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief CMP3IE. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief CMP4IE. */
  };

  static field32_t const HRTIM_TIMB_SETBxR_EXTEVNTx[11] = {
    [1]  = {.msk = 0x00200000U, .pos = 21},   /** @brief External event 1. */
    [2]  = {.msk = 0x00400000U, .pos = 22},   /** @brief External event 2. */
    [3]  = {.msk = 0x00800000U, .pos = 23},   /** @brief External event 3. */
    [4]  = {.msk = 0x01000000U, .pos = 24},   /** @brief External event 4. */
    [5]  = {.msk = 0x02000000U, .pos = 25},   /** @brief External event 5. */
    [6]  = {.msk = 0x04000000U, .pos = 26},   /** @brief External event 6. */
    [7]  = {.msk = 0x08000000U, .pos = 27},   /** @brief External event 7. */
    [8]  = {.msk = 0x10000000U, .pos = 28},   /** @brief External event 8. */
    [9]  = {.msk = 0x20000000U, .pos = 29},   /** @brief External event 9. */
    [10] = {.msk = 0x40000000U, .pos = 30},   /** @brief External event 10. */
  };

  static field32_t const HRTIM_TIMB_SETBxR_TIMEVNTx[10] = {
    [1]  = {.msk = 0x00001000U, .pos = 12},   /** @brief Timer event 1. */
    [2]  = {.msk = 0x00002000U, .pos = 13},   /** @brief Timer event 2. */
    [3]  = {.msk = 0x00004000U, .pos = 14},   /** @brief Timer event 3. */
    [4]  = {.msk = 0x00008000U, .pos = 15},   /** @brief Timer event 4. */
    [5]  = {.msk = 0x00010000U, .pos = 16},   /** @brief Timer event 5. */
    [6]  = {.msk = 0x00020000U, .pos = 17},   /** @brief Timer event 6. */
    [7]  = {.msk = 0x00040000U, .pos = 18},   /** @brief Timer event 7. */
    [8]  = {.msk = 0x00080000U, .pos = 19},   /** @brief Timer event 8. */
    [9]  = {.msk = 0x00100000U, .pos = 20},   /** @brief Timer event 9. */
  };

  static field32_t const HRTIM_TIMB_SETBxR_MSTCMPx[5] = {
    [1] = {.msk = 0x00000100U, .pos = 8},    /** @brief Master compare 1. */
    [2] = {.msk = 0x00000200U, .pos = 9},    /** @brief Master compare 2. */
    [3] = {.msk = 0x00000400U, .pos = 10},   /** @brief Master compare 3. */
    [4] = {.msk = 0x00000800U, .pos = 11},   /** @brief Master compare 4. */
  };

  static field32_t const HRTIM_TIMB_EEFBRx_EExFLTR[6] = {
    [1] = {.msk = 0x0000001EU, .pos = 1},    /** @brief External event 1 filter. */
    [2] = {.msk = 0x00000780U, .pos = 7},    /** @brief External event 2 filter. */
    [3] = {.msk = 0x0001E000U, .pos = 13},   /** @brief External event 3 filter. */
    [4] = {.msk = 0x00780000U, .pos = 19},   /** @brief External event 4 filter. */
    [5] = {.msk = 0x1E000000U, .pos = 25},   /** @brief External event 5 filter. */
  };

  static field32_t const HRTIM_TIMB_EEFBRx_EExLTCH[6] = {
    [1] = {.msk = 0x00000001U, .pos = 0},    /** @brief External event 1 latch. */
    [2] = {.msk = 0x00000040U, .pos = 6},    /** @brief External event 2 latch. */
    [3] = {.msk = 0x00001000U, .pos = 12},   /** @brief External event 3 latch. */
    [4] = {.msk = 0x00040000U, .pos = 18},   /** @brief External event 4 latch. */
    [5] = {.msk = 0x01000000U, .pos = 24},   /** @brief External event 5 latch. */
  };

  static field32_t const HRTIM_TIMB_RSTBR_TIMECMPx[5] = {
    [1] = {.msk = 0x10000000U, .pos = 28},   /** @brief Timer E compare 1. */
    [2] = {.msk = 0x20000000U, .pos = 29},   /** @brief Timer E compare 2. */
    [4] = {.msk = 0x40000000U, .pos = 30},   /** @brief Timer E compare 4. */
  };

  static field32_t const HRTIM_TIMB_RSTBR_TIMDCMPx[5] = {
    [1] = {.msk = 0x02000000U, .pos = 25},   /** @brief Timer D compare 1. */
    [2] = {.msk = 0x04000000U, .pos = 26},   /** @brief Timer D compare 2. */
    [4] = {.msk = 0x08000000U, .pos = 27},   /** @brief Timer D compare 4. */
  };

  static field32_t const HRTIM_TIMB_RSTBR_TIMCCMPx[5] = {
    [1] = {.msk = 0x00400000U, .pos = 22},   /** @brief Timer C compare 1. */
    [2] = {.msk = 0x00800000U, .pos = 23},   /** @brief Timer C compare 2. */
    [4] = {.msk = 0x01000000U, .pos = 24},   /** @brief Timer C compare 4. */
  };

  static field32_t const HRTIM_TIMB_RSTBR_TIMACMPx[5] = {
    [1] = {.msk = 0x00080000U, .pos = 19},   /** @brief Timer A compare 1. */
    [2] = {.msk = 0x00100000U, .pos = 20},   /** @brief Timer A compare 2. */
    [4] = {.msk = 0x00200000U, .pos = 21},   /** @brief Timer A compare 4. */
  };

  static field32_t const HRTIM_TIMB_CPTxBCR_TECMPx[3] = {
    [1] = {.msk = 0x40000000U, .pos = 30},   /** @brief Timer E compare 1. */
    [2] = {.msk = 0x80000000U, .pos = 31},   /** @brief Timer E compare 2. */
  };

  static field32_t const HRTIM_TIMB_CPTxBCR_TDCMPx[3] = {
    [1] = {.msk = 0x04000000U, .pos = 26},   /** @brief Timer D compare 1. */
    [2] = {.msk = 0x08000000U, .pos = 27},   /** @brief Timer D compare 2. */
  };

  static field32_t const HRTIM_TIMB_CPTxBCR_TCCMPx[3] = {
    [1] = {.msk = 0x00400000U, .pos = 22},   /** @brief Timer C compare 1. */
    [2] = {.msk = 0x00800000U, .pos = 23},   /** @brief Timer C compare 2. */
  };

  static field32_t const HRTIM_TIMB_CPTxBCR_TACMPx[3] = {
    [1] = {.msk = 0x00004000U, .pos = 14},   /** @brief Timer A compare 1. */
    [2] = {.msk = 0x00008000U, .pos = 15},   /** @brief Timer A compare 2. */
  };

  static field32_t const HRTIM_TIMB_CPTxBCR_EXEVxCPT[11] = {
    [1]  = {.msk = 0x00000004U, .pos = 2},    /** @brief External event 1 capture. */
    [2]  = {.msk = 0x00000008U, .pos = 3},    /** @brief External event 2 capture. */
    [3]  = {.msk = 0x00000010U, .pos = 4},    /** @brief External event 3 capture. */
    [4]  = {.msk = 0x00000020U, .pos = 5},    /** @brief External event 4 capture. */
    [5]  = {.msk = 0x00000040U, .pos = 6},    /** @brief External event 5 capture. */
    [6]  = {.msk = 0x00000080U, .pos = 7},    /** @brief External event 6 capture. */
    [7]  = {.msk = 0x00000100U, .pos = 8},    /** @brief External event 7 capture. */
    [8]  = {.msk = 0x00000200U, .pos = 9},    /** @brief External event 8 capture. */
    [9]  = {.msk = 0x00000400U, .pos = 10},   /** @brief External event 9 capture. */
    [10] = {.msk = 0x00000800U, .pos = 11},   /** @brief External event 10 capture. */
  };

  static field32_t const HRTIM_TIMB_OUTBR_DIDLx[3] = {
    [1] = {.msk = 0x00000080U, .pos = 7},    /** @brief Output 1 deadtime upon burst mode idle entry. */
    [2] = {.msk = 0x00800000U, .pos = 23},   /** @brief Output 2 deadtime upon burst mode idle entry. */
  };

  static field32_t const HRTIM_TIMB_OUTBR_CHPx[3] = {
    [1] = {.msk = 0x00000040U, .pos = 6},    /** @brief Output 1 chopper enable. */
    [2] = {.msk = 0x00400000U, .pos = 22},   /** @brief Output 2 chopper enable. */
  };

  static field32_t const HRTIM_TIMB_OUTBR_FAULTx[3] = {
    [1] = {.msk = 0x00000030U, .pos = 4},    /** @brief Output 1 fault state. */
    [2] = {.msk = 0x00300000U, .pos = 20},   /** @brief Output 2 fault state. */
  };

  static field32_t const HRTIM_TIMB_OUTBR_IDLESx[3] = {
    [1] = {.msk = 0x00000008U, .pos = 3},    /** @brief Output 1 idle state. */
    [2] = {.msk = 0x00080000U, .pos = 19},   /** @brief Output 2 idle state. */
  };

  static field32_t const HRTIM_TIMB_OUTBR_IDLEMx[3] = {
    [1] = {.msk = 0x00000004U, .pos = 2},    /** @brief Output 1 idle mode. */
    [2] = {.msk = 0x00040000U, .pos = 18},   /** @brief Output 2 idle mode. */
  };

  static field32_t const HRTIM_TIMB_OUTBR_POLx[3] = {
    [1] = {.msk = 0x00000002U, .pos = 1},    /** @brief Output 1 polarity. */
    [2] = {.msk = 0x00020000U, .pos = 17},   /** @brief Output 2 polarity. */
  };

  static field32_t const HRTIM_TIMB_FLTBR_FLTxEN[6] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief Fault 1 enable. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief Fault 2 enable. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief Fault 3 enable. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief Fault 4 enable. */
    [5] = {.msk = 0x00000010U, .pos = 4},   /** @brief Fault 5 enable. */
  };

  /************************************************************************************************
   * HRTIM_TIMC Definitions
   ************************************************************************************************/

  /**** HRTIM_TIMC Register Definitions ****/

  static const rw_reg32_t HRTIM_TIMC_TIMCCR    = (rw_reg32_t)0x40017580U;   /** @brief Timerx control register. */
  static const ro_reg32_t HRTIM_TIMC_TIMCISR   = (ro_reg32_t)0x40017584U;   /** @brief Timerx interrupt status register. */
  static const rw_reg32_t HRTIM_TIMC_TIMCICR   = (rw_reg32_t)0x40017588U;   /** @brief Timerx interrupt clear register. */
  static const rw_reg32_t HRTIM_TIMC_TIMCDIER5 = (rw_reg32_t)0x4001758CU;   /** @brief TIMxDIER5. */
  static const rw_reg32_t HRTIM_TIMC_CNTCR     = (rw_reg32_t)0x40017590U;   /** @brief Timerx counter register. */
  static const rw_reg32_t HRTIM_TIMC_PERCR     = (rw_reg32_t)0x40017594U;   /** @brief Timerx period register. */
  static const rw_reg32_t HRTIM_TIMC_REPCR     = (rw_reg32_t)0x40017598U;   /** @brief Timerx repetition register. */
  static const rw_reg32_t HRTIM_TIMC_CMP1CCR   = (rw_reg32_t)0x400175A0U;   /** @brief Timerx compare 1 compound register. */
  static const rw_reg32_t HRTIM_TIMC_DTCR      = (rw_reg32_t)0x400175B8U;   /** @brief Timerx deadtime register. */
  static const rw_reg32_t HRTIM_TIMC_RSTCR     = (rw_reg32_t)0x400175D4U;   /** @brief TimerA reset register. */
  static const rw_reg32_t HRTIM_TIMC_CHPCR     = (rw_reg32_t)0x400175D8U;   /** @brief Timerx chopper register. */
  static const rw_reg32_t HRTIM_TIMC_OUTCR     = (rw_reg32_t)0x400175E4U;   /** @brief Timerx output register. */
  static const rw_reg32_t HRTIM_TIMC_FLTCR     = (rw_reg32_t)0x400175E8U;   /** @brief Timerx fault register. */

  /**** Enumerated HRTIM_TIMC Register Definitions ****/

  static const rw_reg32_t HRTIM_TIMC_CMPxCR[5] = {
    [1] = (rw_reg32_t)0x4001759CU,   /** @brief Timerx compare 1 register. */
    [2] = (rw_reg32_t)0x400175A4U,   /** @brief Timerx compare 2 register. */
    [3] = (rw_reg32_t)0x400175A8U,   /** @brief Timerx compare 3 register. */
    [4] = (rw_reg32_t)0x400175ACU,   /** @brief Timerx compare 4 register. */
  };

  static const ro_reg32_t HRTIM_TIMC_CPTxCR[3] = {
    [1] = (ro_reg32_t)0x400175B0U,   /** @brief Timerx capture 1 register. */
    [2] = (ro_reg32_t)0x400175B4U,   /** @brief Timerx capture 2 register. */
  };

  static const rw_reg32_t HRTIM_TIMC_SETCxR[3] = {
    [1] = (rw_reg32_t)0x400175BCU,   /** @brief Timerx output1 set register. */
    [2] = (rw_reg32_t)0x400175C4U,   /** @brief Timerx output2 set register. */
  };

  static const rw_reg32_t HRTIM_TIMC_RSTCxR[3] = {
    [1] = (rw_reg32_t)0x400175C0U,   /** @brief Timerx output1 reset register. */
    [2] = (rw_reg32_t)0x400175C8U,   /** @brief Timerx output2 reset register. */
  };

  static const rw_reg32_t HRTIM_TIMC_EEFCRx[3] = {
    [1] = (rw_reg32_t)0x400175CCU,   /** @brief Timerx external event filtering register 1. */
    [2] = (rw_reg32_t)0x400175D0U,   /** @brief Timerx external event filtering register 2. */
  };

  static const rw_reg32_t HRTIM_TIMC_CPTxCCR[3] = {
    [1] = (rw_reg32_t)0x400175DCU,   /** @brief Timerx capture 2 control register. */
    [2] = (rw_reg32_t)0x400175E0U,   /** @brief CPT2xCR. */
  };

  /**** HRTIM_TIMC Register Field Definitions ****/

  static const field32_t HRTIM_TIMC_TIMCCR_UPDGAT      = {.msk = 0xF0000000U, .pos = 28};   /** @brief Update gating. */
  static const field32_t HRTIM_TIMC_TIMCCR_PREEN       = {.msk = 0x08000000U, .pos = 27};   /** @brief Preload enable. */
  static const field32_t HRTIM_TIMC_TIMCCR_DACSYNC     = {.msk = 0x06000000U, .pos = 25};   /** @brief AC synchronization. */
  static const field32_t HRTIM_TIMC_TIMCCR_MSTU        = {.msk = 0x01000000U, .pos = 24};   /** @brief Master timer update. */
  static const field32_t HRTIM_TIMC_TIMCCR_TEU         = {.msk = 0x00800000U, .pos = 23};   /** @brief TEU. */
  static const field32_t HRTIM_TIMC_TIMCCR_TDU         = {.msk = 0x00400000U, .pos = 22};   /** @brief TDU. */
  static const field32_t HRTIM_TIMC_TIMCCR_TCU         = {.msk = 0x00200000U, .pos = 21};   /** @brief TCU. */
  static const field32_t HRTIM_TIMC_TIMCCR_TBU         = {.msk = 0x00100000U, .pos = 20};   /** @brief TBU. */
  static const field32_t HRTIM_TIMC_TIMCCR_TXRSTU      = {.msk = 0x00040000U, .pos = 18};   /** @brief Timerx reset update. */
  static const field32_t HRTIM_TIMC_TIMCCR_TXREPU      = {.msk = 0x00020000U, .pos = 17};   /** @brief Timer x repetition update. */
  static const field32_t HRTIM_TIMC_TIMCCR_SYNCSTRTX   = {.msk = 0x00000800U, .pos = 11};   /** @brief Synchronization starts timer x. */
  static const field32_t HRTIM_TIMC_TIMCCR_SYNCRSTX    = {.msk = 0x00000400U, .pos = 10};   /** @brief Synchronization resets timer x. */
  static const field32_t HRTIM_TIMC_TIMCCR_PSHPLL      = {.msk = 0x00000040U, .pos = 6};    /** @brief Push-Pull mode enable. */
  static const field32_t HRTIM_TIMC_TIMCCR_HALF        = {.msk = 0x00000020U, .pos = 5};    /** @brief Half mode enable. */
  static const field32_t HRTIM_TIMC_TIMCCR_RETRIG      = {.msk = 0x00000010U, .pos = 4};    /** @brief Re-triggerable mode. */
  static const field32_t HRTIM_TIMC_TIMCCR_CONT        = {.msk = 0x00000008U, .pos = 3};    /** @brief Continuous mode. */
  static const field32_t HRTIM_TIMC_TIMCCR_CK_PSCX     = {.msk = 0x00000007U, .pos = 0};    /** @brief HRTIM timer x clock prescaler. */
  static const field32_t HRTIM_TIMC_TIMCISR_IPPSTAT    = {.msk = 0x00020000U, .pos = 17};   /** @brief Idle push pull status. */
  static const field32_t HRTIM_TIMC_TIMCISR_CPPSTAT    = {.msk = 0x00010000U, .pos = 16};   /** @brief Current push pull status. */
  static const field32_t HRTIM_TIMC_TIMCISR_DLYPRT     = {.msk = 0x00004000U, .pos = 14};   /** @brief Delayed protection flag. */
  static const field32_t HRTIM_TIMC_TIMCISR_RST        = {.msk = 0x00002000U, .pos = 13};   /** @brief Reset interrupt flag. */
  static const field32_t HRTIM_TIMC_TIMCISR_UPD        = {.msk = 0x00000040U, .pos = 6};    /** @brief Update interrupt flag. */
  static const field32_t HRTIM_TIMC_TIMCISR_REP        = {.msk = 0x00000010U, .pos = 4};    /** @brief Repetition interrupt flag. */
  static const field32_t HRTIM_TIMC_TIMCICR_DLYPRTC    = {.msk = 0x00004000U, .pos = 14};   /** @brief Delayed protection flag clear. */
  static const field32_t HRTIM_TIMC_TIMCICR_RSTC       = {.msk = 0x00002000U, .pos = 13};   /** @brief Reset interrupt flag clear. */
  static const field32_t HRTIM_TIMC_TIMCICR_UPDC       = {.msk = 0x00000040U, .pos = 6};    /** @brief Update interrupt flag clear. */
  static const field32_t HRTIM_TIMC_TIMCICR_REPC       = {.msk = 0x00000010U, .pos = 4};    /** @brief Repetition interrupt flag clear. */
  static const field32_t HRTIM_TIMC_TIMCDIER5_DLYPRTDE = {.msk = 0x40000000U, .pos = 30};   /** @brief DLYPRTDE. */
  static const field32_t HRTIM_TIMC_TIMCDIER5_RSTDE    = {.msk = 0x20000000U, .pos = 29};   /** @brief RSTDE. */
  static const field32_t HRTIM_TIMC_TIMCDIER5_SETX2DE  = {.msk = 0x08000000U, .pos = 27};   /** @brief SETx2DE. */
  static const field32_t HRTIM_TIMC_TIMCDIER5_SET1XDE  = {.msk = 0x02000000U, .pos = 25};   /** @brief SET1xDE. */
  static const field32_t HRTIM_TIMC_TIMCDIER5_UPDDE    = {.msk = 0x00400000U, .pos = 22};   /** @brief UPDDE. */
  static const field32_t HRTIM_TIMC_TIMCDIER5_REPDE    = {.msk = 0x00100000U, .pos = 20};   /** @brief REPDE. */
  static const field32_t HRTIM_TIMC_TIMCDIER5_DLYPRTIE = {.msk = 0x00004000U, .pos = 14};   /** @brief DLYPRTIE. */
  static const field32_t HRTIM_TIMC_TIMCDIER5_RSTIE    = {.msk = 0x00002000U, .pos = 13};   /** @brief RSTIE. */
  static const field32_t HRTIM_TIMC_TIMCDIER5_SETX2IE  = {.msk = 0x00000800U, .pos = 11};   /** @brief SETx2IE. */
  static const field32_t HRTIM_TIMC_TIMCDIER5_SET1XIE  = {.msk = 0x00000200U, .pos = 9};    /** @brief SET1xIE. */
  static const field32_t HRTIM_TIMC_TIMCDIER5_UPDIE    = {.msk = 0x00000040U, .pos = 6};    /** @brief UPDIE. */
  static const field32_t HRTIM_TIMC_TIMCDIER5_REPIE    = {.msk = 0x00000010U, .pos = 4};    /** @brief REPIE. */
  static const field32_t HRTIM_TIMC_CNTCR_CNTX         = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timerx counter value. */
  static const field32_t HRTIM_TIMC_PERCR_PERX         = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timerx period value. */
  static const field32_t HRTIM_TIMC_REPCR_REPX         = {.msk = 0x000000FFU, .pos = 0};    /** @brief Timerx repetition counter value. */
  static const field32_t HRTIM_TIMC_CMPxCR_CMP1X       = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timerx compare 1 value. */
  static const field32_t HRTIM_TIMC_CMP1CCR_REPX       = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Timerx repetition value (aliased from hrtim_repx register). */
  static const field32_t HRTIM_TIMC_CMP1CCR_CMP1X      = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timerx compare 1 value. */
  static const field32_t HRTIM_TIMC_CPTxCR_CPT1X       = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timerx capture 1 value. */
  static const field32_t HRTIM_TIMC_DTCR_DTFLKX        = {.msk = 0x80000000U, .pos = 31};   /** @brief Deadtime falling lock. */
  static const field32_t HRTIM_TIMC_DTCR_DTFSLKX       = {.msk = 0x40000000U, .pos = 30};   /** @brief Deadtime falling sign lock. */
  static const field32_t HRTIM_TIMC_DTCR_SDTFX         = {.msk = 0x02000000U, .pos = 25};   /** @brief Sign deadtime falling value. */
  static const field32_t HRTIM_TIMC_DTCR_DTFX          = {.msk = 0x01FF0000U, .pos = 16};   /** @brief Deadtime falling value. */
  static const field32_t HRTIM_TIMC_DTCR_DTRLKX        = {.msk = 0x00008000U, .pos = 15};   /** @brief Deadtime rising lock. */
  static const field32_t HRTIM_TIMC_DTCR_DTRSLKX       = {.msk = 0x00004000U, .pos = 14};   /** @brief Deadtime rising sign lock. */
  static const field32_t HRTIM_TIMC_DTCR_DTPRSC        = {.msk = 0x00001C00U, .pos = 10};   /** @brief Deadtime prescaler. */
  static const field32_t HRTIM_TIMC_DTCR_SDTRX         = {.msk = 0x00000200U, .pos = 9};    /** @brief Sign deadtime rising value. */
  static const field32_t HRTIM_TIMC_DTCR_DTRX          = {.msk = 0x000001FFU, .pos = 0};    /** @brief Deadtime rising value. */
  static const field32_t HRTIM_TIMC_SETCxR_UPDATE      = {.msk = 0x80000000U, .pos = 31};   /** @brief Registers update (transfer preload to active). */
  static const field32_t HRTIM_TIMC_SETCxR_MSTPER      = {.msk = 0x00000080U, .pos = 7};    /** @brief Master period. */
  static const field32_t HRTIM_TIMC_SETCxR_PER         = {.msk = 0x00000004U, .pos = 2};    /** @brief Timer A period. */
  static const field32_t HRTIM_TIMC_SETCxR_RESYNC      = {.msk = 0x00000002U, .pos = 1};    /** @brief Timer A resynchronizaton. */
  static const field32_t HRTIM_TIMC_SETCxR_SST         = {.msk = 0x00000001U, .pos = 0};    /** @brief Software set trigger. */
  static const field32_t HRTIM_TIMC_RSTCxR_UPDATE      = {.msk = 0x80000000U, .pos = 31};   /** @brief UPDATE. */
  static const field32_t HRTIM_TIMC_RSTCxR_MSTPER      = {.msk = 0x00000080U, .pos = 7};    /** @brief MSTPER. */
  static const field32_t HRTIM_TIMC_RSTCxR_PER         = {.msk = 0x00000004U, .pos = 2};    /** @brief PER. */
  static const field32_t HRTIM_TIMC_RSTCxR_RESYNC      = {.msk = 0x00000002U, .pos = 1};    /** @brief RESYNC. */
  static const field32_t HRTIM_TIMC_RSTCxR_SRT         = {.msk = 0x00000001U, .pos = 0};    /** @brief SRT. */
  static const field32_t HRTIM_TIMC_RSTCR_MSTPER       = {.msk = 0x00000010U, .pos = 4};    /** @brief Master timer period. */
  static const field32_t HRTIM_TIMC_RSTCR_UPDT         = {.msk = 0x00000002U, .pos = 1};    /** @brief Timer A update reset. */
  static const field32_t HRTIM_TIMC_CHPCR_STRTPW       = {.msk = 0x00000780U, .pos = 7};    /** @brief STRTPW. */
  static const field32_t HRTIM_TIMC_CHPCR_CHPDTY       = {.msk = 0x00000070U, .pos = 4};    /** @brief Timerx chopper duty cycle value. */
  static const field32_t HRTIM_TIMC_CHPCR_CHPFRQ       = {.msk = 0x0000000FU, .pos = 0};    /** @brief Timerx carrier frequency value. */
  static const field32_t HRTIM_TIMC_CPTxCCR_TE1RST     = {.msk = 0x20000000U, .pos = 29};   /** @brief Timer E output 1 reset. */
  static const field32_t HRTIM_TIMC_CPTxCCR_TE1SET     = {.msk = 0x10000000U, .pos = 28};   /** @brief Timer E output 1 set. */
  static const field32_t HRTIM_TIMC_CPTxCCR_TD1RST     = {.msk = 0x02000000U, .pos = 25};   /** @brief Timer D output 1 reset. */
  static const field32_t HRTIM_TIMC_CPTxCCR_TD1SET     = {.msk = 0x01000000U, .pos = 24};   /** @brief Timer D output 1 set. */
  static const field32_t HRTIM_TIMC_CPTxCCR_TB1RST     = {.msk = 0x00020000U, .pos = 17};   /** @brief Timer B output 1 reset. */
  static const field32_t HRTIM_TIMC_CPTxCCR_TB1SET     = {.msk = 0x00010000U, .pos = 16};   /** @brief Timer B output 1 set. */
  static const field32_t HRTIM_TIMC_CPTxCCR_TA1RST     = {.msk = 0x00002000U, .pos = 13};   /** @brief Timer A output 1 reset. */
  static const field32_t HRTIM_TIMC_CPTxCCR_TA1SET     = {.msk = 0x00001000U, .pos = 12};   /** @brief Timer A output 1 set. */
  static const field32_t HRTIM_TIMC_CPTxCCR_UDPCPT     = {.msk = 0x00000002U, .pos = 1};    /** @brief Update capture. */
  static const field32_t HRTIM_TIMC_CPTxCCR_SWCPT      = {.msk = 0x00000001U, .pos = 0};    /** @brief Software capture. */
  static const field32_t HRTIM_TIMC_OUTCR_DLYPRT       = {.msk = 0x00001C00U, .pos = 10};   /** @brief Delayed protection. */
  static const field32_t HRTIM_TIMC_OUTCR_DLYPRTEN     = {.msk = 0x00000200U, .pos = 9};    /** @brief Delayed protection enable. */
  static const field32_t HRTIM_TIMC_OUTCR_DTEN         = {.msk = 0x00000100U, .pos = 8};    /** @brief Deadtime enable. */
  static const field32_t HRTIM_TIMC_FLTCR_FLTLCK       = {.msk = 0x80000000U, .pos = 31};   /** @brief Fault sources lock. */

  /**** Enumerated HRTIM_TIMC Register Field Definitions ****/

  static field32_t const HRTIM_TIMC_TIMCCR_DELCMPx[5] = {
    [2] = {.msk = 0x00003000U, .pos = 12},   /** @brief Delayed CMP2 mode. */
    [4] = {.msk = 0x0000C000U, .pos = 14},   /** @brief Delayed CMP4 mode. */
  };

  static field32_t const HRTIM_TIMC_TIMCISR_OxSTAT[3] = {
    [1] = {.msk = 0x00040000U, .pos = 18},   /** @brief Output 1 state. */
    [2] = {.msk = 0x00080000U, .pos = 19},   /** @brief Output 2 state. */
  };

  static field32_t const HRTIM_TIMC_TIMCISR_RSTXx[3] = {
    [1] = {.msk = 0x00000400U, .pos = 10},   /** @brief Output 1 reset interrupt flag. */
    [2] = {.msk = 0x00001000U, .pos = 12},   /** @brief Output 2 reset interrupt flag. */
  };

  static field32_t const HRTIM_TIMC_TIMCISR_SETXx[3] = {
    [1] = {.msk = 0x00000200U, .pos = 9},    /** @brief Output 1 set interrupt flag. */
    [2] = {.msk = 0x00000800U, .pos = 11},   /** @brief Output 2 set interrupt flag. */
  };

  static field32_t const HRTIM_TIMC_TIMCISR_CPTx[3] = {
    [1] = {.msk = 0x00000080U, .pos = 7},   /** @brief Capture1 interrupt flag. */
    [2] = {.msk = 0x00000100U, .pos = 8},   /** @brief Capture2 interrupt flag. */
  };

  static field32_t const HRTIM_TIMC_TIMCISR_CMPx[5] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief Compare 1 interrupt flag. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief Compare 2 interrupt flag. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief Compare 3 interrupt flag. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief Compare 4 interrupt flag. */
  };

  static field32_t const HRTIM_TIMC_TIMCICR_RSTXxC[3] = {
    [1] = {.msk = 0x00000400U, .pos = 10},   /** @brief Output 1 reset flag clear. */
    [2] = {.msk = 0x00001000U, .pos = 12},   /** @brief Output 2 reset flag clear. */
  };

  static field32_t const HRTIM_TIMC_TIMCICR_SETxXC[3] = {
    [1] = {.msk = 0x00000200U, .pos = 9},    /** @brief Output 1 set flag clear. */
    [2] = {.msk = 0x00000800U, .pos = 11},   /** @brief Output 2 set flag clear. */
  };

  static field32_t const HRTIM_TIMC_TIMCICR_CPTxC[3] = {
    [1] = {.msk = 0x00000080U, .pos = 7},   /** @brief Capture1 interrupt flag clear. */
    [2] = {.msk = 0x00000100U, .pos = 8},   /** @brief Capture2 interrupt flag clear. */
  };

  static field32_t const HRTIM_TIMC_TIMCICR_CMPxC[5] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief Compare 1 interrupt flag clear. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief Compare 2 interrupt flag clear. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief Compare 3 interrupt flag clear. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief Compare 4 interrupt flag clear. */
  };

  static field32_t const HRTIM_TIMC_TIMCDIER5_RSTXxDE[3] = {
    [1] = {.msk = 0x04000000U, .pos = 26},   /** @brief RSTx1DE. */
    [2] = {.msk = 0x10000000U, .pos = 28},   /** @brief RSTx2DE. */
  };

  static field32_t const HRTIM_TIMC_TIMCDIER5_CPTxDE[3] = {
    [1] = {.msk = 0x00800000U, .pos = 23},   /** @brief CPT1DE. */
    [2] = {.msk = 0x01000000U, .pos = 24},   /** @brief CPT2DE. */
  };

  static field32_t const HRTIM_TIMC_TIMCDIER5_CMPxDE[5] = {
    [1] = {.msk = 0x00010000U, .pos = 16},   /** @brief CMP1DE. */
    [2] = {.msk = 0x00020000U, .pos = 17},   /** @brief CMP2DE. */
    [3] = {.msk = 0x00040000U, .pos = 18},   /** @brief CMP3DE. */
    [4] = {.msk = 0x00080000U, .pos = 19},   /** @brief CMP4DE. */
  };

  static field32_t const HRTIM_TIMC_TIMCDIER5_RSTXxIE[3] = {
    [1] = {.msk = 0x00000400U, .pos = 10},   /** @brief RSTx1IE. */
    [2] = {.msk = 0x00001000U, .pos = 12},   /** @brief RSTx2IE. */
  };

  static field32_t const HRTIM_TIMC_TIMCDIER5_CPTxIE[3] = {
    [1] = {.msk = 0x00000080U, .pos = 7},   /** @brief CPT1IE. */
    [2] = {.msk = 0x00000100U, .pos = 8},   /** @brief CPT2IE. */
  };

  static field32_t const HRTIM_TIMC_TIMCDIER5_CMPxIE[5] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief CMP1IE. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief CMP2IE. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief CMP3IE. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief CMP4IE. */
  };

  static field32_t const HRTIM_TIMC_SETCxR_EXTEVNTx[11] = {
    [1]  = {.msk = 0x00200000U, .pos = 21},   /** @brief External event 1. */
    [2]  = {.msk = 0x00400000U, .pos = 22},   /** @brief External event 2. */
    [3]  = {.msk = 0x00800000U, .pos = 23},   /** @brief External event 3. */
    [4]  = {.msk = 0x01000000U, .pos = 24},   /** @brief External event 4. */
    [5]  = {.msk = 0x02000000U, .pos = 25},   /** @brief External event 5. */
    [6]  = {.msk = 0x04000000U, .pos = 26},   /** @brief External event 6. */
    [7]  = {.msk = 0x08000000U, .pos = 27},   /** @brief External event 7. */
    [8]  = {.msk = 0x10000000U, .pos = 28},   /** @brief External event 8. */
    [9]  = {.msk = 0x20000000U, .pos = 29},   /** @brief External event 9. */
    [10] = {.msk = 0x40000000U, .pos = 30},   /** @brief External event 10. */
  };

  static field32_t const HRTIM_TIMC_SETCxR_TIMEVNTx[10] = {
    [1]  = {.msk = 0x00001000U, .pos = 12},   /** @brief Timer event 1. */
    [2]  = {.msk = 0x00002000U, .pos = 13},   /** @brief Timer event 2. */
    [3]  = {.msk = 0x00004000U, .pos = 14},   /** @brief Timer event 3. */
    [4]  = {.msk = 0x00008000U, .pos = 15},   /** @brief Timer event 4. */
    [5]  = {.msk = 0x00010000U, .pos = 16},   /** @brief Timer event 5. */
    [6]  = {.msk = 0x00020000U, .pos = 17},   /** @brief Timer event 6. */
    [7]  = {.msk = 0x00040000U, .pos = 18},   /** @brief Timer event 7. */
    [8]  = {.msk = 0x00080000U, .pos = 19},   /** @brief Timer event 8. */
    [9]  = {.msk = 0x00100000U, .pos = 20},   /** @brief Timer event 9. */
  };

  static field32_t const HRTIM_TIMC_SETCxR_MSTCMPx[5] = {
    [1] = {.msk = 0x00000100U, .pos = 8},    /** @brief Master compare 1. */
    [2] = {.msk = 0x00000200U, .pos = 9},    /** @brief Master compare 2. */
    [3] = {.msk = 0x00000400U, .pos = 10},   /** @brief Master compare 3. */
    [4] = {.msk = 0x00000800U, .pos = 11},   /** @brief Master compare 4. */
  };

  static field32_t const HRTIM_TIMC_EEFCRx_EExFLTR[6] = {
    [1] = {.msk = 0x0000001EU, .pos = 1},    /** @brief External event 1 filter. */
    [2] = {.msk = 0x00000780U, .pos = 7},    /** @brief External event 2 filter. */
    [3] = {.msk = 0x0001E000U, .pos = 13},   /** @brief External event 3 filter. */
    [4] = {.msk = 0x00780000U, .pos = 19},   /** @brief External event 4 filter. */
    [5] = {.msk = 0x1E000000U, .pos = 25},   /** @brief External event 5 filter. */
  };

  static field32_t const HRTIM_TIMC_EEFCRx_EExLTCH[6] = {
    [1] = {.msk = 0x00000001U, .pos = 0},    /** @brief External event 1 latch. */
    [2] = {.msk = 0x00000040U, .pos = 6},    /** @brief External event 2 latch. */
    [3] = {.msk = 0x00001000U, .pos = 12},   /** @brief External event 3 latch. */
    [4] = {.msk = 0x00040000U, .pos = 18},   /** @brief External event 4 latch. */
    [5] = {.msk = 0x01000000U, .pos = 24},   /** @brief External event 5 latch. */
  };

  static field32_t const HRTIM_TIMC_RSTCR_TIMECMPx[5] = {
    [1] = {.msk = 0x10000000U, .pos = 28},   /** @brief Timer E compare 1. */
    [2] = {.msk = 0x20000000U, .pos = 29},   /** @brief Timer E compare 2. */
    [4] = {.msk = 0x40000000U, .pos = 30},   /** @brief Timer E compare 4. */
  };

  static field32_t const HRTIM_TIMC_RSTCR_TIMDCMPx[5] = {
    [1] = {.msk = 0x02000000U, .pos = 25},   /** @brief Timer D compare 1. */
    [2] = {.msk = 0x04000000U, .pos = 26},   /** @brief Timer D compare 2. */
    [4] = {.msk = 0x08000000U, .pos = 27},   /** @brief Timer D compare 4. */
  };

  static field32_t const HRTIM_TIMC_RSTCR_TIMBCMPx[5] = {
    [1] = {.msk = 0x00400000U, .pos = 22},   /** @brief Timer B compare 1. */
    [2] = {.msk = 0x00800000U, .pos = 23},   /** @brief Timer B compare 2. */
    [4] = {.msk = 0x01000000U, .pos = 24},   /** @brief Timer B compare 4. */
  };

  static field32_t const HRTIM_TIMC_RSTCR_TIMACMPx[5] = {
    [1] = {.msk = 0x00080000U, .pos = 19},   /** @brief Timer A compare 1. */
    [2] = {.msk = 0x00100000U, .pos = 20},   /** @brief Timer A compare 2. */
    [4] = {.msk = 0x00200000U, .pos = 21},   /** @brief Timer A compare 4. */
  };

  static field32_t const HRTIM_TIMC_CPTxCCR_TECMPx[3] = {
    [1] = {.msk = 0x40000000U, .pos = 30},   /** @brief Timer E compare 1. */
    [2] = {.msk = 0x80000000U, .pos = 31},   /** @brief Timer E compare 2. */
  };

  static field32_t const HRTIM_TIMC_CPTxCCR_TDCMPx[3] = {
    [1] = {.msk = 0x04000000U, .pos = 26},   /** @brief Timer D compare 1. */
    [2] = {.msk = 0x08000000U, .pos = 27},   /** @brief Timer D compare 2. */
  };

  static field32_t const HRTIM_TIMC_CPTxCCR_TBCMPx[3] = {
    [1] = {.msk = 0x00040000U, .pos = 18},   /** @brief Timer B compare 1. */
    [2] = {.msk = 0x00080000U, .pos = 19},   /** @brief Timer B compare 2. */
  };

  static field32_t const HRTIM_TIMC_CPTxCCR_TACMPx[3] = {
    [1] = {.msk = 0x00004000U, .pos = 14},   /** @brief Timer A compare 1. */
    [2] = {.msk = 0x00008000U, .pos = 15},   /** @brief Timer A compare 2. */
  };

  static field32_t const HRTIM_TIMC_CPTxCCR_EXEVxCPT[11] = {
    [1]  = {.msk = 0x00000004U, .pos = 2},    /** @brief External event 1 capture. */
    [2]  = {.msk = 0x00000008U, .pos = 3},    /** @brief External event 2 capture. */
    [3]  = {.msk = 0x00000010U, .pos = 4},    /** @brief External event 3 capture. */
    [4]  = {.msk = 0x00000020U, .pos = 5},    /** @brief External event 4 capture. */
    [5]  = {.msk = 0x00000040U, .pos = 6},    /** @brief External event 5 capture. */
    [6]  = {.msk = 0x00000080U, .pos = 7},    /** @brief External event 6 capture. */
    [7]  = {.msk = 0x00000100U, .pos = 8},    /** @brief External event 7 capture. */
    [8]  = {.msk = 0x00000200U, .pos = 9},    /** @brief External event 8 capture. */
    [9]  = {.msk = 0x00000400U, .pos = 10},   /** @brief External event 9 capture. */
    [10] = {.msk = 0x00000800U, .pos = 11},   /** @brief External event 10 capture. */
  };

  static field32_t const HRTIM_TIMC_OUTCR_DIDLx[3] = {
    [1] = {.msk = 0x00000080U, .pos = 7},    /** @brief Output 1 deadtime upon burst mode idle entry. */
    [2] = {.msk = 0x00800000U, .pos = 23},   /** @brief Output 2 deadtime upon burst mode idle entry. */
  };

  static field32_t const HRTIM_TIMC_OUTCR_CHPx[3] = {
    [1] = {.msk = 0x00000040U, .pos = 6},    /** @brief Output 1 chopper enable. */
    [2] = {.msk = 0x00400000U, .pos = 22},   /** @brief Output 2 chopper enable. */
  };

  static field32_t const HRTIM_TIMC_OUTCR_FAULTx[3] = {
    [1] = {.msk = 0x00000030U, .pos = 4},    /** @brief Output 1 fault state. */
    [2] = {.msk = 0x00300000U, .pos = 20},   /** @brief Output 2 fault state. */
  };

  static field32_t const HRTIM_TIMC_OUTCR_IDLESx[3] = {
    [1] = {.msk = 0x00000008U, .pos = 3},    /** @brief Output 1 idle state. */
    [2] = {.msk = 0x00080000U, .pos = 19},   /** @brief Output 2 idle state. */
  };

  static field32_t const HRTIM_TIMC_OUTCR_IDLEMx[3] = {
    [1] = {.msk = 0x00000004U, .pos = 2},    /** @brief Output 1 idle mode. */
    [2] = {.msk = 0x00040000U, .pos = 18},   /** @brief Output 2 idle mode. */
  };

  static field32_t const HRTIM_TIMC_OUTCR_POLx[3] = {
    [1] = {.msk = 0x00000002U, .pos = 1},    /** @brief Output 1 polarity. */
    [2] = {.msk = 0x00020000U, .pos = 17},   /** @brief Output 2 polarity. */
  };

  static field32_t const HRTIM_TIMC_FLTCR_FLTxEN[6] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief Fault 1 enable. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief Fault 2 enable. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief Fault 3 enable. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief Fault 4 enable. */
    [5] = {.msk = 0x00000010U, .pos = 4},   /** @brief Fault 5 enable. */
  };

  /************************************************************************************************
   * HRTIM_TIMD Definitions
   ************************************************************************************************/

  /**** HRTIM_TIMD Register Definitions ****/

  static const rw_reg32_t HRTIM_TIMD_TIMDCR    = (rw_reg32_t)0x40017600U;   /** @brief Timerx control register. */
  static const ro_reg32_t HRTIM_TIMD_TIMDISR   = (ro_reg32_t)0x40017604U;   /** @brief Timerx interrupt status register. */
  static const rw_reg32_t HRTIM_TIMD_TIMDICR   = (rw_reg32_t)0x40017608U;   /** @brief Timerx interrupt clear register. */
  static const rw_reg32_t HRTIM_TIMD_TIMDDIER5 = (rw_reg32_t)0x4001760CU;   /** @brief TIMxDIER5. */
  static const rw_reg32_t HRTIM_TIMD_CNTDR     = (rw_reg32_t)0x40017610U;   /** @brief Timerx counter register. */
  static const rw_reg32_t HRTIM_TIMD_PERDR     = (rw_reg32_t)0x40017614U;   /** @brief Timerx period register. */
  static const rw_reg32_t HRTIM_TIMD_REPDR     = (rw_reg32_t)0x40017618U;   /** @brief Timerx repetition register. */
  static const rw_reg32_t HRTIM_TIMD_CMP1CDR   = (rw_reg32_t)0x40017620U;   /** @brief Timerx compare 1 compound register. */
  static const rw_reg32_t HRTIM_TIMD_DTDR      = (rw_reg32_t)0x40017638U;   /** @brief Timerx deadtime register. */
  static const rw_reg32_t HRTIM_TIMD_RSTDR     = (rw_reg32_t)0x40017654U;   /** @brief TimerA reset register. */
  static const rw_reg32_t HRTIM_TIMD_CHPDR     = (rw_reg32_t)0x40017658U;   /** @brief Timerx chopper register. */
  static const rw_reg32_t HRTIM_TIMD_OUTDR     = (rw_reg32_t)0x40017664U;   /** @brief Timerx output register. */
  static const rw_reg32_t HRTIM_TIMD_FLTDR     = (rw_reg32_t)0x40017668U;   /** @brief Timerx fault register. */

  /**** Enumerated HRTIM_TIMD Register Definitions ****/

  static const rw_reg32_t HRTIM_TIMD_CMPxDR[5] = {
    [1] = (rw_reg32_t)0x4001761CU,   /** @brief Timerx compare 1 register. */
    [2] = (rw_reg32_t)0x40017624U,   /** @brief Timerx compare 2 register. */
    [3] = (rw_reg32_t)0x40017628U,   /** @brief Timerx compare 3 register. */
    [4] = (rw_reg32_t)0x4001762CU,   /** @brief Timerx compare 4 register. */
  };

  static const ro_reg32_t HRTIM_TIMD_CPTxDR[3] = {
    [1] = (ro_reg32_t)0x40017630U,   /** @brief Timerx capture 1 register. */
    [2] = (ro_reg32_t)0x40017634U,   /** @brief Timerx capture 2 register. */
  };

  static const rw_reg32_t HRTIM_TIMD_SETDxR[3] = {
    [1] = (rw_reg32_t)0x4001763CU,   /** @brief Timerx output1 set register. */
    [2] = (rw_reg32_t)0x40017644U,   /** @brief Timerx output2 set register. */
  };

  static const rw_reg32_t HRTIM_TIMD_RSTDxR[3] = {
    [1] = (rw_reg32_t)0x40017640U,   /** @brief Timerx output1 reset register. */
    [2] = (rw_reg32_t)0x40017648U,   /** @brief Timerx output2 reset register. */
  };

  static const rw_reg32_t HRTIM_TIMD_EEFDRx[3] = {
    [1] = (rw_reg32_t)0x4001764CU,   /** @brief Timerx external event filtering register 1. */
    [2] = (rw_reg32_t)0x40017650U,   /** @brief Timerx external event filtering register 2. */
  };

  static const rw_reg32_t HRTIM_TIMD_CPTxDCR[3] = {
    [1] = (rw_reg32_t)0x4001765CU,   /** @brief Timerx capture 2 control register. */
    [2] = (rw_reg32_t)0x40017660U,   /** @brief CPT2xCR. */
  };

  /**** HRTIM_TIMD Register Field Definitions ****/

  static const field32_t HRTIM_TIMD_TIMDCR_UPDGAT      = {.msk = 0xF0000000U, .pos = 28};   /** @brief Update gating. */
  static const field32_t HRTIM_TIMD_TIMDCR_PREEN       = {.msk = 0x08000000U, .pos = 27};   /** @brief Preload enable. */
  static const field32_t HRTIM_TIMD_TIMDCR_DACSYNC     = {.msk = 0x06000000U, .pos = 25};   /** @brief AC synchronization. */
  static const field32_t HRTIM_TIMD_TIMDCR_MSTU        = {.msk = 0x01000000U, .pos = 24};   /** @brief Master timer update. */
  static const field32_t HRTIM_TIMD_TIMDCR_TEU         = {.msk = 0x00800000U, .pos = 23};   /** @brief TEU. */
  static const field32_t HRTIM_TIMD_TIMDCR_TDU         = {.msk = 0x00400000U, .pos = 22};   /** @brief TDU. */
  static const field32_t HRTIM_TIMD_TIMDCR_TCU         = {.msk = 0x00200000U, .pos = 21};   /** @brief TCU. */
  static const field32_t HRTIM_TIMD_TIMDCR_TBU         = {.msk = 0x00100000U, .pos = 20};   /** @brief TBU. */
  static const field32_t HRTIM_TIMD_TIMDCR_TXRSTU      = {.msk = 0x00040000U, .pos = 18};   /** @brief Timerx reset update. */
  static const field32_t HRTIM_TIMD_TIMDCR_TXREPU      = {.msk = 0x00020000U, .pos = 17};   /** @brief Timer x repetition update. */
  static const field32_t HRTIM_TIMD_TIMDCR_SYNCSTRTX   = {.msk = 0x00000800U, .pos = 11};   /** @brief Synchronization starts timer x. */
  static const field32_t HRTIM_TIMD_TIMDCR_SYNCRSTX    = {.msk = 0x00000400U, .pos = 10};   /** @brief Synchronization resets timer x. */
  static const field32_t HRTIM_TIMD_TIMDCR_PSHPLL      = {.msk = 0x00000040U, .pos = 6};    /** @brief Push-Pull mode enable. */
  static const field32_t HRTIM_TIMD_TIMDCR_HALF        = {.msk = 0x00000020U, .pos = 5};    /** @brief Half mode enable. */
  static const field32_t HRTIM_TIMD_TIMDCR_RETRIG      = {.msk = 0x00000010U, .pos = 4};    /** @brief Re-triggerable mode. */
  static const field32_t HRTIM_TIMD_TIMDCR_CONT        = {.msk = 0x00000008U, .pos = 3};    /** @brief Continuous mode. */
  static const field32_t HRTIM_TIMD_TIMDCR_CK_PSCX     = {.msk = 0x00000007U, .pos = 0};    /** @brief HRTIM timer x clock prescaler. */
  static const field32_t HRTIM_TIMD_TIMDISR_IPPSTAT    = {.msk = 0x00020000U, .pos = 17};   /** @brief Idle push pull status. */
  static const field32_t HRTIM_TIMD_TIMDISR_CPPSTAT    = {.msk = 0x00010000U, .pos = 16};   /** @brief Current push pull status. */
  static const field32_t HRTIM_TIMD_TIMDISR_DLYPRT     = {.msk = 0x00004000U, .pos = 14};   /** @brief Delayed protection flag. */
  static const field32_t HRTIM_TIMD_TIMDISR_RST        = {.msk = 0x00002000U, .pos = 13};   /** @brief Reset interrupt flag. */
  static const field32_t HRTIM_TIMD_TIMDISR_UPD        = {.msk = 0x00000040U, .pos = 6};    /** @brief Update interrupt flag. */
  static const field32_t HRTIM_TIMD_TIMDISR_REP        = {.msk = 0x00000010U, .pos = 4};    /** @brief Repetition interrupt flag. */
  static const field32_t HRTIM_TIMD_TIMDICR_DLYPRTC    = {.msk = 0x00004000U, .pos = 14};   /** @brief Delayed protection flag clear. */
  static const field32_t HRTIM_TIMD_TIMDICR_RSTC       = {.msk = 0x00002000U, .pos = 13};   /** @brief Reset interrupt flag clear. */
  static const field32_t HRTIM_TIMD_TIMDICR_UPDC       = {.msk = 0x00000040U, .pos = 6};    /** @brief Update interrupt flag clear. */
  static const field32_t HRTIM_TIMD_TIMDICR_REPC       = {.msk = 0x00000010U, .pos = 4};    /** @brief Repetition interrupt flag clear. */
  static const field32_t HRTIM_TIMD_TIMDDIER5_DLYPRTDE = {.msk = 0x40000000U, .pos = 30};   /** @brief DLYPRTDE. */
  static const field32_t HRTIM_TIMD_TIMDDIER5_RSTDE    = {.msk = 0x20000000U, .pos = 29};   /** @brief RSTDE. */
  static const field32_t HRTIM_TIMD_TIMDDIER5_SETX2DE  = {.msk = 0x08000000U, .pos = 27};   /** @brief SETx2DE. */
  static const field32_t HRTIM_TIMD_TIMDDIER5_SET1XDE  = {.msk = 0x02000000U, .pos = 25};   /** @brief SET1xDE. */
  static const field32_t HRTIM_TIMD_TIMDDIER5_UPDDE    = {.msk = 0x00400000U, .pos = 22};   /** @brief UPDDE. */
  static const field32_t HRTIM_TIMD_TIMDDIER5_REPDE    = {.msk = 0x00100000U, .pos = 20};   /** @brief REPDE. */
  static const field32_t HRTIM_TIMD_TIMDDIER5_DLYPRTIE = {.msk = 0x00004000U, .pos = 14};   /** @brief DLYPRTIE. */
  static const field32_t HRTIM_TIMD_TIMDDIER5_RSTIE    = {.msk = 0x00002000U, .pos = 13};   /** @brief RSTIE. */
  static const field32_t HRTIM_TIMD_TIMDDIER5_SETX2IE  = {.msk = 0x00000800U, .pos = 11};   /** @brief SETx2IE. */
  static const field32_t HRTIM_TIMD_TIMDDIER5_SET1XIE  = {.msk = 0x00000200U, .pos = 9};    /** @brief SET1xIE. */
  static const field32_t HRTIM_TIMD_TIMDDIER5_UPDIE    = {.msk = 0x00000040U, .pos = 6};    /** @brief UPDIE. */
  static const field32_t HRTIM_TIMD_TIMDDIER5_REPIE    = {.msk = 0x00000010U, .pos = 4};    /** @brief REPIE. */
  static const field32_t HRTIM_TIMD_CNTDR_CNTX         = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timerx counter value. */
  static const field32_t HRTIM_TIMD_PERDR_PERX         = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timerx period value. */
  static const field32_t HRTIM_TIMD_REPDR_REPX         = {.msk = 0x000000FFU, .pos = 0};    /** @brief Timerx repetition counter value. */
  static const field32_t HRTIM_TIMD_CMPxDR_CMP1X       = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timerx compare 1 value. */
  static const field32_t HRTIM_TIMD_CMP1CDR_REPX       = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Timerx repetition value (aliased from hrtim_repx register). */
  static const field32_t HRTIM_TIMD_CMP1CDR_CMP1X      = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timerx compare 1 value. */
  static const field32_t HRTIM_TIMD_CPTxDR_CPT1X       = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timerx capture 1 value. */
  static const field32_t HRTIM_TIMD_DTDR_DTFLKX        = {.msk = 0x80000000U, .pos = 31};   /** @brief Deadtime falling lock. */
  static const field32_t HRTIM_TIMD_DTDR_DTFSLKX       = {.msk = 0x40000000U, .pos = 30};   /** @brief Deadtime falling sign lock. */
  static const field32_t HRTIM_TIMD_DTDR_SDTFX         = {.msk = 0x02000000U, .pos = 25};   /** @brief Sign deadtime falling value. */
  static const field32_t HRTIM_TIMD_DTDR_DTFX          = {.msk = 0x01FF0000U, .pos = 16};   /** @brief Deadtime falling value. */
  static const field32_t HRTIM_TIMD_DTDR_DTRLKX        = {.msk = 0x00008000U, .pos = 15};   /** @brief Deadtime rising lock. */
  static const field32_t HRTIM_TIMD_DTDR_DTRSLKX       = {.msk = 0x00004000U, .pos = 14};   /** @brief Deadtime rising sign lock. */
  static const field32_t HRTIM_TIMD_DTDR_DTPRSC        = {.msk = 0x00001C00U, .pos = 10};   /** @brief Deadtime prescaler. */
  static const field32_t HRTIM_TIMD_DTDR_SDTRX         = {.msk = 0x00000200U, .pos = 9};    /** @brief Sign deadtime rising value. */
  static const field32_t HRTIM_TIMD_DTDR_DTRX          = {.msk = 0x000001FFU, .pos = 0};    /** @brief Deadtime rising value. */
  static const field32_t HRTIM_TIMD_SETDxR_UPDATE      = {.msk = 0x80000000U, .pos = 31};   /** @brief Registers update (transfer preload to active). */
  static const field32_t HRTIM_TIMD_SETDxR_MSTPER      = {.msk = 0x00000080U, .pos = 7};    /** @brief Master period. */
  static const field32_t HRTIM_TIMD_SETDxR_PER         = {.msk = 0x00000004U, .pos = 2};    /** @brief Timer A period. */
  static const field32_t HRTIM_TIMD_SETDxR_RESYNC      = {.msk = 0x00000002U, .pos = 1};    /** @brief Timer A resynchronizaton. */
  static const field32_t HRTIM_TIMD_SETDxR_SST         = {.msk = 0x00000001U, .pos = 0};    /** @brief Software set trigger. */
  static const field32_t HRTIM_TIMD_RSTDxR_UPDATE      = {.msk = 0x80000000U, .pos = 31};   /** @brief UPDATE. */
  static const field32_t HRTIM_TIMD_RSTDxR_MSTPER      = {.msk = 0x00000080U, .pos = 7};    /** @brief MSTPER. */
  static const field32_t HRTIM_TIMD_RSTDxR_PER         = {.msk = 0x00000004U, .pos = 2};    /** @brief PER. */
  static const field32_t HRTIM_TIMD_RSTDxR_RESYNC      = {.msk = 0x00000002U, .pos = 1};    /** @brief RESYNC. */
  static const field32_t HRTIM_TIMD_RSTDxR_SRT         = {.msk = 0x00000001U, .pos = 0};    /** @brief SRT. */
  static const field32_t HRTIM_TIMD_RSTDR_MSTPER       = {.msk = 0x00000010U, .pos = 4};    /** @brief Master timer period. */
  static const field32_t HRTIM_TIMD_RSTDR_UPDT         = {.msk = 0x00000002U, .pos = 1};    /** @brief Timer A update reset. */
  static const field32_t HRTIM_TIMD_CHPDR_STRTPW       = {.msk = 0x00000780U, .pos = 7};    /** @brief STRTPW. */
  static const field32_t HRTIM_TIMD_CHPDR_CHPDTY       = {.msk = 0x00000070U, .pos = 4};    /** @brief Timerx chopper duty cycle value. */
  static const field32_t HRTIM_TIMD_CHPDR_CHPFRQ       = {.msk = 0x0000000FU, .pos = 0};    /** @brief Timerx carrier frequency value. */
  static const field32_t HRTIM_TIMD_CPTxDCR_TE1RST     = {.msk = 0x20000000U, .pos = 29};   /** @brief Timer E output 1 reset. */
  static const field32_t HRTIM_TIMD_CPTxDCR_TE1SET     = {.msk = 0x10000000U, .pos = 28};   /** @brief Timer E output 1 set. */
  static const field32_t HRTIM_TIMD_CPTxDCR_TC1RST     = {.msk = 0x00200000U, .pos = 21};   /** @brief Timer C output 1 reset. */
  static const field32_t HRTIM_TIMD_CPTxDCR_TC1SET     = {.msk = 0x00100000U, .pos = 20};   /** @brief Timer C output 1 set. */
  static const field32_t HRTIM_TIMD_CPTxDCR_TB1RST     = {.msk = 0x00020000U, .pos = 17};   /** @brief Timer B output 1 reset. */
  static const field32_t HRTIM_TIMD_CPTxDCR_TB1SET     = {.msk = 0x00010000U, .pos = 16};   /** @brief Timer B output 1 set. */
  static const field32_t HRTIM_TIMD_CPTxDCR_TA1RST     = {.msk = 0x00002000U, .pos = 13};   /** @brief Timer A output 1 reset. */
  static const field32_t HRTIM_TIMD_CPTxDCR_TA1SET     = {.msk = 0x00001000U, .pos = 12};   /** @brief Timer A output 1 set. */
  static const field32_t HRTIM_TIMD_CPTxDCR_UDPCPT     = {.msk = 0x00000002U, .pos = 1};    /** @brief Update capture. */
  static const field32_t HRTIM_TIMD_CPTxDCR_SWCPT      = {.msk = 0x00000001U, .pos = 0};    /** @brief Software capture. */
  static const field32_t HRTIM_TIMD_OUTDR_DLYPRT       = {.msk = 0x00001C00U, .pos = 10};   /** @brief Delayed protection. */
  static const field32_t HRTIM_TIMD_OUTDR_DLYPRTEN     = {.msk = 0x00000200U, .pos = 9};    /** @brief Delayed protection enable. */
  static const field32_t HRTIM_TIMD_OUTDR_DTEN         = {.msk = 0x00000100U, .pos = 8};    /** @brief Deadtime enable. */
  static const field32_t HRTIM_TIMD_FLTDR_FLTLCK       = {.msk = 0x80000000U, .pos = 31};   /** @brief Fault sources lock. */

  /**** Enumerated HRTIM_TIMD Register Field Definitions ****/

  static field32_t const HRTIM_TIMD_TIMDCR_DELCMPx[5] = {
    [2] = {.msk = 0x00003000U, .pos = 12},   /** @brief Delayed CMP2 mode. */
    [4] = {.msk = 0x0000C000U, .pos = 14},   /** @brief Delayed CMP4 mode. */
  };

  static field32_t const HRTIM_TIMD_TIMDISR_OxSTAT[3] = {
    [1] = {.msk = 0x00040000U, .pos = 18},   /** @brief Output 1 state. */
    [2] = {.msk = 0x00080000U, .pos = 19},   /** @brief Output 2 state. */
  };

  static field32_t const HRTIM_TIMD_TIMDISR_RSTXx[3] = {
    [1] = {.msk = 0x00000400U, .pos = 10},   /** @brief Output 1 reset interrupt flag. */
    [2] = {.msk = 0x00001000U, .pos = 12},   /** @brief Output 2 reset interrupt flag. */
  };

  static field32_t const HRTIM_TIMD_TIMDISR_SETXx[3] = {
    [1] = {.msk = 0x00000200U, .pos = 9},    /** @brief Output 1 set interrupt flag. */
    [2] = {.msk = 0x00000800U, .pos = 11},   /** @brief Output 2 set interrupt flag. */
  };

  static field32_t const HRTIM_TIMD_TIMDISR_CPTx[3] = {
    [1] = {.msk = 0x00000080U, .pos = 7},   /** @brief Capture1 interrupt flag. */
    [2] = {.msk = 0x00000100U, .pos = 8},   /** @brief Capture2 interrupt flag. */
  };

  static field32_t const HRTIM_TIMD_TIMDISR_CMPx[5] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief Compare 1 interrupt flag. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief Compare 2 interrupt flag. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief Compare 3 interrupt flag. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief Compare 4 interrupt flag. */
  };

  static field32_t const HRTIM_TIMD_TIMDICR_RSTXxC[3] = {
    [1] = {.msk = 0x00000400U, .pos = 10},   /** @brief Output 1 reset flag clear. */
    [2] = {.msk = 0x00001000U, .pos = 12},   /** @brief Output 2 reset flag clear. */
  };

  static field32_t const HRTIM_TIMD_TIMDICR_SETxXC[3] = {
    [1] = {.msk = 0x00000200U, .pos = 9},    /** @brief Output 1 set flag clear. */
    [2] = {.msk = 0x00000800U, .pos = 11},   /** @brief Output 2 set flag clear. */
  };

  static field32_t const HRTIM_TIMD_TIMDICR_CPTxC[3] = {
    [1] = {.msk = 0x00000080U, .pos = 7},   /** @brief Capture1 interrupt flag clear. */
    [2] = {.msk = 0x00000100U, .pos = 8},   /** @brief Capture2 interrupt flag clear. */
  };

  static field32_t const HRTIM_TIMD_TIMDICR_CMPxC[5] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief Compare 1 interrupt flag clear. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief Compare 2 interrupt flag clear. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief Compare 3 interrupt flag clear. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief Compare 4 interrupt flag clear. */
  };

  static field32_t const HRTIM_TIMD_TIMDDIER5_RSTXxDE[3] = {
    [1] = {.msk = 0x04000000U, .pos = 26},   /** @brief RSTx1DE. */
    [2] = {.msk = 0x10000000U, .pos = 28},   /** @brief RSTx2DE. */
  };

  static field32_t const HRTIM_TIMD_TIMDDIER5_CPTxDE[3] = {
    [1] = {.msk = 0x00800000U, .pos = 23},   /** @brief CPT1DE. */
    [2] = {.msk = 0x01000000U, .pos = 24},   /** @brief CPT2DE. */
  };

  static field32_t const HRTIM_TIMD_TIMDDIER5_CMPxDE[5] = {
    [1] = {.msk = 0x00010000U, .pos = 16},   /** @brief CMP1DE. */
    [2] = {.msk = 0x00020000U, .pos = 17},   /** @brief CMP2DE. */
    [3] = {.msk = 0x00040000U, .pos = 18},   /** @brief CMP3DE. */
    [4] = {.msk = 0x00080000U, .pos = 19},   /** @brief CMP4DE. */
  };

  static field32_t const HRTIM_TIMD_TIMDDIER5_RSTXxIE[3] = {
    [1] = {.msk = 0x00000400U, .pos = 10},   /** @brief RSTx1IE. */
    [2] = {.msk = 0x00001000U, .pos = 12},   /** @brief RSTx2IE. */
  };

  static field32_t const HRTIM_TIMD_TIMDDIER5_CPTxIE[3] = {
    [1] = {.msk = 0x00000080U, .pos = 7},   /** @brief CPT1IE. */
    [2] = {.msk = 0x00000100U, .pos = 8},   /** @brief CPT2IE. */
  };

  static field32_t const HRTIM_TIMD_TIMDDIER5_CMPxIE[5] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief CMP1IE. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief CMP2IE. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief CMP3IE. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief CMP4IE. */
  };

  static field32_t const HRTIM_TIMD_SETDxR_EXTEVNTx[11] = {
    [1]  = {.msk = 0x00200000U, .pos = 21},   /** @brief External event 1. */
    [2]  = {.msk = 0x00400000U, .pos = 22},   /** @brief External event 2. */
    [3]  = {.msk = 0x00800000U, .pos = 23},   /** @brief External event 3. */
    [4]  = {.msk = 0x01000000U, .pos = 24},   /** @brief External event 4. */
    [5]  = {.msk = 0x02000000U, .pos = 25},   /** @brief External event 5. */
    [6]  = {.msk = 0x04000000U, .pos = 26},   /** @brief External event 6. */
    [7]  = {.msk = 0x08000000U, .pos = 27},   /** @brief External event 7. */
    [8]  = {.msk = 0x10000000U, .pos = 28},   /** @brief External event 8. */
    [9]  = {.msk = 0x20000000U, .pos = 29},   /** @brief External event 9. */
    [10] = {.msk = 0x40000000U, .pos = 30},   /** @brief External event 10. */
  };

  static field32_t const HRTIM_TIMD_SETDxR_TIMEVNTx[10] = {
    [1]  = {.msk = 0x00001000U, .pos = 12},   /** @brief Timer event 1. */
    [2]  = {.msk = 0x00002000U, .pos = 13},   /** @brief Timer event 2. */
    [3]  = {.msk = 0x00004000U, .pos = 14},   /** @brief Timer event 3. */
    [4]  = {.msk = 0x00008000U, .pos = 15},   /** @brief Timer event 4. */
    [5]  = {.msk = 0x00010000U, .pos = 16},   /** @brief Timer event 5. */
    [6]  = {.msk = 0x00020000U, .pos = 17},   /** @brief Timer event 6. */
    [7]  = {.msk = 0x00040000U, .pos = 18},   /** @brief Timer event 7. */
    [8]  = {.msk = 0x00080000U, .pos = 19},   /** @brief Timer event 8. */
    [9]  = {.msk = 0x00100000U, .pos = 20},   /** @brief Timer event 9. */
  };

  static field32_t const HRTIM_TIMD_SETDxR_MSTCMPx[5] = {
    [1] = {.msk = 0x00000100U, .pos = 8},    /** @brief Master compare 1. */
    [2] = {.msk = 0x00000200U, .pos = 9},    /** @brief Master compare 2. */
    [3] = {.msk = 0x00000400U, .pos = 10},   /** @brief Master compare 3. */
    [4] = {.msk = 0x00000800U, .pos = 11},   /** @brief Master compare 4. */
  };

  static field32_t const HRTIM_TIMD_EEFDRx_EExFLTR[6] = {
    [1] = {.msk = 0x0000001EU, .pos = 1},    /** @brief External event 1 filter. */
    [2] = {.msk = 0x00000780U, .pos = 7},    /** @brief External event 2 filter. */
    [3] = {.msk = 0x0001E000U, .pos = 13},   /** @brief External event 3 filter. */
    [4] = {.msk = 0x00780000U, .pos = 19},   /** @brief External event 4 filter. */
    [5] = {.msk = 0x1E000000U, .pos = 25},   /** @brief External event 5 filter. */
  };

  static field32_t const HRTIM_TIMD_EEFDRx_EExLTCH[6] = {
    [1] = {.msk = 0x00000001U, .pos = 0},    /** @brief External event 1 latch. */
    [2] = {.msk = 0x00000040U, .pos = 6},    /** @brief External event 2 latch. */
    [3] = {.msk = 0x00001000U, .pos = 12},   /** @brief External event 3 latch. */
    [4] = {.msk = 0x00040000U, .pos = 18},   /** @brief External event 4 latch. */
    [5] = {.msk = 0x01000000U, .pos = 24},   /** @brief External event 5 latch. */
  };

  static field32_t const HRTIM_TIMD_RSTDR_TIMECMPx[5] = {
    [1] = {.msk = 0x10000000U, .pos = 28},   /** @brief Timer E compare 1. */
    [2] = {.msk = 0x20000000U, .pos = 29},   /** @brief Timer E compare 2. */
    [4] = {.msk = 0x40000000U, .pos = 30},   /** @brief Timer E compare 4. */
  };

  static field32_t const HRTIM_TIMD_RSTDR_TIMCCMPx[5] = {
    [1] = {.msk = 0x02000000U, .pos = 25},   /** @brief Timer C compare 1. */
    [2] = {.msk = 0x04000000U, .pos = 26},   /** @brief Timer C compare 2. */
    [4] = {.msk = 0x08000000U, .pos = 27},   /** @brief Timer C compare 4. */
  };

  static field32_t const HRTIM_TIMD_RSTDR_TIMBCMPx[5] = {
    [1] = {.msk = 0x00400000U, .pos = 22},   /** @brief Timer B compare 1. */
    [2] = {.msk = 0x00800000U, .pos = 23},   /** @brief Timer B compare 2. */
    [4] = {.msk = 0x01000000U, .pos = 24},   /** @brief Timer B compare 4. */
  };

  static field32_t const HRTIM_TIMD_RSTDR_TIMACMPx[5] = {
    [1] = {.msk = 0x00080000U, .pos = 19},   /** @brief Timer A compare 1. */
    [2] = {.msk = 0x00100000U, .pos = 20},   /** @brief Timer A compare 2. */
    [4] = {.msk = 0x00200000U, .pos = 21},   /** @brief Timer A compare 4. */
  };

  static field32_t const HRTIM_TIMD_CPTxDCR_TECMPx[3] = {
    [1] = {.msk = 0x40000000U, .pos = 30},   /** @brief Timer E compare 1. */
    [2] = {.msk = 0x80000000U, .pos = 31},   /** @brief Timer E compare 2. */
  };

  static field32_t const HRTIM_TIMD_CPTxDCR_TCCMPx[3] = {
    [1] = {.msk = 0x00400000U, .pos = 22},   /** @brief Timer C compare 1. */
    [2] = {.msk = 0x00800000U, .pos = 23},   /** @brief Timer C compare 2. */
  };

  static field32_t const HRTIM_TIMD_CPTxDCR_TBCMPx[3] = {
    [1] = {.msk = 0x00040000U, .pos = 18},   /** @brief Timer B compare 1. */
    [2] = {.msk = 0x00080000U, .pos = 19},   /** @brief Timer B compare 2. */
  };

  static field32_t const HRTIM_TIMD_CPTxDCR_TACMPx[3] = {
    [1] = {.msk = 0x00004000U, .pos = 14},   /** @brief Timer A compare 1. */
    [2] = {.msk = 0x00008000U, .pos = 15},   /** @brief Timer A compare 2. */
  };

  static field32_t const HRTIM_TIMD_CPTxDCR_EXEVxCPT[11] = {
    [1]  = {.msk = 0x00000004U, .pos = 2},    /** @brief External event 1 capture. */
    [2]  = {.msk = 0x00000008U, .pos = 3},    /** @brief External event 2 capture. */
    [3]  = {.msk = 0x00000010U, .pos = 4},    /** @brief External event 3 capture. */
    [4]  = {.msk = 0x00000020U, .pos = 5},    /** @brief External event 4 capture. */
    [5]  = {.msk = 0x00000040U, .pos = 6},    /** @brief External event 5 capture. */
    [6]  = {.msk = 0x00000080U, .pos = 7},    /** @brief External event 6 capture. */
    [7]  = {.msk = 0x00000100U, .pos = 8},    /** @brief External event 7 capture. */
    [8]  = {.msk = 0x00000200U, .pos = 9},    /** @brief External event 8 capture. */
    [9]  = {.msk = 0x00000400U, .pos = 10},   /** @brief External event 9 capture. */
    [10] = {.msk = 0x00000800U, .pos = 11},   /** @brief External event 10 capture. */
  };

  static field32_t const HRTIM_TIMD_OUTDR_DIDLx[3] = {
    [1] = {.msk = 0x00000080U, .pos = 7},    /** @brief Output 1 deadtime upon burst mode idle entry. */
    [2] = {.msk = 0x00800000U, .pos = 23},   /** @brief Output 2 deadtime upon burst mode idle entry. */
  };

  static field32_t const HRTIM_TIMD_OUTDR_CHPx[3] = {
    [1] = {.msk = 0x00000040U, .pos = 6},    /** @brief Output 1 chopper enable. */
    [2] = {.msk = 0x00400000U, .pos = 22},   /** @brief Output 2 chopper enable. */
  };

  static field32_t const HRTIM_TIMD_OUTDR_FAULTx[3] = {
    [1] = {.msk = 0x00000030U, .pos = 4},    /** @brief Output 1 fault state. */
    [2] = {.msk = 0x00300000U, .pos = 20},   /** @brief Output 2 fault state. */
  };

  static field32_t const HRTIM_TIMD_OUTDR_IDLESx[3] = {
    [1] = {.msk = 0x00000008U, .pos = 3},    /** @brief Output 1 idle state. */
    [2] = {.msk = 0x00080000U, .pos = 19},   /** @brief Output 2 idle state. */
  };

  static field32_t const HRTIM_TIMD_OUTDR_IDLEMx[3] = {
    [1] = {.msk = 0x00000004U, .pos = 2},    /** @brief Output 1 idle mode. */
    [2] = {.msk = 0x00040000U, .pos = 18},   /** @brief Output 2 idle mode. */
  };

  static field32_t const HRTIM_TIMD_OUTDR_POLx[3] = {
    [1] = {.msk = 0x00000002U, .pos = 1},    /** @brief Output 1 polarity. */
    [2] = {.msk = 0x00020000U, .pos = 17},   /** @brief Output 2 polarity. */
  };

  static field32_t const HRTIM_TIMD_FLTDR_FLTxEN[6] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief Fault 1 enable. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief Fault 2 enable. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief Fault 3 enable. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief Fault 4 enable. */
    [5] = {.msk = 0x00000010U, .pos = 4},   /** @brief Fault 5 enable. */
  };

  /************************************************************************************************
   * HRTIM_TIME Definitions
   ************************************************************************************************/

  /**** HRTIM_TIME Register Definitions ****/

  static const rw_reg32_t HRTIM_TIME_TIMECR    = (rw_reg32_t)0x40017680U;   /** @brief Timerx control register. */
  static const ro_reg32_t HRTIM_TIME_TIMEISR   = (ro_reg32_t)0x40017684U;   /** @brief Timerx interrupt status register. */
  static const rw_reg32_t HRTIM_TIME_TIMEICR   = (rw_reg32_t)0x40017688U;   /** @brief Timerx interrupt clear register. */
  static const rw_reg32_t HRTIM_TIME_TIMEDIER5 = (rw_reg32_t)0x4001768CU;   /** @brief TIMxDIER5. */
  static const rw_reg32_t HRTIM_TIME_CNTER     = (rw_reg32_t)0x40017690U;   /** @brief Timerx counter register. */
  static const rw_reg32_t HRTIM_TIME_PERER     = (rw_reg32_t)0x40017694U;   /** @brief Timerx period register. */
  static const rw_reg32_t HRTIM_TIME_REPER     = (rw_reg32_t)0x40017698U;   /** @brief Timerx repetition register. */
  static const rw_reg32_t HRTIM_TIME_CMP1CER   = (rw_reg32_t)0x400176A0U;   /** @brief Timerx compare 1 compound register. */
  static const rw_reg32_t HRTIM_TIME_DTER      = (rw_reg32_t)0x400176B8U;   /** @brief Timerx deadtime register. */
  static const rw_reg32_t HRTIM_TIME_RSTER     = (rw_reg32_t)0x400176D4U;   /** @brief TimerA reset register. */
  static const rw_reg32_t HRTIM_TIME_CHPER     = (rw_reg32_t)0x400176D8U;   /** @brief Timerx chopper register. */
  static const rw_reg32_t HRTIM_TIME_OUTER     = (rw_reg32_t)0x400176E4U;   /** @brief Timerx output register. */
  static const rw_reg32_t HRTIM_TIME_FLTER     = (rw_reg32_t)0x400176E8U;   /** @brief Timerx fault register. */

  /**** Enumerated HRTIM_TIME Register Definitions ****/

  static const rw_reg32_t HRTIM_TIME_CMPxER[5] = {
    [1] = (rw_reg32_t)0x4001769CU,   /** @brief Timerx compare 1 register. */
    [2] = (rw_reg32_t)0x400176A4U,   /** @brief Timerx compare 2 register. */
    [3] = (rw_reg32_t)0x400176A8U,   /** @brief Timerx compare 3 register. */
    [4] = (rw_reg32_t)0x400176ACU,   /** @brief Timerx compare 4 register. */
  };

  static const ro_reg32_t HRTIM_TIME_CPTxER[3] = {
    [1] = (ro_reg32_t)0x400176B0U,   /** @brief Timerx capture 1 register. */
    [2] = (ro_reg32_t)0x400176B4U,   /** @brief Timerx capture 2 register. */
  };

  static const rw_reg32_t HRTIM_TIME_SETExR[3] = {
    [1] = (rw_reg32_t)0x400176BCU,   /** @brief Timerx output1 set register. */
    [2] = (rw_reg32_t)0x400176C4U,   /** @brief Timerx output2 set register. */
  };

  static const rw_reg32_t HRTIM_TIME_RSTExR[3] = {
    [1] = (rw_reg32_t)0x400176C0U,   /** @brief Timerx output1 reset register. */
    [2] = (rw_reg32_t)0x400176C8U,   /** @brief Timerx output2 reset register. */
  };

  static const rw_reg32_t HRTIM_TIME_EEFERx[3] = {
    [1] = (rw_reg32_t)0x400176CCU,   /** @brief Timerx external event filtering register 1. */
    [2] = (rw_reg32_t)0x400176D0U,   /** @brief Timerx external event filtering register 2. */
  };

  static const rw_reg32_t HRTIM_TIME_CPTxECR[3] = {
    [1] = (rw_reg32_t)0x400176DCU,   /** @brief Timerx capture 2 control register. */
    [2] = (rw_reg32_t)0x400176E0U,   /** @brief CPT2xCR. */
  };

  /**** HRTIM_TIME Register Field Definitions ****/

  static const field32_t HRTIM_TIME_TIMECR_UPDGAT      = {.msk = 0xF0000000U, .pos = 28};   /** @brief Update gating. */
  static const field32_t HRTIM_TIME_TIMECR_PREEN       = {.msk = 0x08000000U, .pos = 27};   /** @brief Preload enable. */
  static const field32_t HRTIM_TIME_TIMECR_DACSYNC     = {.msk = 0x06000000U, .pos = 25};   /** @brief AC synchronization. */
  static const field32_t HRTIM_TIME_TIMECR_MSTU        = {.msk = 0x01000000U, .pos = 24};   /** @brief Master timer update. */
  static const field32_t HRTIM_TIME_TIMECR_TEU         = {.msk = 0x00800000U, .pos = 23};   /** @brief TEU. */
  static const field32_t HRTIM_TIME_TIMECR_TDU         = {.msk = 0x00400000U, .pos = 22};   /** @brief TDU. */
  static const field32_t HRTIM_TIME_TIMECR_TCU         = {.msk = 0x00200000U, .pos = 21};   /** @brief TCU. */
  static const field32_t HRTIM_TIME_TIMECR_TBU         = {.msk = 0x00100000U, .pos = 20};   /** @brief TBU. */
  static const field32_t HRTIM_TIME_TIMECR_TXRSTU      = {.msk = 0x00040000U, .pos = 18};   /** @brief Timerx reset update. */
  static const field32_t HRTIM_TIME_TIMECR_TXREPU      = {.msk = 0x00020000U, .pos = 17};   /** @brief Timer x repetition update. */
  static const field32_t HRTIM_TIME_TIMECR_SYNCSTRTX   = {.msk = 0x00000800U, .pos = 11};   /** @brief Synchronization starts timer x. */
  static const field32_t HRTIM_TIME_TIMECR_SYNCRSTX    = {.msk = 0x00000400U, .pos = 10};   /** @brief Synchronization resets timer x. */
  static const field32_t HRTIM_TIME_TIMECR_PSHPLL      = {.msk = 0x00000040U, .pos = 6};    /** @brief Push-Pull mode enable. */
  static const field32_t HRTIM_TIME_TIMECR_HALF        = {.msk = 0x00000020U, .pos = 5};    /** @brief Half mode enable. */
  static const field32_t HRTIM_TIME_TIMECR_RETRIG      = {.msk = 0x00000010U, .pos = 4};    /** @brief Re-triggerable mode. */
  static const field32_t HRTIM_TIME_TIMECR_CONT        = {.msk = 0x00000008U, .pos = 3};    /** @brief Continuous mode. */
  static const field32_t HRTIM_TIME_TIMECR_CK_PSCX     = {.msk = 0x00000007U, .pos = 0};    /** @brief HRTIM timer x clock prescaler. */
  static const field32_t HRTIM_TIME_TIMEISR_IPPSTAT    = {.msk = 0x00020000U, .pos = 17};   /** @brief Idle push pull status. */
  static const field32_t HRTIM_TIME_TIMEISR_CPPSTAT    = {.msk = 0x00010000U, .pos = 16};   /** @brief Current push pull status. */
  static const field32_t HRTIM_TIME_TIMEISR_DLYPRT     = {.msk = 0x00004000U, .pos = 14};   /** @brief Delayed protection flag. */
  static const field32_t HRTIM_TIME_TIMEISR_RST        = {.msk = 0x00002000U, .pos = 13};   /** @brief Reset interrupt flag. */
  static const field32_t HRTIM_TIME_TIMEISR_UPD        = {.msk = 0x00000040U, .pos = 6};    /** @brief Update interrupt flag. */
  static const field32_t HRTIM_TIME_TIMEISR_REP        = {.msk = 0x00000010U, .pos = 4};    /** @brief Repetition interrupt flag. */
  static const field32_t HRTIM_TIME_TIMEICR_DLYPRTC    = {.msk = 0x00004000U, .pos = 14};   /** @brief Delayed protection flag clear. */
  static const field32_t HRTIM_TIME_TIMEICR_RSTC       = {.msk = 0x00002000U, .pos = 13};   /** @brief Reset interrupt flag clear. */
  static const field32_t HRTIM_TIME_TIMEICR_UPDC       = {.msk = 0x00000040U, .pos = 6};    /** @brief Update interrupt flag clear. */
  static const field32_t HRTIM_TIME_TIMEICR_REPC       = {.msk = 0x00000010U, .pos = 4};    /** @brief Repetition interrupt flag clear. */
  static const field32_t HRTIM_TIME_TIMEDIER5_DLYPRTDE = {.msk = 0x40000000U, .pos = 30};   /** @brief DLYPRTDE. */
  static const field32_t HRTIM_TIME_TIMEDIER5_RSTDE    = {.msk = 0x20000000U, .pos = 29};   /** @brief RSTDE. */
  static const field32_t HRTIM_TIME_TIMEDIER5_SETX2DE  = {.msk = 0x08000000U, .pos = 27};   /** @brief SETx2DE. */
  static const field32_t HRTIM_TIME_TIMEDIER5_SET1XDE  = {.msk = 0x02000000U, .pos = 25};   /** @brief SET1xDE. */
  static const field32_t HRTIM_TIME_TIMEDIER5_UPDDE    = {.msk = 0x00400000U, .pos = 22};   /** @brief UPDDE. */
  static const field32_t HRTIM_TIME_TIMEDIER5_REPDE    = {.msk = 0x00100000U, .pos = 20};   /** @brief REPDE. */
  static const field32_t HRTIM_TIME_TIMEDIER5_DLYPRTIE = {.msk = 0x00004000U, .pos = 14};   /** @brief DLYPRTIE. */
  static const field32_t HRTIM_TIME_TIMEDIER5_RSTIE    = {.msk = 0x00002000U, .pos = 13};   /** @brief RSTIE. */
  static const field32_t HRTIM_TIME_TIMEDIER5_SETX2IE  = {.msk = 0x00000800U, .pos = 11};   /** @brief SETx2IE. */
  static const field32_t HRTIM_TIME_TIMEDIER5_SET1XIE  = {.msk = 0x00000200U, .pos = 9};    /** @brief SET1xIE. */
  static const field32_t HRTIM_TIME_TIMEDIER5_UPDIE    = {.msk = 0x00000040U, .pos = 6};    /** @brief UPDIE. */
  static const field32_t HRTIM_TIME_TIMEDIER5_REPIE    = {.msk = 0x00000010U, .pos = 4};    /** @brief REPIE. */
  static const field32_t HRTIM_TIME_CNTER_CNTX         = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timerx counter value. */
  static const field32_t HRTIM_TIME_PERER_PERX         = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timerx period value. */
  static const field32_t HRTIM_TIME_REPER_REPX         = {.msk = 0x000000FFU, .pos = 0};    /** @brief Timerx repetition counter value. */
  static const field32_t HRTIM_TIME_CMPxER_CMP1X       = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timerx compare 1 value. */
  static const field32_t HRTIM_TIME_CMP1CER_REPX       = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Timerx repetition value (aliased from hrtim_repx register). */
  static const field32_t HRTIM_TIME_CMP1CER_CMP1X      = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timerx compare 1 value. */
  static const field32_t HRTIM_TIME_CPTxER_CPT1X       = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timerx capture 1 value. */
  static const field32_t HRTIM_TIME_DTER_DTFLKX        = {.msk = 0x80000000U, .pos = 31};   /** @brief Deadtime falling lock. */
  static const field32_t HRTIM_TIME_DTER_DTFSLKX       = {.msk = 0x40000000U, .pos = 30};   /** @brief Deadtime falling sign lock. */
  static const field32_t HRTIM_TIME_DTER_SDTFX         = {.msk = 0x02000000U, .pos = 25};   /** @brief Sign deadtime falling value. */
  static const field32_t HRTIM_TIME_DTER_DTFX          = {.msk = 0x01FF0000U, .pos = 16};   /** @brief Deadtime falling value. */
  static const field32_t HRTIM_TIME_DTER_DTRLKX        = {.msk = 0x00008000U, .pos = 15};   /** @brief Deadtime rising lock. */
  static const field32_t HRTIM_TIME_DTER_DTRSLKX       = {.msk = 0x00004000U, .pos = 14};   /** @brief Deadtime rising sign lock. */
  static const field32_t HRTIM_TIME_DTER_DTPRSC        = {.msk = 0x00001C00U, .pos = 10};   /** @brief Deadtime prescaler. */
  static const field32_t HRTIM_TIME_DTER_SDTRX         = {.msk = 0x00000200U, .pos = 9};    /** @brief Sign deadtime rising value. */
  static const field32_t HRTIM_TIME_DTER_DTRX          = {.msk = 0x000001FFU, .pos = 0};    /** @brief Deadtime rising value. */
  static const field32_t HRTIM_TIME_SETExR_UPDATE      = {.msk = 0x80000000U, .pos = 31};   /** @brief Registers update (transfer preload to active). */
  static const field32_t HRTIM_TIME_SETExR_MSTPER      = {.msk = 0x00000080U, .pos = 7};    /** @brief Master period. */
  static const field32_t HRTIM_TIME_SETExR_PER         = {.msk = 0x00000004U, .pos = 2};    /** @brief Timer A period. */
  static const field32_t HRTIM_TIME_SETExR_RESYNC      = {.msk = 0x00000002U, .pos = 1};    /** @brief Timer A resynchronizaton. */
  static const field32_t HRTIM_TIME_SETExR_SST         = {.msk = 0x00000001U, .pos = 0};    /** @brief Software set trigger. */
  static const field32_t HRTIM_TIME_RSTExR_UPDATE      = {.msk = 0x80000000U, .pos = 31};   /** @brief UPDATE. */
  static const field32_t HRTIM_TIME_RSTExR_MSTPER      = {.msk = 0x00000080U, .pos = 7};    /** @brief MSTPER. */
  static const field32_t HRTIM_TIME_RSTExR_PER         = {.msk = 0x00000004U, .pos = 2};    /** @brief PER. */
  static const field32_t HRTIM_TIME_RSTExR_RESYNC      = {.msk = 0x00000002U, .pos = 1};    /** @brief RESYNC. */
  static const field32_t HRTIM_TIME_RSTExR_SRT         = {.msk = 0x00000001U, .pos = 0};    /** @brief SRT. */
  static const field32_t HRTIM_TIME_RSTER_MSTPER       = {.msk = 0x00000010U, .pos = 4};    /** @brief Master timer period. */
  static const field32_t HRTIM_TIME_RSTER_UPDT         = {.msk = 0x00000002U, .pos = 1};    /** @brief Timer A update reset. */
  static const field32_t HRTIM_TIME_CHPER_STRTPW       = {.msk = 0x00000780U, .pos = 7};    /** @brief STRTPW. */
  static const field32_t HRTIM_TIME_CHPER_CHPDTY       = {.msk = 0x00000070U, .pos = 4};    /** @brief Timerx chopper duty cycle value. */
  static const field32_t HRTIM_TIME_CHPER_CHPFRQ       = {.msk = 0x0000000FU, .pos = 0};    /** @brief Timerx carrier frequency value. */
  static const field32_t HRTIM_TIME_CPTxECR_TD1RST     = {.msk = 0x02000000U, .pos = 25};   /** @brief Timer D output 1 reset. */
  static const field32_t HRTIM_TIME_CPTxECR_TD1SET     = {.msk = 0x01000000U, .pos = 24};   /** @brief Timer D output 1 set. */
  static const field32_t HRTIM_TIME_CPTxECR_TC1RST     = {.msk = 0x00200000U, .pos = 21};   /** @brief Timer C output 1 reset. */
  static const field32_t HRTIM_TIME_CPTxECR_TC1SET     = {.msk = 0x00100000U, .pos = 20};   /** @brief Timer C output 1 set. */
  static const field32_t HRTIM_TIME_CPTxECR_TB1RST     = {.msk = 0x00020000U, .pos = 17};   /** @brief Timer B output 1 reset. */
  static const field32_t HRTIM_TIME_CPTxECR_TB1SET     = {.msk = 0x00010000U, .pos = 16};   /** @brief Timer B output 1 set. */
  static const field32_t HRTIM_TIME_CPTxECR_TA1RST     = {.msk = 0x00002000U, .pos = 13};   /** @brief Timer A output 1 reset. */
  static const field32_t HRTIM_TIME_CPTxECR_TA1SET     = {.msk = 0x00001000U, .pos = 12};   /** @brief Timer A output 1 set. */
  static const field32_t HRTIM_TIME_CPTxECR_UDPCPT     = {.msk = 0x00000002U, .pos = 1};    /** @brief Update capture. */
  static const field32_t HRTIM_TIME_CPTxECR_SWCPT      = {.msk = 0x00000001U, .pos = 0};    /** @brief Software capture. */
  static const field32_t HRTIM_TIME_OUTER_DLYPRT       = {.msk = 0x00001C00U, .pos = 10};   /** @brief Delayed protection. */
  static const field32_t HRTIM_TIME_OUTER_DLYPRTEN     = {.msk = 0x00000200U, .pos = 9};    /** @brief Delayed protection enable. */
  static const field32_t HRTIM_TIME_OUTER_DTEN         = {.msk = 0x00000100U, .pos = 8};    /** @brief Deadtime enable. */
  static const field32_t HRTIM_TIME_FLTER_FLTLCK       = {.msk = 0x80000000U, .pos = 31};   /** @brief Fault sources lock. */

  /**** Enumerated HRTIM_TIME Register Field Definitions ****/

  static field32_t const HRTIM_TIME_TIMECR_DELCMPx[5] = {
    [2] = {.msk = 0x00003000U, .pos = 12},   /** @brief Delayed CMP2 mode. */
    [4] = {.msk = 0x0000C000U, .pos = 14},   /** @brief Delayed CMP4 mode. */
  };

  static field32_t const HRTIM_TIME_TIMEISR_OxSTAT[3] = {
    [1] = {.msk = 0x00040000U, .pos = 18},   /** @brief Output 1 state. */
    [2] = {.msk = 0x00080000U, .pos = 19},   /** @brief Output 2 state. */
  };

  static field32_t const HRTIM_TIME_TIMEISR_RSTXx[3] = {
    [1] = {.msk = 0x00000400U, .pos = 10},   /** @brief Output 1 reset interrupt flag. */
    [2] = {.msk = 0x00001000U, .pos = 12},   /** @brief Output 2 reset interrupt flag. */
  };

  static field32_t const HRTIM_TIME_TIMEISR_SETXx[3] = {
    [1] = {.msk = 0x00000200U, .pos = 9},    /** @brief Output 1 set interrupt flag. */
    [2] = {.msk = 0x00000800U, .pos = 11},   /** @brief Output 2 set interrupt flag. */
  };

  static field32_t const HRTIM_TIME_TIMEISR_CPTx[3] = {
    [1] = {.msk = 0x00000080U, .pos = 7},   /** @brief Capture1 interrupt flag. */
    [2] = {.msk = 0x00000100U, .pos = 8},   /** @brief Capture2 interrupt flag. */
  };

  static field32_t const HRTIM_TIME_TIMEISR_CMPx[5] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief Compare 1 interrupt flag. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief Compare 2 interrupt flag. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief Compare 3 interrupt flag. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief Compare 4 interrupt flag. */
  };

  static field32_t const HRTIM_TIME_TIMEICR_RSTXxC[3] = {
    [1] = {.msk = 0x00000400U, .pos = 10},   /** @brief Output 1 reset flag clear. */
    [2] = {.msk = 0x00001000U, .pos = 12},   /** @brief Output 2 reset flag clear. */
  };

  static field32_t const HRTIM_TIME_TIMEICR_SETxXC[3] = {
    [1] = {.msk = 0x00000200U, .pos = 9},    /** @brief Output 1 set flag clear. */
    [2] = {.msk = 0x00000800U, .pos = 11},   /** @brief Output 2 set flag clear. */
  };

  static field32_t const HRTIM_TIME_TIMEICR_CPTxC[3] = {
    [1] = {.msk = 0x00000080U, .pos = 7},   /** @brief Capture1 interrupt flag clear. */
    [2] = {.msk = 0x00000100U, .pos = 8},   /** @brief Capture2 interrupt flag clear. */
  };

  static field32_t const HRTIM_TIME_TIMEICR_CMPxC[5] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief Compare 1 interrupt flag clear. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief Compare 2 interrupt flag clear. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief Compare 3 interrupt flag clear. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief Compare 4 interrupt flag clear. */
  };

  static field32_t const HRTIM_TIME_TIMEDIER5_RSTXxDE[3] = {
    [1] = {.msk = 0x04000000U, .pos = 26},   /** @brief RSTx1DE. */
    [2] = {.msk = 0x10000000U, .pos = 28},   /** @brief RSTx2DE. */
  };

  static field32_t const HRTIM_TIME_TIMEDIER5_CPTxDE[3] = {
    [1] = {.msk = 0x00800000U, .pos = 23},   /** @brief CPT1DE. */
    [2] = {.msk = 0x01000000U, .pos = 24},   /** @brief CPT2DE. */
  };

  static field32_t const HRTIM_TIME_TIMEDIER5_CMPxDE[5] = {
    [1] = {.msk = 0x00010000U, .pos = 16},   /** @brief CMP1DE. */
    [2] = {.msk = 0x00020000U, .pos = 17},   /** @brief CMP2DE. */
    [3] = {.msk = 0x00040000U, .pos = 18},   /** @brief CMP3DE. */
    [4] = {.msk = 0x00080000U, .pos = 19},   /** @brief CMP4DE. */
  };

  static field32_t const HRTIM_TIME_TIMEDIER5_RSTXxIE[3] = {
    [1] = {.msk = 0x00000400U, .pos = 10},   /** @brief RSTx1IE. */
    [2] = {.msk = 0x00001000U, .pos = 12},   /** @brief RSTx2IE. */
  };

  static field32_t const HRTIM_TIME_TIMEDIER5_CPTxIE[3] = {
    [1] = {.msk = 0x00000080U, .pos = 7},   /** @brief CPT1IE. */
    [2] = {.msk = 0x00000100U, .pos = 8},   /** @brief CPT2IE. */
  };

  static field32_t const HRTIM_TIME_TIMEDIER5_CMPxIE[5] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief CMP1IE. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief CMP2IE. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief CMP3IE. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief CMP4IE. */
  };

  static field32_t const HRTIM_TIME_SETExR_EXTEVNTx[11] = {
    [1]  = {.msk = 0x00200000U, .pos = 21},   /** @brief External event 1. */
    [2]  = {.msk = 0x00400000U, .pos = 22},   /** @brief External event 2. */
    [3]  = {.msk = 0x00800000U, .pos = 23},   /** @brief External event 3. */
    [4]  = {.msk = 0x01000000U, .pos = 24},   /** @brief External event 4. */
    [5]  = {.msk = 0x02000000U, .pos = 25},   /** @brief External event 5. */
    [6]  = {.msk = 0x04000000U, .pos = 26},   /** @brief External event 6. */
    [7]  = {.msk = 0x08000000U, .pos = 27},   /** @brief External event 7. */
    [8]  = {.msk = 0x10000000U, .pos = 28},   /** @brief External event 8. */
    [9]  = {.msk = 0x20000000U, .pos = 29},   /** @brief External event 9. */
    [10] = {.msk = 0x40000000U, .pos = 30},   /** @brief External event 10. */
  };

  static field32_t const HRTIM_TIME_SETExR_TIMEVNTx[10] = {
    [1]  = {.msk = 0x00001000U, .pos = 12},   /** @brief Timer event 1. */
    [2]  = {.msk = 0x00002000U, .pos = 13},   /** @brief Timer event 2. */
    [3]  = {.msk = 0x00004000U, .pos = 14},   /** @brief Timer event 3. */
    [4]  = {.msk = 0x00008000U, .pos = 15},   /** @brief Timer event 4. */
    [5]  = {.msk = 0x00010000U, .pos = 16},   /** @brief Timer event 5. */
    [6]  = {.msk = 0x00020000U, .pos = 17},   /** @brief Timer event 6. */
    [7]  = {.msk = 0x00040000U, .pos = 18},   /** @brief Timer event 7. */
    [8]  = {.msk = 0x00080000U, .pos = 19},   /** @brief Timer event 8. */
    [9]  = {.msk = 0x00100000U, .pos = 20},   /** @brief Timer event 9. */
  };

  static field32_t const HRTIM_TIME_SETExR_MSTCMPx[5] = {
    [1] = {.msk = 0x00000100U, .pos = 8},    /** @brief Master compare 1. */
    [2] = {.msk = 0x00000200U, .pos = 9},    /** @brief Master compare 2. */
    [3] = {.msk = 0x00000400U, .pos = 10},   /** @brief Master compare 3. */
    [4] = {.msk = 0x00000800U, .pos = 11},   /** @brief Master compare 4. */
  };

  static field32_t const HRTIM_TIME_EEFERx_EExFLTR[6] = {
    [1] = {.msk = 0x0000001EU, .pos = 1},    /** @brief External event 1 filter. */
    [2] = {.msk = 0x00000780U, .pos = 7},    /** @brief External event 2 filter. */
    [3] = {.msk = 0x0001E000U, .pos = 13},   /** @brief External event 3 filter. */
    [4] = {.msk = 0x00780000U, .pos = 19},   /** @brief External event 4 filter. */
    [5] = {.msk = 0x1E000000U, .pos = 25},   /** @brief External event 5 filter. */
  };

  static field32_t const HRTIM_TIME_EEFERx_EExLTCH[6] = {
    [1] = {.msk = 0x00000001U, .pos = 0},    /** @brief External event 1 latch. */
    [2] = {.msk = 0x00000040U, .pos = 6},    /** @brief External event 2 latch. */
    [3] = {.msk = 0x00001000U, .pos = 12},   /** @brief External event 3 latch. */
    [4] = {.msk = 0x00040000U, .pos = 18},   /** @brief External event 4 latch. */
    [5] = {.msk = 0x01000000U, .pos = 24},   /** @brief External event 5 latch. */
  };

  static field32_t const HRTIM_TIME_RSTER_TIMDCMPx[5] = {
    [1] = {.msk = 0x10000000U, .pos = 28},   /** @brief Timer D compare 1. */
    [2] = {.msk = 0x20000000U, .pos = 29},   /** @brief Timer D compare 2. */
    [4] = {.msk = 0x40000000U, .pos = 30},   /** @brief Timer D compare 4. */
  };

  static field32_t const HRTIM_TIME_RSTER_TIMCCMPx[5] = {
    [1] = {.msk = 0x02000000U, .pos = 25},   /** @brief Timer C compare 1. */
    [2] = {.msk = 0x04000000U, .pos = 26},   /** @brief Timer C compare 2. */
    [4] = {.msk = 0x08000000U, .pos = 27},   /** @brief Timer C compare 4. */
  };

  static field32_t const HRTIM_TIME_RSTER_TIMBCMPx[5] = {
    [1] = {.msk = 0x00400000U, .pos = 22},   /** @brief Timer B compare 1. */
    [2] = {.msk = 0x00800000U, .pos = 23},   /** @brief Timer B compare 2. */
    [4] = {.msk = 0x01000000U, .pos = 24},   /** @brief Timer B compare 4. */
  };

  static field32_t const HRTIM_TIME_RSTER_TIMACMPx[5] = {
    [1] = {.msk = 0x00080000U, .pos = 19},   /** @brief Timer A compare 1. */
    [2] = {.msk = 0x00100000U, .pos = 20},   /** @brief Timer A compare 2. */
    [4] = {.msk = 0x00200000U, .pos = 21},   /** @brief Timer A compare 4. */
  };

  static field32_t const HRTIM_TIME_CPTxECR_TDCMPx[3] = {
    [1] = {.msk = 0x04000000U, .pos = 26},   /** @brief Timer D compare 1. */
    [2] = {.msk = 0x08000000U, .pos = 27},   /** @brief Timer D compare 2. */
  };

  static field32_t const HRTIM_TIME_CPTxECR_TCCMPx[3] = {
    [1] = {.msk = 0x00400000U, .pos = 22},   /** @brief Timer C compare 1. */
    [2] = {.msk = 0x00800000U, .pos = 23},   /** @brief Timer C compare 2. */
  };

  static field32_t const HRTIM_TIME_CPTxECR_TBCMPx[3] = {
    [1] = {.msk = 0x00040000U, .pos = 18},   /** @brief Timer B compare 1. */
    [2] = {.msk = 0x00080000U, .pos = 19},   /** @brief Timer B compare 2. */
  };

  static field32_t const HRTIM_TIME_CPTxECR_TACMPx[3] = {
    [1] = {.msk = 0x00004000U, .pos = 14},   /** @brief Timer A compare 1. */
    [2] = {.msk = 0x00008000U, .pos = 15},   /** @brief Timer A compare 2. */
  };

  static field32_t const HRTIM_TIME_CPTxECR_EXEVxCPT[11] = {
    [1]  = {.msk = 0x00000004U, .pos = 2},    /** @brief External event 1 capture. */
    [2]  = {.msk = 0x00000008U, .pos = 3},    /** @brief External event 2 capture. */
    [3]  = {.msk = 0x00000010U, .pos = 4},    /** @brief External event 3 capture. */
    [4]  = {.msk = 0x00000020U, .pos = 5},    /** @brief External event 4 capture. */
    [5]  = {.msk = 0x00000040U, .pos = 6},    /** @brief External event 5 capture. */
    [6]  = {.msk = 0x00000080U, .pos = 7},    /** @brief External event 6 capture. */
    [7]  = {.msk = 0x00000100U, .pos = 8},    /** @brief External event 7 capture. */
    [8]  = {.msk = 0x00000200U, .pos = 9},    /** @brief External event 8 capture. */
    [9]  = {.msk = 0x00000400U, .pos = 10},   /** @brief External event 9 capture. */
    [10] = {.msk = 0x00000800U, .pos = 11},   /** @brief External event 10 capture. */
  };

  static field32_t const HRTIM_TIME_OUTER_DIDLx[3] = {
    [1] = {.msk = 0x00000080U, .pos = 7},    /** @brief Output 1 deadtime upon burst mode idle entry. */
    [2] = {.msk = 0x00800000U, .pos = 23},   /** @brief Output 2 deadtime upon burst mode idle entry. */
  };

  static field32_t const HRTIM_TIME_OUTER_CHPx[3] = {
    [1] = {.msk = 0x00000040U, .pos = 6},    /** @brief Output 1 chopper enable. */
    [2] = {.msk = 0x00400000U, .pos = 22},   /** @brief Output 2 chopper enable. */
  };

  static field32_t const HRTIM_TIME_OUTER_FAULTx[3] = {
    [1] = {.msk = 0x00000030U, .pos = 4},    /** @brief Output 1 fault state. */
    [2] = {.msk = 0x00300000U, .pos = 20},   /** @brief Output 2 fault state. */
  };

  static field32_t const HRTIM_TIME_OUTER_IDLESx[3] = {
    [1] = {.msk = 0x00000008U, .pos = 3},    /** @brief Output 1 idle state. */
    [2] = {.msk = 0x00080000U, .pos = 19},   /** @brief Output 2 idle state. */
  };

  static field32_t const HRTIM_TIME_OUTER_IDLEMx[3] = {
    [1] = {.msk = 0x00000004U, .pos = 2},    /** @brief Output 1 idle mode. */
    [2] = {.msk = 0x00040000U, .pos = 18},   /** @brief Output 2 idle mode. */
  };

  static field32_t const HRTIM_TIME_OUTER_POLx[3] = {
    [1] = {.msk = 0x00000002U, .pos = 1},    /** @brief Output 1 polarity. */
    [2] = {.msk = 0x00020000U, .pos = 17},   /** @brief Output 2 polarity. */
  };

  static field32_t const HRTIM_TIME_FLTER_FLTxEN[6] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief Fault 1 enable. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief Fault 2 enable. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief Fault 3 enable. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief Fault 4 enable. */
    [5] = {.msk = 0x00000010U, .pos = 4},   /** @brief Fault 5 enable. */
  };

  /************************************************************************************************
   * HRTIM_COMMON Definitions
   ************************************************************************************************/

  /**** HRTIM_COMMON Register Definitions ****/

  static const rw_reg32_t HRTIM_COMMON_ISR     = (rw_reg32_t)0x40017788U;   /** @brief Interrupt status register. */
  static const rw_reg32_t HRTIM_COMMON_ICR     = (rw_reg32_t)0x4001778CU;   /** @brief Interrupt clear register. */
  static const rw_reg32_t HRTIM_COMMON_IER     = (rw_reg32_t)0x40017790U;   /** @brief Interrupt enable register. */
  static const rw_reg32_t HRTIM_COMMON_OENR    = (rw_reg32_t)0x40017794U;   /** @brief Output enable register. */
  static const rw_reg32_t HRTIM_COMMON_DISR    = (rw_reg32_t)0x40017798U;   /** @brief DISR. */
  static const ro_reg32_t HRTIM_COMMON_ODSR    = (ro_reg32_t)0x4001779CU;   /** @brief Output disable status register. */
  static const rw_reg32_t HRTIM_COMMON_BMCR    = (rw_reg32_t)0x400177A0U;   /** @brief Burst mode control register. */
  static const rw_reg32_t HRTIM_COMMON_BMTRG   = (rw_reg32_t)0x400177A4U;   /** @brief BMTRG. */
  static const rw_reg32_t HRTIM_COMMON_BMCMPR6 = (rw_reg32_t)0x400177A8U;   /** @brief BMCMPR6. */
  static const rw_reg32_t HRTIM_COMMON_BMPER   = (rw_reg32_t)0x400177ACU;   /** @brief Burst mode period register. */
  static const rw_reg32_t HRTIM_COMMON_DLLCR   = (rw_reg32_t)0x400177CCU;   /** @brief DLL control register. */
  static const rw_reg32_t HRTIM_COMMON_BDMUPDR = (rw_reg32_t)0x400177D8U;   /** @brief BDMUPDR. */
  static const rw_reg32_t HRTIM_COMMON_BDTXUPR = (rw_reg32_t)0x400177DCU;   /** @brief Burst DMA timerx update register. */
  static const rw_reg32_t HRTIM_COMMON_BDMADR  = (rw_reg32_t)0x400177E0U;   /** @brief Burst DMA data register. */

  /**** Enumerated HRTIM_COMMON Register Definitions ****/

  static const rw_reg32_t HRTIM_COMMON_CRx[3] = {
    [1] = (rw_reg32_t)0x40017780U,   /** @brief Control register 1. */
    [2] = (rw_reg32_t)0x40017784U,   /** @brief Control register 2. */
  };

  static const rw_reg32_t HRTIM_COMMON_EECRx[4] = {
    [1] = (rw_reg32_t)0x400177B0U,   /** @brief Timer external event control register 1. */
    [2] = (rw_reg32_t)0x400177B4U,   /** @brief Timer external event control register 2. */
    [3] = (rw_reg32_t)0x400177B8U,   /** @brief Timer external event control register 3. */
  };

  static const rw_reg32_t HRTIM_COMMON_ADCxR[5] = {
    [1] = (rw_reg32_t)0x400177BCU,   /** @brief ADC trigger 1 register. */
    [2] = (rw_reg32_t)0x400177C0U,   /** @brief ADC trigger 2 register. */
    [3] = (rw_reg32_t)0x400177C4U,   /** @brief ADC trigger 3 register. */
    [4] = (rw_reg32_t)0x400177C8U,   /** @brief ADC trigger 4 register. */
  };

  static const rw_reg32_t HRTIM_COMMON_FLTINRx[3] = {
    [1] = (rw_reg32_t)0x400177D0U,   /** @brief HRTIM fault input register 1. */
    [2] = (rw_reg32_t)0x400177D4U,   /** @brief HRTIM fault input register 2. */
  };

  /**** HRTIM_COMMON Register Field Definitions ****/

  static const field32_t HRTIM_COMMON_CRx_TEUDIS        = {.msk = 0x00000020U, .pos = 5};    /** @brief Timer E update disable. */
  static const field32_t HRTIM_COMMON_CRx_TDUDIS        = {.msk = 0x00000010U, .pos = 4};    /** @brief Timer D update disable. */
  static const field32_t HRTIM_COMMON_CRx_TCUDIS        = {.msk = 0x00000008U, .pos = 3};    /** @brief Timer C update disable. */
  static const field32_t HRTIM_COMMON_CRx_TBUDIS        = {.msk = 0x00000004U, .pos = 2};    /** @brief Timer B update disable. */
  static const field32_t HRTIM_COMMON_CRx_TAUDIS        = {.msk = 0x00000002U, .pos = 1};    /** @brief Timer A update disable. */
  static const field32_t HRTIM_COMMON_CRx_MUDIS         = {.msk = 0x00000001U, .pos = 0};    /** @brief Master update disable. */
  static const field32_t HRTIM_COMMON_ISR_BMPER         = {.msk = 0x00020000U, .pos = 17};   /** @brief Burst mode period interrupt flag. */
  static const field32_t HRTIM_COMMON_ISR_DLLRDY        = {.msk = 0x00010000U, .pos = 16};   /** @brief DLL ready interrupt flag. */
  static const field32_t HRTIM_COMMON_ISR_SYSFLT        = {.msk = 0x00000020U, .pos = 5};    /** @brief System fault interrupt flag. */
  static const field32_t HRTIM_COMMON_ICR_BMPERC        = {.msk = 0x00020000U, .pos = 17};   /** @brief Burst mode period flag clear. */
  static const field32_t HRTIM_COMMON_ICR_DLLRDYC       = {.msk = 0x00010000U, .pos = 16};   /** @brief DLL ready interrupt flag clear. */
  static const field32_t HRTIM_COMMON_ICR_SYSFLTC       = {.msk = 0x00000020U, .pos = 5};    /** @brief System fault interrupt flag clear. */
  static const field32_t HRTIM_COMMON_IER_BMPERIE       = {.msk = 0x00020000U, .pos = 17};   /** @brief Burst mode period interrupt enable. */
  static const field32_t HRTIM_COMMON_IER_DLLRDYIE      = {.msk = 0x00010000U, .pos = 16};   /** @brief DLL ready interrupt enable. */
  static const field32_t HRTIM_COMMON_IER_SYSFLTE       = {.msk = 0x00000020U, .pos = 5};    /** @brief System fault interrupt enable. */
  static const field32_t HRTIM_COMMON_BMCR_BMSTAT       = {.msk = 0x80000000U, .pos = 31};   /** @brief Burst mode status. */
  static const field32_t HRTIM_COMMON_BMCR_TEBM         = {.msk = 0x00200000U, .pos = 21};   /** @brief Timer E burst mode. */
  static const field32_t HRTIM_COMMON_BMCR_TDBM         = {.msk = 0x00100000U, .pos = 20};   /** @brief Timer D burst mode. */
  static const field32_t HRTIM_COMMON_BMCR_TCBM         = {.msk = 0x00080000U, .pos = 19};   /** @brief Timer C burst mode. */
  static const field32_t HRTIM_COMMON_BMCR_TBBM         = {.msk = 0x00040000U, .pos = 18};   /** @brief Timer B burst mode. */
  static const field32_t HRTIM_COMMON_BMCR_TABM         = {.msk = 0x00020000U, .pos = 17};   /** @brief Timer A burst mode. */
  static const field32_t HRTIM_COMMON_BMCR_MTBM         = {.msk = 0x00010000U, .pos = 16};   /** @brief Master timer burst mode. */
  static const field32_t HRTIM_COMMON_BMCR_BMPREN       = {.msk = 0x00000400U, .pos = 10};   /** @brief Burst mode preload enable. */
  static const field32_t HRTIM_COMMON_BMCR_BMPRSC       = {.msk = 0x000003C0U, .pos = 6};    /** @brief Burst mode prescaler. */
  static const field32_t HRTIM_COMMON_BMCR_BMCLK        = {.msk = 0x0000003CU, .pos = 2};    /** @brief Burst mode clock source. */
  static const field32_t HRTIM_COMMON_BMCR_BMOM         = {.msk = 0x00000002U, .pos = 1};    /** @brief Burst mode operating mode. */
  static const field32_t HRTIM_COMMON_BMCR_BME          = {.msk = 0x00000001U, .pos = 0};    /** @brief Burst mode enable. */
  static const field32_t HRTIM_COMMON_BMTRG_OCHPEV      = {.msk = 0x80000000U, .pos = 31};   /** @brief OCHPEV. */
  static const field32_t HRTIM_COMMON_BMTRG_TEREP       = {.msk = 0x01000000U, .pos = 24};   /** @brief TEREP. */
  static const field32_t HRTIM_COMMON_BMTRG_TERST       = {.msk = 0x00800000U, .pos = 23};   /** @brief TERST. */
  static const field32_t HRTIM_COMMON_BMTRG_TDREP       = {.msk = 0x00100000U, .pos = 20};   /** @brief TDREP. */
  static const field32_t HRTIM_COMMON_BMTRG_TDRST       = {.msk = 0x00080000U, .pos = 19};   /** @brief TDRST. */
  static const field32_t HRTIM_COMMON_BMTRG_TCREP       = {.msk = 0x00010000U, .pos = 16};   /** @brief TCREP. */
  static const field32_t HRTIM_COMMON_BMTRG_TCRST       = {.msk = 0x00008000U, .pos = 15};   /** @brief TCRST. */
  static const field32_t HRTIM_COMMON_BMTRG_TBREP       = {.msk = 0x00001000U, .pos = 12};   /** @brief TBREP. */
  static const field32_t HRTIM_COMMON_BMTRG_TBRST       = {.msk = 0x00000800U, .pos = 11};   /** @brief TBRST. */
  static const field32_t HRTIM_COMMON_BMTRG_TAREP       = {.msk = 0x00000100U, .pos = 8};    /** @brief TAREP. */
  static const field32_t HRTIM_COMMON_BMTRG_TARST       = {.msk = 0x00000080U, .pos = 7};    /** @brief TARST. */
  static const field32_t HRTIM_COMMON_BMTRG_MSTREP      = {.msk = 0x00000004U, .pos = 2};    /** @brief MSTREP. */
  static const field32_t HRTIM_COMMON_BMTRG_MSTRST      = {.msk = 0x00000002U, .pos = 1};    /** @brief MSTRST. */
  static const field32_t HRTIM_COMMON_BMTRG_SW          = {.msk = 0x00000001U, .pos = 0};    /** @brief SW. */
  static const field32_t HRTIM_COMMON_BMCMPR6_BMCMP     = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief BMCMP. */
  static const field32_t HRTIM_COMMON_BMPER_BMPER       = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Burst mode period. */
  static const field32_t HRTIM_COMMON_ADCxR_AD1TEPER    = {.msk = 0x80000000U, .pos = 31};   /** @brief ADC trigger 1 on timer E period. */
  static const field32_t HRTIM_COMMON_ADCxR_AD1TDPER    = {.msk = 0x08000000U, .pos = 27};   /** @brief ADC trigger 1 on timer D period. */
  static const field32_t HRTIM_COMMON_ADCxR_AD1TCPER    = {.msk = 0x00800000U, .pos = 23};   /** @brief ADC trigger 1 on timer C period. */
  static const field32_t HRTIM_COMMON_ADCxR_AD1TBRST    = {.msk = 0x00080000U, .pos = 19};   /** @brief ADC trigger 1 on timer B reset. */
  static const field32_t HRTIM_COMMON_ADCxR_AD1TBPER    = {.msk = 0x00040000U, .pos = 18};   /** @brief ADC trigger 1 on timer B period. */
  static const field32_t HRTIM_COMMON_ADCxR_AD1TARST    = {.msk = 0x00004000U, .pos = 14};   /** @brief ADC trigger 1 on timer A reset. */
  static const field32_t HRTIM_COMMON_ADCxR_AD1TAPER    = {.msk = 0x00002000U, .pos = 13};   /** @brief ADC trigger 1 on timer A period. */
  static const field32_t HRTIM_COMMON_ADCxR_AD1MPER     = {.msk = 0x00000010U, .pos = 4};    /** @brief ADC trigger 1 on master period. */
  static const field32_t HRTIM_COMMON_DLLCR_CALRTE      = {.msk = 0x0000000CU, .pos = 2};    /** @brief DLL calibration rate. */
  static const field32_t HRTIM_COMMON_DLLCR_CALEN       = {.msk = 0x00000002U, .pos = 1};    /** @brief DLL calibration enable. */
  static const field32_t HRTIM_COMMON_DLLCR_CAL         = {.msk = 0x00000001U, .pos = 0};    /** @brief DLL calibration start. */
  static const field32_t HRTIM_COMMON_BDMUPDR_MREP      = {.msk = 0x00000020U, .pos = 5};    /** @brief MREP. */
  static const field32_t HRTIM_COMMON_BDMUPDR_MPER      = {.msk = 0x00000010U, .pos = 4};    /** @brief MPER. */
  static const field32_t HRTIM_COMMON_BDMUPDR_MCNT      = {.msk = 0x00000008U, .pos = 3};    /** @brief MCNT. */
  static const field32_t HRTIM_COMMON_BDMUPDR_MDIER     = {.msk = 0x00000004U, .pos = 2};    /** @brief MDIER. */
  static const field32_t HRTIM_COMMON_BDMUPDR_MICR      = {.msk = 0x00000002U, .pos = 1};    /** @brief MICR. */
  static const field32_t HRTIM_COMMON_BDMUPDR_MCR       = {.msk = 0x00000001U, .pos = 0};    /** @brief MCR. */
  static const field32_t HRTIM_COMMON_BDTXUPR_TIMXFLTR  = {.msk = 0x00100000U, .pos = 20};   /** @brief HRTIM_FLTxR register update enable. */
  static const field32_t HRTIM_COMMON_BDTXUPR_TIMXOUTR  = {.msk = 0x00080000U, .pos = 19};   /** @brief HRTIM_OUTxR register update enable. */
  static const field32_t HRTIM_COMMON_BDTXUPR_TIMXCHPR  = {.msk = 0x00040000U, .pos = 18};   /** @brief HRTIM_CHPxR register update enable. */
  static const field32_t HRTIM_COMMON_BDTXUPR_TIMXRSTR  = {.msk = 0x00020000U, .pos = 17};   /** @brief HRTIM_RSTxR register update enable. */
  static const field32_t HRTIM_COMMON_BDTXUPR_TIMX_DTXR = {.msk = 0x00000400U, .pos = 10};   /** @brief HRTIM_DTxR register update enable. */
  static const field32_t HRTIM_COMMON_BDTXUPR_TIMXREP   = {.msk = 0x00000020U, .pos = 5};    /** @brief HRTIM_REPxR register update enable. */
  static const field32_t HRTIM_COMMON_BDTXUPR_TIMXPER   = {.msk = 0x00000010U, .pos = 4};    /** @brief HRTIM_PERxR register update enable. */
  static const field32_t HRTIM_COMMON_BDTXUPR_TIMXCNT   = {.msk = 0x00000008U, .pos = 3};    /** @brief HRTIM_CNTxR register update enable. */
  static const field32_t HRTIM_COMMON_BDTXUPR_TIMXDIER  = {.msk = 0x00000004U, .pos = 2};    /** @brief HRTIM_TIMxDIER register update enable. */
  static const field32_t HRTIM_COMMON_BDTXUPR_TIMXICR   = {.msk = 0x00000002U, .pos = 1};    /** @brief HRTIM_TIMxICR register update enable. */
  static const field32_t HRTIM_COMMON_BDTXUPR_TIMXCR    = {.msk = 0x00000001U, .pos = 0};    /** @brief HRTIM_TIMxCR register update enable. */

  /**** Enumerated HRTIM_COMMON Register Field Definitions ****/

  static field32_t const HRTIM_COMMON_CRx_ADxUSRC[5] = {
    [1] = {.msk = 0x00070000U, .pos = 16},   /** @brief ADC trigger 1 update source. */
    [2] = {.msk = 0x00380000U, .pos = 19},   /** @brief ADC trigger 2 update source. */
    [3] = {.msk = 0x01C00000U, .pos = 22},   /** @brief ADC trigger 3 update source. */
    [4] = {.msk = 0x0E000000U, .pos = 25},   /** @brief ADC trigger 4 update source. */
  };

  static field32_t const HRTIM_COMMON_ISR_FLTx[6] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief Fault 1 interrupt flag. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief Fault 2 interrupt flag. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief Fault 3 interrupt flag. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief Fault 4 interrupt flag. */
    [5] = {.msk = 0x00000010U, .pos = 4},   /** @brief Fault 5 interrupt flag. */
  };

  static field32_t const HRTIM_COMMON_ICR_FLTxC[6] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief Fault 1 interrupt flag clear. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief Fault 2 interrupt flag clear. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief Fault 3 interrupt flag clear. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief Fault 4 interrupt flag clear. */
    [5] = {.msk = 0x00000010U, .pos = 4},   /** @brief Fault 5 interrupt flag clear. */
  };

  static field32_t const HRTIM_COMMON_IER_FLTxIE[6] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief Fault 1 interrupt enable. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief Fault 2 interrupt enable. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief Fault 3 interrupt enable. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief Fault 4 interrupt enable. */
    [5] = {.msk = 0x00000010U, .pos = 4},   /** @brief Fault 5 interrupt enable. */
  };

  static field32_t const HRTIM_COMMON_OENR_TExOEN[3] = {
    [1] = {.msk = 0x00000100U, .pos = 8},   /** @brief Timer E output 1 enable. */
    [2] = {.msk = 0x00000200U, .pos = 9},   /** @brief Timer E output 2 enable. */
  };

  static field32_t const HRTIM_COMMON_OENR_TDxOEN[3] = {
    [1] = {.msk = 0x00000040U, .pos = 6},   /** @brief Timer D output 1 enable. */
    [2] = {.msk = 0x00000080U, .pos = 7},   /** @brief Timer D output 2 enable. */
  };

  static field32_t const HRTIM_COMMON_OENR_TCxOEN[3] = {
    [1] = {.msk = 0x00000010U, .pos = 4},   /** @brief Timer C output 1 enable. */
    [2] = {.msk = 0x00000020U, .pos = 5},   /** @brief Timer C output 2 enable. */
  };

  static field32_t const HRTIM_COMMON_OENR_TBxOEN[3] = {
    [1] = {.msk = 0x00000004U, .pos = 2},   /** @brief Timer B output 1 enable. */
    [2] = {.msk = 0x00000008U, .pos = 3},   /** @brief Timer B output 2 enable. */
  };

  static field32_t const HRTIM_COMMON_OENR_TAxOEN[3] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief Timer A output 1 enable. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief Timer A output 2 enable. */
  };

  static field32_t const HRTIM_COMMON_DISR_TExODIS[3] = {
    [1] = {.msk = 0x00000100U, .pos = 8},   /** @brief TE1ODIS. */
    [2] = {.msk = 0x00000200U, .pos = 9},   /** @brief TE2ODIS. */
  };

  static field32_t const HRTIM_COMMON_DISR_TDxODIS[3] = {
    [1] = {.msk = 0x00000040U, .pos = 6},   /** @brief TD1ODIS. */
    [2] = {.msk = 0x00000080U, .pos = 7},   /** @brief TD2ODIS. */
  };

  static field32_t const HRTIM_COMMON_DISR_TCxODIS[3] = {
    [1] = {.msk = 0x00000010U, .pos = 4},   /** @brief TC1ODIS. */
    [2] = {.msk = 0x00000020U, .pos = 5},   /** @brief TC2ODIS. */
  };

  static field32_t const HRTIM_COMMON_DISR_TBxODIS[3] = {
    [1] = {.msk = 0x00000004U, .pos = 2},   /** @brief TB1ODIS. */
    [2] = {.msk = 0x00000008U, .pos = 3},   /** @brief TB2ODIS. */
  };

  static field32_t const HRTIM_COMMON_DISR_TAxODIS[3] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief TA1ODIS. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief TA2ODIS. */
  };

  static field32_t const HRTIM_COMMON_ODSR_TExODS[3] = {
    [1] = {.msk = 0x00000100U, .pos = 8},   /** @brief Timer E output 1 disable status. */
    [2] = {.msk = 0x00000200U, .pos = 9},   /** @brief Timer E output 2 disable status. */
  };

  static field32_t const HRTIM_COMMON_ODSR_TDxODS[3] = {
    [1] = {.msk = 0x00000040U, .pos = 6},   /** @brief Timer D output 1 disable status. */
    [2] = {.msk = 0x00000080U, .pos = 7},   /** @brief Timer D output 2 disable status. */
  };

  static field32_t const HRTIM_COMMON_ODSR_TCxODS[3] = {
    [1] = {.msk = 0x00000010U, .pos = 4},   /** @brief Timer C output 1 disable status. */
    [2] = {.msk = 0x00000020U, .pos = 5},   /** @brief Timer C output 2 disable status. */
  };

  static field32_t const HRTIM_COMMON_ODSR_TBxODS[3] = {
    [1] = {.msk = 0x00000004U, .pos = 2},   /** @brief Timer B output 1 disable status. */
    [2] = {.msk = 0x00000008U, .pos = 3},   /** @brief Timer B output 2 disable status. */
  };

  static field32_t const HRTIM_COMMON_ODSR_TAxODS[3] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief Timer A output 1 disable status. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief Timer A output 2 disable status. */
  };

  static field32_t const HRTIM_COMMON_BMTRG_TECMPx[3] = {
    [1] = {.msk = 0x02000000U, .pos = 25},   /** @brief TECMP1. */
    [2] = {.msk = 0x04000000U, .pos = 26},   /** @brief TECMP2. */
  };

  static field32_t const HRTIM_COMMON_BMTRG_TDCMPx[3] = {
    [1] = {.msk = 0x00200000U, .pos = 21},   /** @brief TDCMP1. */
    [2] = {.msk = 0x00400000U, .pos = 22},   /** @brief TDCMP2. */
  };

  static field32_t const HRTIM_COMMON_BMTRG_TCCMPx[3] = {
    [1] = {.msk = 0x00020000U, .pos = 17},   /** @brief TCCMP1. */
    [2] = {.msk = 0x00040000U, .pos = 18},   /** @brief TCCMP2. */
  };

  static field32_t const HRTIM_COMMON_BMTRG_TBCMPx[3] = {
    [1] = {.msk = 0x00002000U, .pos = 13},   /** @brief TBCMP1. */
    [2] = {.msk = 0x00004000U, .pos = 14},   /** @brief TBCMP2. */
  };

  static field32_t const HRTIM_COMMON_BMTRG_TACMPx[3] = {
    [1] = {.msk = 0x00000200U, .pos = 9},    /** @brief TACMP1. */
    [2] = {.msk = 0x00000400U, .pos = 10},   /** @brief TACMP2. */
  };

  static field32_t const HRTIM_COMMON_BMTRG_MSTCMPx[5] = {
    [1] = {.msk = 0x00000008U, .pos = 3},   /** @brief MSTCMP1. */
    [2] = {.msk = 0x00000010U, .pos = 4},   /** @brief MSTCMP2. */
    [3] = {.msk = 0x00000020U, .pos = 5},   /** @brief MSTCMP3. */
    [4] = {.msk = 0x00000040U, .pos = 6},   /** @brief MSTCMP4. */
  };

  static field32_t const HRTIM_COMMON_EECRx_EExFAST[6] = {
    [1] = {.msk = 0x00000020U, .pos = 5},    /** @brief External event 1 fast mode. */
    [2] = {.msk = 0x00000800U, .pos = 11},   /** @brief External event 2 fast mode. */
    [3] = {.msk = 0x00020000U, .pos = 17},   /** @brief External event 3 fast mode. */
    [4] = {.msk = 0x00800000U, .pos = 23},   /** @brief External event 4 fast mode. */
    [5] = {.msk = 0x20000000U, .pos = 29},   /** @brief External event 5 fast mode. */
  };

  static field32_t const HRTIM_COMMON_EECRx_EExSNS[6] = {
    [1] = {.msk = 0x00000018U, .pos = 3},    /** @brief External event 1 sensitivity. */
    [2] = {.msk = 0x00000600U, .pos = 9},    /** @brief External event 2 sensitivity. */
    [3] = {.msk = 0x00018000U, .pos = 15},   /** @brief External event 3 sensitivity. */
    [4] = {.msk = 0x00600000U, .pos = 21},   /** @brief External event 4 sensitivity. */
    [5] = {.msk = 0x18000000U, .pos = 27},   /** @brief External event 5 sensitivity. */
  };

  static field32_t const HRTIM_COMMON_EECRx_EExPOL[6] = {
    [1] = {.msk = 0x00000004U, .pos = 2},    /** @brief External event 1 polarity. */
    [2] = {.msk = 0x00000100U, .pos = 8},    /** @brief External event 2 polarity. */
    [3] = {.msk = 0x00004000U, .pos = 14},   /** @brief External event 3 polarity. */
    [4] = {.msk = 0x00100000U, .pos = 20},   /** @brief External event 4 polarity. */
    [5] = {.msk = 0x04000000U, .pos = 26},   /** @brief External event 5 polarity. */
  };

  static field32_t const HRTIM_COMMON_EECRx_EExSRC[6] = {
    [1] = {.msk = 0x00000003U, .pos = 0},    /** @brief External event 1 source. */
    [2] = {.msk = 0x000000C0U, .pos = 6},    /** @brief External event 2 source. */
    [3] = {.msk = 0x00003000U, .pos = 12},   /** @brief External event 3 source. */
    [4] = {.msk = 0x000C0000U, .pos = 18},   /** @brief External event 4 source. */
    [5] = {.msk = 0x03000000U, .pos = 24},   /** @brief External event 5 source. */
  };

  static field32_t const HRTIM_COMMON_ADCxR_AD1TECx[5] = {
    [2] = {.msk = 0x10000000U, .pos = 28},   /** @brief ADC trigger 1 on timer E compare 2. */
    [3] = {.msk = 0x20000000U, .pos = 29},   /** @brief ADC trigger 1 on timer E compare 3. */
    [4] = {.msk = 0x40000000U, .pos = 30},   /** @brief ADC trigger 1 on timer E compare 4. */
  };

  static field32_t const HRTIM_COMMON_ADCxR_AD1TDCx[5] = {
    [2] = {.msk = 0x01000000U, .pos = 24},   /** @brief ADC trigger 1 on timer D compare 2. */
    [3] = {.msk = 0x02000000U, .pos = 25},   /** @brief ADC trigger 1 on timer D compare 3. */
    [4] = {.msk = 0x04000000U, .pos = 26},   /** @brief ADC trigger 1 on timer D compare 4. */
  };

  static field32_t const HRTIM_COMMON_ADCxR_AD1TCCx[5] = {
    [2] = {.msk = 0x00100000U, .pos = 20},   /** @brief ADC trigger 1 on timer C compare 2. */
    [3] = {.msk = 0x00200000U, .pos = 21},   /** @brief ADC trigger 1 on timer C compare 3. */
    [4] = {.msk = 0x00400000U, .pos = 22},   /** @brief ADC trigger 1 on timer C compare 4. */
  };

  static field32_t const HRTIM_COMMON_ADCxR_AD1TBCx[5] = {
    [2] = {.msk = 0x00008000U, .pos = 15},   /** @brief ADC trigger 1 on timer B compare 2. */
    [3] = {.msk = 0x00010000U, .pos = 16},   /** @brief ADC trigger 1 on timer B compare 3. */
    [4] = {.msk = 0x00020000U, .pos = 17},   /** @brief ADC trigger 1 on timer B compare 4. */
  };

  static field32_t const HRTIM_COMMON_ADCxR_AD1TACx[5] = {
    [2] = {.msk = 0x00000400U, .pos = 10},   /** @brief ADC trigger 1 on timer A compare 2. */
    [3] = {.msk = 0x00000800U, .pos = 11},   /** @brief ADC trigger 1 on timer A compare 3. */
    [4] = {.msk = 0x00001000U, .pos = 12},   /** @brief ADC trigger 1 on timer A compare 4. */
  };

  static field32_t const HRTIM_COMMON_ADCxR_AD1EEVx[6] = {
    [1] = {.msk = 0x00000020U, .pos = 5},   /** @brief ADC trigger 1 on external event 1. */
    [2] = {.msk = 0x00000040U, .pos = 6},   /** @brief ADC trigger 1 on external event 2. */
    [3] = {.msk = 0x00000080U, .pos = 7},   /** @brief ADC trigger 1 on external event 3. */
    [4] = {.msk = 0x00000100U, .pos = 8},   /** @brief ADC trigger 1 on external event 4. */
    [5] = {.msk = 0x00000200U, .pos = 9},   /** @brief ADC trigger 1 on external event 5. */
  };

  static field32_t const HRTIM_COMMON_ADCxR_AD1MCx[5] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief ADC trigger 1 on master compare 1. */
    [2] = {.msk = 0x00000002U, .pos = 1},   /** @brief ADC trigger 1 on master compare 2. */
    [3] = {.msk = 0x00000004U, .pos = 2},   /** @brief ADC trigger 1 on master compare 3. */
    [4] = {.msk = 0x00000008U, .pos = 3},   /** @brief ADC trigger 1 on master compare 4. */
  };

  static field32_t const HRTIM_COMMON_FLTINRx_FLTxLCK[5] = {
    [1] = {.msk = 0x00000080U, .pos = 7},    /** @brief FLT1LCK. */
    [2] = {.msk = 0x00008000U, .pos = 15},   /** @brief FLT2LCK. */
    [3] = {.msk = 0x00800000U, .pos = 23},   /** @brief FLT3LCK. */
    [4] = {.msk = 0x80000000U, .pos = 31},   /** @brief FLT4LCK. */
  };

  static field32_t const HRTIM_COMMON_FLTINRx_FLTxF[5] = {
    [1] = {.msk = 0x00000078U, .pos = 3},    /** @brief FLT1F. */
    [2] = {.msk = 0x00007800U, .pos = 11},   /** @brief FLT2F. */
    [3] = {.msk = 0x00780000U, .pos = 19},   /** @brief FLT3F. */
    [4] = {.msk = 0x78000000U, .pos = 27},   /** @brief FLT4F. */
  };

  static field32_t const HRTIM_COMMON_FLTINRx_FLTxSRC[5] = {
    [1] = {.msk = 0x00000004U, .pos = 2},    /** @brief FLT1SRC. */
    [2] = {.msk = 0x00000400U, .pos = 10},   /** @brief FLT2SRC. */
    [3] = {.msk = 0x00040000U, .pos = 18},   /** @brief FLT3SRC. */
    [4] = {.msk = 0x04000000U, .pos = 26},   /** @brief FLT4SRC. */
  };

  static field32_t const HRTIM_COMMON_FLTINRx_FLTxP[5] = {
    [1] = {.msk = 0x00000002U, .pos = 1},    /** @brief FLT1P. */
    [2] = {.msk = 0x00000200U, .pos = 9},    /** @brief FLT2P. */
    [3] = {.msk = 0x00020000U, .pos = 17},   /** @brief FLT3P. */
    [4] = {.msk = 0x02000000U, .pos = 25},   /** @brief FLT4P. */
  };

  static field32_t const HRTIM_COMMON_FLTINRx_FLTxE[5] = {
    [1] = {.msk = 0x00000001U, .pos = 0},    /** @brief FLT1E. */
    [2] = {.msk = 0x00000100U, .pos = 8},    /** @brief FLT2E. */
    [3] = {.msk = 0x00010000U, .pos = 16},   /** @brief FLT3E. */
    [4] = {.msk = 0x01000000U, .pos = 24},   /** @brief FLT4E. */
  };

  static field32_t const HRTIM_COMMON_BDMUPDR_MCMPx[5] = {
    [1] = {.msk = 0x00000040U, .pos = 6},   /** @brief MCMP1. */
    [2] = {.msk = 0x00000080U, .pos = 7},   /** @brief MCMP2. */
    [3] = {.msk = 0x00000100U, .pos = 8},   /** @brief MCMP3. */
    [4] = {.msk = 0x00000200U, .pos = 9},   /** @brief MCMP4. */
  };

  static field32_t const HRTIM_COMMON_BDTXUPR_TIMXEEFRx[3] = {
    [1] = {.msk = 0x00008000U, .pos = 15},   /** @brief HRTIM_EEFxR1 register update enable. */
    [2] = {.msk = 0x00010000U, .pos = 16},   /** @brief HRTIM_EEFxR2 register update enable. */
  };

  static field32_t const HRTIM_COMMON_BDTXUPR_TIMXRSTxR[3] = {
    [1] = {.msk = 0x00001000U, .pos = 12},   /** @brief HRTIM_RST1xR register update enable. */
    [2] = {.msk = 0x00004000U, .pos = 14},   /** @brief HRTIM_RST2xR register update enable. */
  };

  static field32_t const HRTIM_COMMON_BDTXUPR_TIMXSETxR[3] = {
    [1] = {.msk = 0x00000800U, .pos = 11},   /** @brief HRTIM_SET1xR register update enable. */
    [2] = {.msk = 0x00002000U, .pos = 13},   /** @brief HRTIM_SET2xR register update enable. */
  };

  static field32_t const HRTIM_COMMON_BDTXUPR_TIMXCMPx[5] = {
    [1] = {.msk = 0x00000040U, .pos = 6},   /** @brief HRTIM_CMP1xR register update enable. */
    [2] = {.msk = 0x00000080U, .pos = 7},   /** @brief HRTIM_CMP2xR register update enable. */
    [3] = {.msk = 0x00000100U, .pos = 8},   /** @brief HRTIM_CMP3xR register update enable. */
    [4] = {.msk = 0x00000200U, .pos = 9},   /** @brief HRTIM_CMP4xR register update enable. */
  };

  /************************************************************************************************
   * DFSDM Definitions
   ************************************************************************************************/

  /**** Enumerated DFSDM Register Definitions ****/

  static const rw_reg32_t DFSDM_DFSDM_CHCFG0Rx[3] = {
    [1] = (rw_reg32_t)0x40017000U,   /** @brief DFSDM channel configuration 0 register 1. */
    [2] = (rw_reg32_t)0x40017020U,   /** @brief DFSDM channel configuration 0 register 2. */
  };

  static const rw_reg32_t DFSDM_DFSDM_CHCFGxR1[8] = {
    [1] = (rw_reg32_t)0x40017004U,   /** @brief DFSDM channel configuration 1 register 1. */
    [2] = (rw_reg32_t)0x40017008U,   /** @brief DFSDM channel configuration 2 register 1. */
    [3] = (rw_reg32_t)0x4001700CU,   /** @brief DFSDM channel configuration 3 register 1. */
    [4] = (rw_reg32_t)0x40017010U,   /** @brief DFSDM channel configuration 4 register 1. */
    [5] = (rw_reg32_t)0x40017014U,   /** @brief DFSDM channel configuration 5 register 1. */
    [6] = (rw_reg32_t)0x40017018U,   /** @brief DFSDM channel configuration 6 register 1. */
    [7] = (rw_reg32_t)0x4001701CU,   /** @brief DFSDM channel configuration 7 register 1. */
  };

  static const rw_reg32_t DFSDM_DFSDM_CHCFGxR2[8] = {
    [1] = (rw_reg32_t)0x40017024U,   /** @brief DFSDM channel configuration 1 register 2. */
    [2] = (rw_reg32_t)0x40017028U,   /** @brief DFSDM channel configuration 2 register 2. */
    [3] = (rw_reg32_t)0x4001702CU,   /** @brief DFSDM channel configuration 3 register 2. */
    [4] = (rw_reg32_t)0x40017030U,   /** @brief DFSDM channel configuration 4 register 2. */
    [5] = (rw_reg32_t)0x40017034U,   /** @brief DFSDM channel configuration 5 register 2. */
    [6] = (rw_reg32_t)0x40017038U,   /** @brief DFSDM channel configuration 6 register 2. */
    [7] = (rw_reg32_t)0x4001703CU,   /** @brief DFSDM channel configuration 7 register 2. */
  };

  static const rw_reg32_t DFSDM_DFSDM_AWSCDxR[8] = {
    [0] = (rw_reg32_t)0x40017040U,   /** @brief DFSDM analog watchdog and short-circuit detector register. */
    [1] = (rw_reg32_t)0x40017044U,   /** @brief DFSDM analog watchdog and short-circuit detector register. */
    [2] = (rw_reg32_t)0x40017048U,   /** @brief DFSDM analog watchdog and short-circuit detector register. */
    [3] = (rw_reg32_t)0x4001704CU,   /** @brief DFSDM analog watchdog and short-circuit detector register. */
    [4] = (rw_reg32_t)0x40017050U,   /** @brief DFSDM analog watchdog and short-circuit detector register. */
    [5] = (rw_reg32_t)0x40017054U,   /** @brief DFSDM analog watchdog and short-circuit detector register. */
    [6] = (rw_reg32_t)0x40017058U,   /** @brief DFSDM analog watchdog and short-circuit detector register. */
    [7] = (rw_reg32_t)0x4001705CU,   /** @brief DFSDM analog watchdog and short-circuit detector register. */
  };

  static const ro_reg32_t DFSDM_DFSDM_CHWDATxR[8] = {
    [0] = (ro_reg32_t)0x40017060U,   /** @brief DFSDM channel watchdog filter data register. */
    [1] = (ro_reg32_t)0x40017064U,   /** @brief DFSDM channel watchdog filter data register. */
    [2] = (ro_reg32_t)0x40017068U,   /** @brief DFSDM channel watchdog filter data register. */
    [3] = (ro_reg32_t)0x4001706CU,   /** @brief DFSDM channel watchdog filter data register. */
    [4] = (ro_reg32_t)0x40017070U,   /** @brief DFSDM channel watchdog filter data register. */
    [5] = (ro_reg32_t)0x40017074U,   /** @brief DFSDM channel watchdog filter data register. */
    [6] = (ro_reg32_t)0x40017078U,   /** @brief DFSDM channel watchdog filter data register. */
    [7] = (ro_reg32_t)0x4001707CU,   /** @brief DFSDM channel watchdog filter data register. */
  };

  static const rw_reg32_t DFSDM_DFSDM_CHDATINxR[8] = {
    [0] = (rw_reg32_t)0x40017080U,   /** @brief DFSDM channel data input register. */
    [1] = (rw_reg32_t)0x40017084U,   /** @brief DFSDM channel data input register. */
    [2] = (rw_reg32_t)0x40017088U,   /** @brief DFSDM channel data input register. */
    [3] = (rw_reg32_t)0x4001708CU,   /** @brief DFSDM channel data input register. */
    [4] = (rw_reg32_t)0x40017090U,   /** @brief DFSDM channel data input register. */
    [5] = (rw_reg32_t)0x40017094U,   /** @brief DFSDM channel data input register. */
    [6] = (rw_reg32_t)0x40017098U,   /** @brief DFSDM channel data input register. */
    [7] = (rw_reg32_t)0x4001709CU,   /** @brief DFSDM channel data input register. */
  };

  static const rw_reg32_t DFSDM_DFSDM0_CRx[3] = {
    [1] = (rw_reg32_t)0x400170A0U,   /** @brief DFSDM control register 1. */
    [2] = (rw_reg32_t)0x400170B0U,   /** @brief DFSDM control register 2. */
  };

  static const rw_reg32_t DFSDM_DFSDMx_CR1[4] = {
    [1] = (rw_reg32_t)0x400170A4U,   /** @brief DFSDM control register 1. */
    [2] = (rw_reg32_t)0x400170A8U,   /** @brief DFSDM control register 1. */
    [3] = (rw_reg32_t)0x400170ACU,   /** @brief DFSDM control register 1. */
  };

  static const rw_reg32_t DFSDM_DFSDMx_CR2[4] = {
    [1] = (rw_reg32_t)0x400170B4U,   /** @brief DFSDM control register 2. */
    [2] = (rw_reg32_t)0x400170B8U,   /** @brief DFSDM control register 2. */
    [3] = (rw_reg32_t)0x400170BCU,   /** @brief DFSDM control register 2. */
  };

  static const ro_reg32_t DFSDM_DFSDMx_ISR[4] = {
    [0] = (ro_reg32_t)0x400170C0U,   /** @brief DFSDM interrupt and status register. */
    [1] = (ro_reg32_t)0x400170C4U,   /** @brief DFSDM interrupt and status register. */
    [2] = (ro_reg32_t)0x400170C8U,   /** @brief DFSDM interrupt and status register. */
    [3] = (ro_reg32_t)0x400170CCU,   /** @brief DFSDM interrupt and status register. */
  };

  static const rw_reg32_t DFSDM_DFSDMx_ICR[4] = {
    [0] = (rw_reg32_t)0x400170D0U,   /** @brief DFSDM interrupt flag clear register. */
    [1] = (rw_reg32_t)0x400170D4U,   /** @brief DFSDM interrupt flag clear register. */
    [2] = (rw_reg32_t)0x400170D8U,   /** @brief DFSDM interrupt flag clear register. */
    [3] = (rw_reg32_t)0x400170DCU,   /** @brief DFSDM interrupt flag clear register. */
  };

  static const rw_reg32_t DFSDM_DFSDMx_JCHGR[4] = {
    [0] = (rw_reg32_t)0x400170E0U,   /** @brief DFSDM injected channel group selection register. */
    [1] = (rw_reg32_t)0x400170E4U,   /** @brief DFSDM injected channel group selection register. */
    [2] = (rw_reg32_t)0x400170E8U,   /** @brief DFSDM injected channel group selection register. */
    [3] = (rw_reg32_t)0x400170ECU,   /** @brief DFSDM injected channel group selection register. */
  };

  static const rw_reg32_t DFSDM_DFSDMx_FCR[4] = {
    [0] = (rw_reg32_t)0x400170F0U,   /** @brief DFSDM filter control register. */
    [1] = (rw_reg32_t)0x400170F4U,   /** @brief DFSDM filter control register. */
    [2] = (rw_reg32_t)0x400170F8U,   /** @brief DFSDM filter control register. */
    [3] = (rw_reg32_t)0x400170FCU,   /** @brief DFSDM filter control register. */
  };

  static const ro_reg32_t DFSDM_DFSDMx_JDATAR[4] = {
    [0] = (ro_reg32_t)0x40017100U,   /** @brief DFSDM data register for injected group. */
    [1] = (ro_reg32_t)0x40017104U,   /** @brief DFSDM data register for injected group. */
    [2] = (ro_reg32_t)0x40017108U,   /** @brief DFSDM data register for injected group. */
    [3] = (ro_reg32_t)0x4001710CU,   /** @brief DFSDM data register for injected group. */
  };

  static const ro_reg32_t DFSDM_DFSDMx_RDATAR[4] = {
    [0] = (ro_reg32_t)0x40017110U,   /** @brief DFSDM data register for the regular channel. */
    [1] = (ro_reg32_t)0x40017114U,   /** @brief DFSDM data register for the regular channel. */
    [2] = (ro_reg32_t)0x40017118U,   /** @brief DFSDM data register for the regular channel. */
    [3] = (ro_reg32_t)0x4001711CU,   /** @brief DFSDM data register for the regular channel. */
  };

  static const rw_reg32_t DFSDM_DFSDMx_AWHTR[4] = {
    [0] = (rw_reg32_t)0x40017120U,   /** @brief DFSDM analog watchdog high threshold register. */
    [1] = (rw_reg32_t)0x40017124U,   /** @brief DFSDM analog watchdog high threshold register. */
    [2] = (rw_reg32_t)0x40017128U,   /** @brief DFSDM analog watchdog high threshold register. */
    [3] = (rw_reg32_t)0x4001712CU,   /** @brief DFSDM analog watchdog high threshold register. */
  };

  static const rw_reg32_t DFSDM_DFSDMx_AWLTR[4] = {
    [0] = (rw_reg32_t)0x40017130U,   /** @brief DFSDM analog watchdog low threshold register. */
    [1] = (rw_reg32_t)0x40017134U,   /** @brief DFSDM analog watchdog low threshold register. */
    [2] = (rw_reg32_t)0x40017138U,   /** @brief DFSDM analog watchdog low threshold register. */
    [3] = (rw_reg32_t)0x4001713CU,   /** @brief DFSDM analog watchdog low threshold register. */
  };

  static const ro_reg32_t DFSDM_DFSDMx_AWSR[4] = {
    [0] = (ro_reg32_t)0x40017140U,   /** @brief DFSDM analog watchdog status register. */
    [1] = (ro_reg32_t)0x40017144U,   /** @brief DFSDM analog watchdog status register. */
    [2] = (ro_reg32_t)0x40017148U,   /** @brief DFSDM analog watchdog status register. */
    [3] = (ro_reg32_t)0x4001714CU,   /** @brief DFSDM analog watchdog status register. */
  };

  static const rw_reg32_t DFSDM_DFSDMx_AWCFR[4] = {
    [0] = (rw_reg32_t)0x40017150U,   /** @brief DFSDM analog watchdog clear flag register. */
    [1] = (rw_reg32_t)0x40017154U,   /** @brief DFSDM analog watchdog clear flag register. */
    [2] = (rw_reg32_t)0x40017158U,   /** @brief DFSDM analog watchdog clear flag register. */
    [3] = (rw_reg32_t)0x4001715CU,   /** @brief DFSDM analog watchdog clear flag register. */
  };

  static const ro_reg32_t DFSDM_DFSDMx_EXMAX[4] = {
    [0] = (ro_reg32_t)0x40017160U,   /** @brief DFSDM extremes detector maximum register. */
    [1] = (ro_reg32_t)0x40017164U,   /** @brief DFSDM extremes detector maximum register. */
    [2] = (ro_reg32_t)0x40017168U,   /** @brief DFSDM extremes detector maximum register. */
    [3] = (ro_reg32_t)0x4001716CU,   /** @brief DFSDM extremes detector maximum register. */
  };

  static const ro_reg32_t DFSDM_DFSDMx_EXMIN[4] = {
    [0] = (ro_reg32_t)0x40017170U,   /** @brief DFSDM extremes detector minimum register. */
    [1] = (ro_reg32_t)0x40017174U,   /** @brief DFSDM extremes detector minimum register. */
    [2] = (ro_reg32_t)0x40017178U,   /** @brief DFSDM extremes detector minimum register. */
    [3] = (ro_reg32_t)0x4001717CU,   /** @brief DFSDM extremes detector minimum register. */
  };

  static const ro_reg32_t DFSDM_DFSDMx_CNVTIMR[4] = {
    [0] = (ro_reg32_t)0x40017180U,   /** @brief DFSDM conversion timer register. */
    [1] = (ro_reg32_t)0x40017184U,   /** @brief DFSDM conversion timer register. */
    [2] = (ro_reg32_t)0x40017188U,   /** @brief DFSDM conversion timer register. */
    [3] = (ro_reg32_t)0x4001718CU,   /** @brief DFSDM conversion timer register. */
  };

  /**** DFSDM Register Field Definitions ****/

  static const field32_t DFSDM_DFSDM_CHCFG0Rx_SITP     = {.msk = 0x00000003U, .pos = 0};    /** @brief Serial interface type for channel 0. */
  static const field32_t DFSDM_DFSDM_CHCFG0Rx_SPICKSEL = {.msk = 0x0000000CU, .pos = 2};    /** @brief SPI clock select for channel 0. */
  static const field32_t DFSDM_DFSDM_CHCFG0Rx_SCDEN    = {.msk = 0x00000020U, .pos = 5};    /** @brief Short-circuit detector enable on channel 0. */
  static const field32_t DFSDM_DFSDM_CHCFG0Rx_CKABEN   = {.msk = 0x00000040U, .pos = 6};    /** @brief Clock absence detector enable on channel 0. */
  static const field32_t DFSDM_DFSDM_CHCFG0Rx_CHEN     = {.msk = 0x00000080U, .pos = 7};    /** @brief Channel 0 enable. */
  static const field32_t DFSDM_DFSDM_CHCFG0Rx_CHINSEL  = {.msk = 0x00000100U, .pos = 8};    /** @brief Channel inputs selection. */
  static const field32_t DFSDM_DFSDM_CHCFG0Rx_DATMPX   = {.msk = 0x00003000U, .pos = 12};   /** @brief Input data multiplexer for channel 0. */
  static const field32_t DFSDM_DFSDM_CHCFG0Rx_DATPACK  = {.msk = 0x0000C000U, .pos = 14};   /** @brief Data packing mode in dfsdm_chdatinyr register. */
  static const field32_t DFSDM_DFSDM_CHCFG0Rx_CKOUTDIV = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Output serial clock divider. */
  static const field32_t DFSDM_DFSDM_CHCFG0Rx_CKOUTSRC = {.msk = 0x40000000U, .pos = 30};   /** @brief Output serial clock source selection. */
  static const field32_t DFSDM_DFSDM_CHCFG0Rx_DFSDMEN  = {.msk = 0x80000000U, .pos = 31};   /** @brief Global enable for DFSDM interface. */
  static const field32_t DFSDM_DFSDM_CHCFGxR1_SITP     = {.msk = 0x00000003U, .pos = 0};    /** @brief Serial interface type for channel 1. */
  static const field32_t DFSDM_DFSDM_CHCFGxR1_SPICKSEL = {.msk = 0x0000000CU, .pos = 2};    /** @brief SPI clock select for channel 1. */
  static const field32_t DFSDM_DFSDM_CHCFGxR1_SCDEN    = {.msk = 0x00000020U, .pos = 5};    /** @brief Short-circuit detector enable on channel 1. */
  static const field32_t DFSDM_DFSDM_CHCFGxR1_CKABEN   = {.msk = 0x00000040U, .pos = 6};    /** @brief Clock absence detector enable on channel 1. */
  static const field32_t DFSDM_DFSDM_CHCFGxR1_CHEN     = {.msk = 0x00000080U, .pos = 7};    /** @brief Channel 1 enable. */
  static const field32_t DFSDM_DFSDM_CHCFGxR1_CHINSEL  = {.msk = 0x00000100U, .pos = 8};    /** @brief Channel inputs selection. */
  static const field32_t DFSDM_DFSDM_CHCFGxR1_DATMPX   = {.msk = 0x00003000U, .pos = 12};   /** @brief Input data multiplexer for channel 1. */
  static const field32_t DFSDM_DFSDM_CHCFGxR1_DATPACK  = {.msk = 0x0000C000U, .pos = 14};   /** @brief Data packing mode in dfsdm_chdatinyr register. */
  static const field32_t DFSDM_DFSDM_CHCFGxR1_CKOUTDIV = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Output serial clock divider. */
  static const field32_t DFSDM_DFSDM_CHCFGxR1_CKOUTSRC = {.msk = 0x40000000U, .pos = 30};   /** @brief Output serial clock source selection. */
  static const field32_t DFSDM_DFSDM_CHCFGxR1_DFSDMEN  = {.msk = 0x80000000U, .pos = 31};   /** @brief Global enable for DFSDM interface. */
  static const field32_t DFSDM_DFSDM_CHCFGxR2_DTRBS    = {.msk = 0x000000F8U, .pos = 3};    /** @brief Data right bit-shift for channel 1. */
  static const field32_t DFSDM_DFSDM_CHCFGxR2_OFFSET   = {.msk = 0xFFFFFF00U, .pos = 8};    /** @brief 24-bit calibration offset for channel 1. */
  static const field32_t DFSDM_DFSDM_AWSCDxR_SCDT      = {.msk = 0x000000FFU, .pos = 0};    /** @brief Short-circuit detector threshold for channel 0. */
  static const field32_t DFSDM_DFSDM_AWSCDxR_BKSCD     = {.msk = 0x0000F000U, .pos = 12};   /** @brief Break signal assignment for short-circuit detector on channel 0. */
  static const field32_t DFSDM_DFSDM_AWSCDxR_AWFOSR    = {.msk = 0x001F0000U, .pos = 16};   /** @brief Analog watchdog filter oversampling ratio (decimation rate) on channel 0. */
  static const field32_t DFSDM_DFSDM_AWSCDxR_AWFORD    = {.msk = 0x00C00000U, .pos = 22};   /** @brief Analog watchdog sinc filter order on channel 0. */
  static const field32_t DFSDM_DFSDM_CHWDATxR_WDATA    = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Input channel y watchdog data. */
  static const field32_t DFSDM_DFSDM0_CRx_DFEN         = {.msk = 0x00000001U, .pos = 0};    /** @brief DFSDM enable. */
  static const field32_t DFSDM_DFSDM0_CRx_JSWSTART     = {.msk = 0x00000002U, .pos = 1};    /** @brief Start a conversion of the injected group of channels. */
  static const field32_t DFSDM_DFSDM0_CRx_JSYNC        = {.msk = 0x00000008U, .pos = 3};    /** @brief Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger. */
  static const field32_t DFSDM_DFSDM0_CRx_JSCAN        = {.msk = 0x00000010U, .pos = 4};    /** @brief Scanning conversion mode for injected conversions. */
  static const field32_t DFSDM_DFSDM0_CRx_JDMAEN       = {.msk = 0x00000020U, .pos = 5};    /** @brief DMA channel enabled to read data for the injected channel group. */
  static const field32_t DFSDM_DFSDM0_CRx_JEXTSEL      = {.msk = 0x00001F00U, .pos = 8};    /** @brief Trigger signal selection for launching injected conversions. */
  static const field32_t DFSDM_DFSDM0_CRx_JEXTEN       = {.msk = 0x00006000U, .pos = 13};   /** @brief Trigger enable and trigger edge selection for injected conversions. */
  static const field32_t DFSDM_DFSDM0_CRx_RSWSTART     = {.msk = 0x00020000U, .pos = 17};   /** @brief Software start of a conversion on the regular channel. */
  static const field32_t DFSDM_DFSDM0_CRx_RCONT        = {.msk = 0x00040000U, .pos = 18};   /** @brief Continuous mode selection for regular conversions. */
  static const field32_t DFSDM_DFSDM0_CRx_RSYNC        = {.msk = 0x00080000U, .pos = 19};   /** @brief Launch regular conversion synchronously with DFSDM0. */
  static const field32_t DFSDM_DFSDM0_CRx_RDMAEN       = {.msk = 0x00200000U, .pos = 21};   /** @brief DMA channel enabled to read data for the regular conversion. */
  static const field32_t DFSDM_DFSDM0_CRx_RCH          = {.msk = 0x07000000U, .pos = 24};   /** @brief Regular channel selection. */
  static const field32_t DFSDM_DFSDM0_CRx_FAST         = {.msk = 0x20000000U, .pos = 29};   /** @brief Fast conversion mode selection for regular conversions. */
  static const field32_t DFSDM_DFSDM0_CRx_AWFSEL       = {.msk = 0x40000000U, .pos = 30};   /** @brief Analog watchdog fast mode select. */
  static const field32_t DFSDM_DFSDMx_CR1_DFEN         = {.msk = 0x00000001U, .pos = 0};    /** @brief DFSDM enable. */
  static const field32_t DFSDM_DFSDMx_CR1_JSWSTART     = {.msk = 0x00000002U, .pos = 1};    /** @brief Start a conversion of the injected group of channels. */
  static const field32_t DFSDM_DFSDMx_CR1_JSYNC        = {.msk = 0x00000008U, .pos = 3};    /** @brief Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger. */
  static const field32_t DFSDM_DFSDMx_CR1_JSCAN        = {.msk = 0x00000010U, .pos = 4};    /** @brief Scanning conversion mode for injected conversions. */
  static const field32_t DFSDM_DFSDMx_CR1_JDMAEN       = {.msk = 0x00000020U, .pos = 5};    /** @brief DMA channel enabled to read data for the injected channel group. */
  static const field32_t DFSDM_DFSDMx_CR1_JEXTSEL      = {.msk = 0x00001F00U, .pos = 8};    /** @brief Trigger signal selection for launching injected conversions. */
  static const field32_t DFSDM_DFSDMx_CR1_JEXTEN       = {.msk = 0x00006000U, .pos = 13};   /** @brief Trigger enable and trigger edge selection for injected conversions. */
  static const field32_t DFSDM_DFSDMx_CR1_RSWSTART     = {.msk = 0x00020000U, .pos = 17};   /** @brief Software start of a conversion on the regular channel. */
  static const field32_t DFSDM_DFSDMx_CR1_RCONT        = {.msk = 0x00040000U, .pos = 18};   /** @brief Continuous mode selection for regular conversions. */
  static const field32_t DFSDM_DFSDMx_CR1_RSYNC        = {.msk = 0x00080000U, .pos = 19};   /** @brief Launch regular conversion synchronously with DFSDM0. */
  static const field32_t DFSDM_DFSDMx_CR1_RDMAEN       = {.msk = 0x00200000U, .pos = 21};   /** @brief DMA channel enabled to read data for the regular conversion. */
  static const field32_t DFSDM_DFSDMx_CR1_RCH          = {.msk = 0x07000000U, .pos = 24};   /** @brief Regular channel selection. */
  static const field32_t DFSDM_DFSDMx_CR1_FAST         = {.msk = 0x20000000U, .pos = 29};   /** @brief Fast conversion mode selection for regular conversions. */
  static const field32_t DFSDM_DFSDMx_CR1_AWFSEL       = {.msk = 0x40000000U, .pos = 30};   /** @brief Analog watchdog fast mode select. */
  static const field32_t DFSDM_DFSDMx_CR2_JEOCIE       = {.msk = 0x00000001U, .pos = 0};    /** @brief Injected end of conversion interrupt enable. */
  static const field32_t DFSDM_DFSDMx_CR2_REOCIE       = {.msk = 0x00000002U, .pos = 1};    /** @brief Regular end of conversion interrupt enable. */
  static const field32_t DFSDM_DFSDMx_CR2_JOVRIE       = {.msk = 0x00000004U, .pos = 2};    /** @brief Injected data overrun interrupt enable. */
  static const field32_t DFSDM_DFSDMx_CR2_ROVRIE       = {.msk = 0x00000008U, .pos = 3};    /** @brief Regular data overrun interrupt enable. */
  static const field32_t DFSDM_DFSDMx_CR2_AWDIE        = {.msk = 0x00000010U, .pos = 4};    /** @brief Analog watchdog interrupt enable. */
  static const field32_t DFSDM_DFSDMx_CR2_SCDIE        = {.msk = 0x00000020U, .pos = 5};    /** @brief Short-circuit detector interrupt enable. */
  static const field32_t DFSDM_DFSDMx_CR2_CKABIE       = {.msk = 0x00000040U, .pos = 6};    /** @brief Clock absence interrupt enable. */
  static const field32_t DFSDM_DFSDMx_CR2_EXCH         = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Extremes detector channel selection. */
  static const field32_t DFSDM_DFSDMx_CR2_AWDCH        = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Analog watchdog channel selection. */
  static const field32_t DFSDM_DFSDMx_ISR_JEOCF        = {.msk = 0x00000001U, .pos = 0};    /** @brief End of injected conversion flag. */
  static const field32_t DFSDM_DFSDMx_ISR_REOCF        = {.msk = 0x00000002U, .pos = 1};    /** @brief End of regular conversion flag. */
  static const field32_t DFSDM_DFSDMx_ISR_JOVRF        = {.msk = 0x00000004U, .pos = 2};    /** @brief Injected conversion overrun flag. */
  static const field32_t DFSDM_DFSDMx_ISR_ROVRF        = {.msk = 0x00000008U, .pos = 3};    /** @brief Regular conversion overrun flag. */
  static const field32_t DFSDM_DFSDMx_ISR_AWDF         = {.msk = 0x00000010U, .pos = 4};    /** @brief Analog watchdog. */
  static const field32_t DFSDM_DFSDMx_ISR_JCIP         = {.msk = 0x00002000U, .pos = 13};   /** @brief Injected conversion in progress status. */
  static const field32_t DFSDM_DFSDMx_ISR_RCIP         = {.msk = 0x00004000U, .pos = 14};   /** @brief Regular conversion in progress status. */
  static const field32_t DFSDM_DFSDMx_ISR_CKABF        = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Clock absence flag. */
  static const field32_t DFSDM_DFSDMx_ISR_SCDF         = {.msk = 0xFF000000U, .pos = 24};   /** @brief Short-circuit detector flag. */
  static const field32_t DFSDM_DFSDMx_ICR_CLRJOVRF     = {.msk = 0x00000004U, .pos = 2};    /** @brief Clear the injected conversion overrun flag. */
  static const field32_t DFSDM_DFSDMx_ICR_CLRROVRF     = {.msk = 0x00000008U, .pos = 3};    /** @brief Clear the regular conversion overrun flag. */
  static const field32_t DFSDM_DFSDMx_ICR_CLRCKABF     = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Clear the clock absence flag. */
  static const field32_t DFSDM_DFSDMx_ICR_CLRSCDF      = {.msk = 0xFF000000U, .pos = 24};   /** @brief Clear the short-circuit detector flag. */
  static const field32_t DFSDM_DFSDMx_JCHGR_JCHG       = {.msk = 0x000000FFU, .pos = 0};    /** @brief Injected channel group selection. */
  static const field32_t DFSDM_DFSDMx_FCR_IOSR         = {.msk = 0x000000FFU, .pos = 0};    /** @brief Integrator oversampling ratio (averaging length). */
  static const field32_t DFSDM_DFSDMx_FCR_FOSR         = {.msk = 0x03FF0000U, .pos = 16};   /** @brief Sinc filter oversampling ratio (decimation rate). */
  static const field32_t DFSDM_DFSDMx_FCR_FORD         = {.msk = 0xE0000000U, .pos = 29};   /** @brief Sinc filter order. */
  static const field32_t DFSDM_DFSDMx_JDATAR_JDATACH   = {.msk = 0x00000007U, .pos = 0};    /** @brief Injected channel most recently converted. */
  static const field32_t DFSDM_DFSDMx_JDATAR_JDATA     = {.msk = 0xFFFFFF00U, .pos = 8};    /** @brief Injected group conversion data. */
  static const field32_t DFSDM_DFSDMx_RDATAR_RDATACH   = {.msk = 0x00000007U, .pos = 0};    /** @brief Regular channel most recently converted. */
  static const field32_t DFSDM_DFSDMx_RDATAR_RPEND     = {.msk = 0x00000010U, .pos = 4};    /** @brief Regular channel pending data. */
  static const field32_t DFSDM_DFSDMx_RDATAR_RDATA     = {.msk = 0xFFFFFF00U, .pos = 8};    /** @brief Regular channel conversion data. */
  static const field32_t DFSDM_DFSDMx_AWHTR_BKAWH      = {.msk = 0x0000000FU, .pos = 0};    /** @brief Break signal assignment to analog watchdog high threshold event. */
  static const field32_t DFSDM_DFSDMx_AWHTR_AWHT       = {.msk = 0xFFFFFF00U, .pos = 8};    /** @brief Analog watchdog high threshold. */
  static const field32_t DFSDM_DFSDMx_AWLTR_BKAWL      = {.msk = 0x0000000FU, .pos = 0};    /** @brief Break signal assignment to analog watchdog low threshold event. */
  static const field32_t DFSDM_DFSDMx_AWLTR_AWLT       = {.msk = 0xFFFFFF00U, .pos = 8};    /** @brief Analog watchdog low threshold. */
  static const field32_t DFSDM_DFSDMx_AWSR_AWLTF       = {.msk = 0x000000FFU, .pos = 0};    /** @brief Analog watchdog low threshold flag. */
  static const field32_t DFSDM_DFSDMx_AWSR_AWHTF       = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Analog watchdog high threshold flag. */
  static const field32_t DFSDM_DFSDMx_AWCFR_CLRAWLTF   = {.msk = 0x000000FFU, .pos = 0};    /** @brief Clear the analog watchdog low threshold flag. */
  static const field32_t DFSDM_DFSDMx_AWCFR_CLRAWHTF   = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Clear the analog watchdog high threshold flag. */
  static const field32_t DFSDM_DFSDMx_EXMAX_EXMAXCH    = {.msk = 0x00000007U, .pos = 0};    /** @brief Extremes detector maximum data channel. */
  static const field32_t DFSDM_DFSDMx_EXMAX_EXMAX      = {.msk = 0xFFFFFF00U, .pos = 8};    /** @brief Extremes detector maximum value. */
  static const field32_t DFSDM_DFSDMx_EXMIN_EXMINCH    = {.msk = 0x00000007U, .pos = 0};    /** @brief Extremes detector minimum data channel. */
  static const field32_t DFSDM_DFSDMx_EXMIN_EXMIN      = {.msk = 0xFFFFFF00U, .pos = 8};    /** @brief Extremes detector minimum value. */
  static const field32_t DFSDM_DFSDMx_CNVTIMR_CNVCNT   = {.msk = 0xFFFFFFF0U, .pos = 4};    /** @brief 28-bit timer counting conversion time. */

  /**** Enumerated DFSDM Register Field Definitions ****/

  static field32_t const DFSDM_DFSDM_CHDATINxR_INDATx[2] = {
    [0] = {.msk = 0x0000FFFFU, .pos = 0},    /** @brief Input data for channel 0. */
    [1] = {.msk = 0xFFFF0000U, .pos = 16},   /** @brief Input data for channel 1. */
  };

  /************************************************************************************************
   * G2_TIM1x Definitions
   ************************************************************************************************/

  /**** Enumerated G2_TIM1x Register Definitions ****/

  static const rw_reg32_t G2_TIM1x_CRx[8][3] = {
    [6] = {
      [1] = (rw_reg32_t)0x40014400U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40014404U,   /** @brief Control register 2. */
    },
    [7] = {
      [1] = (rw_reg32_t)0x40014800U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40014804U,   /** @brief Control register 2. */
    },
  };

  static const rw_reg32_t G2_TIM1x_DIER[8] = {
    [6] = (rw_reg32_t)0x4001440CU,   /** @brief DMA/Interrupt enable register. */
    [7] = (rw_reg32_t)0x4001480CU,   /** @brief DMA/Interrupt enable register. */
  };

  static const rw_reg32_t G2_TIM1x_SR[8] = {
    [6] = (rw_reg32_t)0x40014410U,   /** @brief Status register. */
    [7] = (rw_reg32_t)0x40014810U,   /** @brief Status register. */
  };

  static const rw_reg32_t G2_TIM1x_EGR[8] = {
    [6] = (rw_reg32_t)0x40014414U,   /** @brief Event generation register. */
    [7] = (rw_reg32_t)0x40014814U,   /** @brief Event generation register. */
  };

  static const rw_reg32_t G2_TIM1x_CCMR1_OUTPUT[8] = {
    [6] = (rw_reg32_t)0x40014418U,   /** @brief Capture/compare mode register (output mode). */
    [7] = (rw_reg32_t)0x40014818U,   /** @brief Capture/compare mode register (output mode). */
  };

  static const rw_reg32_t G2_TIM1x_CCMR1_INPUT[8] = {
    [6] = (rw_reg32_t)0x40014418U,   /** @brief Capture/compare mode register (output mode). */
    [7] = (rw_reg32_t)0x40014818U,   /** @brief Capture/compare mode register (output mode). */
  };

  static const rw_reg32_t G2_TIM1x_CCER[8] = {
    [6] = (rw_reg32_t)0x40014420U,   /** @brief Capture/compare enable register. */
    [7] = (rw_reg32_t)0x40014820U,   /** @brief Capture/compare enable register. */
  };

  static const rw_reg32_t G2_TIM1x_CNT[8] = {
    [6] = (rw_reg32_t)0x40014424U,   /** @brief Counter. */
    [7] = (rw_reg32_t)0x40014824U,   /** @brief Counter. */
  };

  static const rw_reg32_t G2_TIM1x_PSC[8] = {
    [6] = (rw_reg32_t)0x40014428U,   /** @brief Prescaler. */
    [7] = (rw_reg32_t)0x40014828U,   /** @brief Prescaler. */
  };

  static const rw_reg32_t G2_TIM1x_ARR[8] = {
    [6] = (rw_reg32_t)0x4001442CU,   /** @brief Auto-reload register. */
    [7] = (rw_reg32_t)0x4001482CU,   /** @brief Auto-reload register. */
  };

  static const rw_reg32_t G2_TIM1x_RCR[8] = {
    [6] = (rw_reg32_t)0x40014430U,   /** @brief Repetition counter register. */
    [7] = (rw_reg32_t)0x40014830U,   /** @brief Repetition counter register. */
  };

  static const rw_reg32_t G2_TIM1x_CCR1[8] = {
    [6] = (rw_reg32_t)0x40014434U,   /** @brief Capture/compare register 1. */
    [7] = (rw_reg32_t)0x40014834U,   /** @brief Capture/compare register 1. */
  };

  static const rw_reg32_t G2_TIM1x_BDTR[8] = {
    [6] = (rw_reg32_t)0x40014444U,   /** @brief Break and dead-time register. */
    [7] = (rw_reg32_t)0x40014844U,   /** @brief Break and dead-time register. */
  };

  static const rw_reg32_t G2_TIM1x_DCR[8] = {
    [6] = (rw_reg32_t)0x40014448U,   /** @brief DMA control register. */
    [7] = (rw_reg32_t)0x40014848U,   /** @brief DMA control register. */
  };

  static const rw_reg32_t G2_TIM1x_DMAR[8] = {
    [6] = (rw_reg32_t)0x4001444CU,   /** @brief DMA address for full transfer. */
    [7] = (rw_reg32_t)0x4001484CU,   /** @brief DMA address for full transfer. */
  };

  static const rw_reg32_t G2_TIM1x_TIM16_AF1[8] = {
    [6] = (rw_reg32_t)0x40014460U,   /** @brief TIM16 alternate function register 1. */
    [7] = (rw_reg32_t)0x40014860U,   /** @brief TIM17 alternate function register 1. */
  };

  static const rw_reg32_t G2_TIM1x_TIM16_TISEL[8] = {
    [6] = (rw_reg32_t)0x40014468U,   /** @brief TIM16 input selection register. */
    [7] = (rw_reg32_t)0x40014868U,   /** @brief TIM17 input selection register. */
  };

  /**** G2_TIM1x Register Field Definitions ****/

  static const field32_t G2_TIM1x_CRx_CEN             = {.msk = 0x00000001U, .pos = 0};    /** @brief Counter enable. */
  static const field32_t G2_TIM1x_CRx_UDIS            = {.msk = 0x00000002U, .pos = 1};    /** @brief Update disable. */
  static const field32_t G2_TIM1x_CRx_URS             = {.msk = 0x00000004U, .pos = 2};    /** @brief Update request source. */
  static const field32_t G2_TIM1x_CRx_OPM             = {.msk = 0x00000008U, .pos = 3};    /** @brief One-pulse mode. */
  static const field32_t G2_TIM1x_CRx_ARPE            = {.msk = 0x00000080U, .pos = 7};    /** @brief Auto-reload preload enable. */
  static const field32_t G2_TIM1x_CRx_CKD             = {.msk = 0x00000300U, .pos = 8};    /** @brief Clock division. */
  static const field32_t G2_TIM1x_CRx_UIFREMAP        = {.msk = 0x00000800U, .pos = 11};   /** @brief UIF status bit remapping. */
  static const field32_t G2_TIM1x_DIER_UIE            = {.msk = 0x00000001U, .pos = 0};    /** @brief Update interrupt enable. */
  static const field32_t G2_TIM1x_DIER_CC1IE          = {.msk = 0x00000002U, .pos = 1};    /** @brief Capture/Compare 1 interrupt enable. */
  static const field32_t G2_TIM1x_DIER_COMIE          = {.msk = 0x00000020U, .pos = 5};    /** @brief COM interrupt enable. */
  static const field32_t G2_TIM1x_DIER_BIE            = {.msk = 0x00000080U, .pos = 7};    /** @brief Break interrupt enable. */
  static const field32_t G2_TIM1x_DIER_UDE            = {.msk = 0x00000100U, .pos = 8};    /** @brief Update DMA request enable. */
  static const field32_t G2_TIM1x_DIER_CC1DE          = {.msk = 0x00000200U, .pos = 9};    /** @brief Capture/Compare 1 DMA request enable. */
  static const field32_t G2_TIM1x_DIER_COMDE          = {.msk = 0x00002000U, .pos = 13};   /** @brief COM DMA request enable. */
  static const field32_t G2_TIM1x_SR_CC1OF            = {.msk = 0x00000200U, .pos = 9};    /** @brief Capture/Compare 1 overcapture flag. */
  static const field32_t G2_TIM1x_SR_BIF              = {.msk = 0x00000080U, .pos = 7};    /** @brief Break interrupt flag. */
  static const field32_t G2_TIM1x_SR_COMIF            = {.msk = 0x00000020U, .pos = 5};    /** @brief COM interrupt flag. */
  static const field32_t G2_TIM1x_SR_CC1IF            = {.msk = 0x00000002U, .pos = 1};    /** @brief Capture/compare 1 interrupt flag. */
  static const field32_t G2_TIM1x_SR_UIF              = {.msk = 0x00000001U, .pos = 0};    /** @brief Update interrupt flag. */
  static const field32_t G2_TIM1x_EGR_BG              = {.msk = 0x00000080U, .pos = 7};    /** @brief Break generation. */
  static const field32_t G2_TIM1x_EGR_COMG            = {.msk = 0x00000020U, .pos = 5};    /** @brief Capture/Compare control update generation. */
  static const field32_t G2_TIM1x_EGR_CC1G            = {.msk = 0x00000002U, .pos = 1};    /** @brief Capture/compare 1 generation. */
  static const field32_t G2_TIM1x_EGR_UG              = {.msk = 0x00000001U, .pos = 0};    /** @brief Update generation. */
  static const field32_t G2_TIM1x_CCMR1_OUTPUT_CC1S   = {.msk = 0x00000003U, .pos = 0};    /** @brief Capture/Compare 1 selection. */
  static const field32_t G2_TIM1x_CCMR1_OUTPUT_OC1FE  = {.msk = 0x00000004U, .pos = 2};    /** @brief Output compare 1 fast enable. */
  static const field32_t G2_TIM1x_CCMR1_OUTPUT_OC1PE  = {.msk = 0x00000008U, .pos = 3};    /** @brief Output compare 1 preload enable. */
  static const field32_t G2_TIM1x_CCMR1_OUTPUT_OC1M   = {.msk = 0x00000070U, .pos = 4};    /** @brief Output compare 1 mode. */
  static const field32_t G2_TIM1x_CCMR1_OUTPUT_OC1M_3 = {.msk = 0x00010000U, .pos = 16};   /** @brief Output compare 1 mode. */
  static const field32_t G2_TIM1x_CCMR1_INPUT_IC1F    = {.msk = 0x000000F0U, .pos = 4};    /** @brief Input capture 1 filter. */
  static const field32_t G2_TIM1x_CCMR1_INPUT_IC1PSC  = {.msk = 0x0000000CU, .pos = 2};    /** @brief Input capture 1 prescaler. */
  static const field32_t G2_TIM1x_CCMR1_INPUT_CC1S    = {.msk = 0x00000003U, .pos = 0};    /** @brief Capture/Compare 1 selection. */
  static const field32_t G2_TIM1x_CCER_CC1NP          = {.msk = 0x00000008U, .pos = 3};    /** @brief Capture/Compare 1 output polarity. */
  static const field32_t G2_TIM1x_CCER_CC1NE          = {.msk = 0x00000004U, .pos = 2};    /** @brief Capture/Compare 1 complementary output enable. */
  static const field32_t G2_TIM1x_CCER_CC1P           = {.msk = 0x00000002U, .pos = 1};    /** @brief Capture/Compare 1 output polarity. */
  static const field32_t G2_TIM1x_CCER_CC1E           = {.msk = 0x00000001U, .pos = 0};    /** @brief Capture/Compare 1 output enable. */
  static const field32_t G2_TIM1x_CNT_CNT             = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Counter value. */
  static const field32_t G2_TIM1x_CNT_UIFCPY          = {.msk = 0x80000000U, .pos = 31};   /** @brief UIF copy. */
  static const field32_t G2_TIM1x_PSC_PSC             = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Prescaler value. */
  static const field32_t G2_TIM1x_ARR_ARR             = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Auto-reload value. */
  static const field32_t G2_TIM1x_RCR_REP             = {.msk = 0x000000FFU, .pos = 0};    /** @brief Repetition counter value. */
  static const field32_t G2_TIM1x_CCR1_CCR1           = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Capture/Compare 1 value. */
  static const field32_t G2_TIM1x_BDTR_DTG            = {.msk = 0x000000FFU, .pos = 0};    /** @brief Dead-time generator setup. */
  static const field32_t G2_TIM1x_BDTR_LOCK           = {.msk = 0x00000300U, .pos = 8};    /** @brief Lock configuration. */
  static const field32_t G2_TIM1x_BDTR_OSSI           = {.msk = 0x00000400U, .pos = 10};   /** @brief Off-state selection for idle mode. */
  static const field32_t G2_TIM1x_BDTR_OSSR           = {.msk = 0x00000800U, .pos = 11};   /** @brief Off-state selection for run mode. */
  static const field32_t G2_TIM1x_BDTR_BKE            = {.msk = 0x00001000U, .pos = 12};   /** @brief Break enable. */
  static const field32_t G2_TIM1x_BDTR_BKP            = {.msk = 0x00002000U, .pos = 13};   /** @brief Break polarity. */
  static const field32_t G2_TIM1x_BDTR_AOE            = {.msk = 0x00004000U, .pos = 14};   /** @brief Automatic output enable. */
  static const field32_t G2_TIM1x_BDTR_MOE            = {.msk = 0x00008000U, .pos = 15};   /** @brief Main output enable. */
  static const field32_t G2_TIM1x_BDTR_BKF            = {.msk = 0x000F0000U, .pos = 16};   /** @brief Break filter. */
  static const field32_t G2_TIM1x_DCR_DBL             = {.msk = 0x00001F00U, .pos = 8};    /** @brief DMA burst length. */
  static const field32_t G2_TIM1x_DCR_DBA             = {.msk = 0x0000001FU, .pos = 0};    /** @brief DMA base address. */
  static const field32_t G2_TIM1x_DMAR_DMAB           = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief DMA register for burst accesses. */
  static const field32_t G2_TIM1x_TIM16_AF1_BKINE     = {.msk = 0x00000001U, .pos = 0};    /** @brief BRK BKIN input enable. */
  static const field32_t G2_TIM1x_TIM16_AF1_BKDFBK1E  = {.msk = 0x00000100U, .pos = 8};    /** @brief BRK dfsdm1_break[1] enable. */
  static const field32_t G2_TIM1x_TIM16_AF1_BKINP     = {.msk = 0x00000200U, .pos = 9};    /** @brief BRK BKIN input polarity. */
  static const field32_t G2_TIM1x_TIM16_TISEL_TI1SEL  = {.msk = 0x0000000FU, .pos = 0};    /** @brief Selects TI1[0] to TI1[15] input. */

  /**** Enumerated G2_TIM1x Register Field Definitions ****/

  static field32_t const G2_TIM1x_TIM16_AF1_BKCMPxE[3] = {
    [1] = {.msk = 0x00000002U, .pos = 1},   /** @brief BRK COMP1 enable. */
    [2] = {.msk = 0x00000004U, .pos = 2},   /** @brief BRK COMP2 enable. */
  };

  static field32_t const G2_TIM1x_TIM16_AF1_BKCMPxP[3] = {
    [1] = {.msk = 0x00000400U, .pos = 10},   /** @brief BRK COMP1 input polarity. */
    [2] = {.msk = 0x00000800U, .pos = 11},   /** @brief BRK COMP2 input polarity. */
  };

  /************************************************************************************************
   * TIM15 Definitions
   ************************************************************************************************/

  /**** TIM15 Register Definitions ****/

  static const rw_reg32_t TIM15_SMCR         = (rw_reg32_t)0x40014008U;   /** @brief Slave mode control register. */
  static const rw_reg32_t TIM15_DIER         = (rw_reg32_t)0x4001400CU;   /** @brief DMA/Interrupt enable register. */
  static const rw_reg32_t TIM15_SR           = (rw_reg32_t)0x40014010U;   /** @brief Status register. */
  static const rw_reg32_t TIM15_EGR          = (rw_reg32_t)0x40014014U;   /** @brief Event generation register. */
  static const rw_reg32_t TIM15_CCMR1_OUTPUT = (rw_reg32_t)0x40014018U;   /** @brief Capture/compare mode register (output mode). */
  static const rw_reg32_t TIM15_CCMR1_INPUT  = (rw_reg32_t)0x40014018U;   /** @brief Capture/compare mode register 1 (input mode). */
  static const rw_reg32_t TIM15_CCER         = (rw_reg32_t)0x40014020U;   /** @brief Capture/compare enable register. */
  static const rw_reg32_t TIM15_CNT          = (rw_reg32_t)0x40014024U;   /** @brief Counter. */
  static const rw_reg32_t TIM15_PSC          = (rw_reg32_t)0x40014028U;   /** @brief Prescaler. */
  static const rw_reg32_t TIM15_ARR          = (rw_reg32_t)0x4001402CU;   /** @brief Auto-reload register. */
  static const rw_reg32_t TIM15_RCR          = (rw_reg32_t)0x40014030U;   /** @brief Repetition counter register. */
  static const rw_reg32_t TIM15_BDTR         = (rw_reg32_t)0x40014044U;   /** @brief Break and dead-time register. */
  static const rw_reg32_t TIM15_DCR          = (rw_reg32_t)0x40014048U;   /** @brief DMA control register. */
  static const rw_reg32_t TIM15_DMAR         = (rw_reg32_t)0x4001404CU;   /** @brief DMA address for full transfer. */
  static const rw_reg32_t TIM15_AF1          = (rw_reg32_t)0x40014060U;   /** @brief TIM15 alternate fdfsdm1_breakon register 1. */
  static const rw_reg32_t TIM15_TISEL        = (rw_reg32_t)0x40014068U;   /** @brief TIM15 input selection register. */

  /**** Enumerated TIM15 Register Definitions ****/

  static const rw_reg32_t TIM15_CRx[3] = {
    [1] = (rw_reg32_t)0x40014000U,   /** @brief Control register 1. */
    [2] = (rw_reg32_t)0x40014004U,   /** @brief Control register 2. */
  };

  static const rw_reg32_t TIM15_CCRx[3] = {
    [1] = (rw_reg32_t)0x40014034U,   /** @brief Capture/compare register 1. */
    [2] = (rw_reg32_t)0x40014038U,   /** @brief Capture/compare register 2. */
  };

  /**** TIM15 Register Field Definitions ****/

  static const field32_t TIM15_CRx_CEN       = {.msk = 0x00000001U, .pos = 0};    /** @brief Counter enable. */
  static const field32_t TIM15_CRx_UDIS      = {.msk = 0x00000002U, .pos = 1};    /** @brief Update disable. */
  static const field32_t TIM15_CRx_URS       = {.msk = 0x00000004U, .pos = 2};    /** @brief Update request source. */
  static const field32_t TIM15_CRx_OPM       = {.msk = 0x00000008U, .pos = 3};    /** @brief One-pulse mode. */
  static const field32_t TIM15_CRx_ARPE      = {.msk = 0x00000080U, .pos = 7};    /** @brief Auto-reload preload enable. */
  static const field32_t TIM15_CRx_CKD       = {.msk = 0x00000300U, .pos = 8};    /** @brief Clock division. */
  static const field32_t TIM15_CRx_UIFREMAP  = {.msk = 0x00000800U, .pos = 11};   /** @brief UIF status bit remapping. */
  static const field32_t TIM15_SMCR_SMS      = {.msk = 0x00000007U, .pos = 0};    /** @brief Slave mode selection. */
  static const field32_t TIM15_SMCR_TS_2_0   = {.msk = 0x00000070U, .pos = 4};    /** @brief Trigger selection. */
  static const field32_t TIM15_SMCR_MSM      = {.msk = 0x00000080U, .pos = 7};    /** @brief Master/Slave mode. */
  static const field32_t TIM15_SMCR_SMS_3    = {.msk = 0x00010000U, .pos = 16};   /** @brief Slave mode selection bit 3. */
  static const field32_t TIM15_SMCR_TS_4_3   = {.msk = 0x00300000U, .pos = 20};   /** @brief Trigger selection - bit 4:3. */
  static const field32_t TIM15_DIER_UIE      = {.msk = 0x00000001U, .pos = 0};    /** @brief Update interrupt enable. */
  static const field32_t TIM15_DIER_COMIE    = {.msk = 0x00000020U, .pos = 5};    /** @brief COM interrupt enable. */
  static const field32_t TIM15_DIER_TIE      = {.msk = 0x00000040U, .pos = 6};    /** @brief Trigger interrupt enable. */
  static const field32_t TIM15_DIER_BIE      = {.msk = 0x00000080U, .pos = 7};    /** @brief Break interrupt enable. */
  static const field32_t TIM15_DIER_UDE      = {.msk = 0x00000100U, .pos = 8};    /** @brief Update DMA request enable. */
  static const field32_t TIM15_DIER_COMDE    = {.msk = 0x00002000U, .pos = 13};   /** @brief COM DMA request enable. */
  static const field32_t TIM15_DIER_TDE      = {.msk = 0x00004000U, .pos = 14};   /** @brief Trigger DMA request enable. */
  static const field32_t TIM15_SR_BIF        = {.msk = 0x00000080U, .pos = 7};    /** @brief Break interrupt flag. */
  static const field32_t TIM15_SR_TIF        = {.msk = 0x00000040U, .pos = 6};    /** @brief Trigger interrupt flag. */
  static const field32_t TIM15_SR_COMIF      = {.msk = 0x00000020U, .pos = 5};    /** @brief COM interrupt flag. */
  static const field32_t TIM15_SR_UIF        = {.msk = 0x00000001U, .pos = 0};    /** @brief Update interrupt flag. */
  static const field32_t TIM15_EGR_BG        = {.msk = 0x00000080U, .pos = 7};    /** @brief Break generation. */
  static const field32_t TIM15_EGR_TG        = {.msk = 0x00000040U, .pos = 6};    /** @brief Trigger generation. */
  static const field32_t TIM15_EGR_COMG      = {.msk = 0x00000020U, .pos = 5};    /** @brief Capture/Compare control update generation. */
  static const field32_t TIM15_EGR_UG        = {.msk = 0x00000001U, .pos = 0};    /** @brief Update generation. */
  static const field32_t TIM15_CCER_CC1NE    = {.msk = 0x00000004U, .pos = 2};    /** @brief Capture/Compare 1 complementary output enable. */
  static const field32_t TIM15_CNT_CNT       = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Counter value. */
  static const field32_t TIM15_CNT_UIFCPY    = {.msk = 0x80000000U, .pos = 31};   /** @brief UIF copy. */
  static const field32_t TIM15_PSC_PSC       = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Prescaler value. */
  static const field32_t TIM15_ARR_ARR       = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Auto-reload value. */
  static const field32_t TIM15_RCR_REP       = {.msk = 0x000000FFU, .pos = 0};    /** @brief Repetition counter value. */
  static const field32_t TIM15_CCRx_CCR1     = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Capture/Compare 1 value. */
  static const field32_t TIM15_BDTR_MOE      = {.msk = 0x00008000U, .pos = 15};   /** @brief Main output enable. */
  static const field32_t TIM15_BDTR_AOE      = {.msk = 0x00004000U, .pos = 14};   /** @brief Automatic output enable. */
  static const field32_t TIM15_BDTR_BKP      = {.msk = 0x00002000U, .pos = 13};   /** @brief Break polarity. */
  static const field32_t TIM15_BDTR_BKE      = {.msk = 0x00001000U, .pos = 12};   /** @brief Break enable. */
  static const field32_t TIM15_BDTR_OSSR     = {.msk = 0x00000800U, .pos = 11};   /** @brief Off-state selection for run mode. */
  static const field32_t TIM15_BDTR_OSSI     = {.msk = 0x00000400U, .pos = 10};   /** @brief Off-state selection for idle mode. */
  static const field32_t TIM15_BDTR_LOCK     = {.msk = 0x00000300U, .pos = 8};    /** @brief Lock configuration. */
  static const field32_t TIM15_BDTR_DTG      = {.msk = 0x000000FFU, .pos = 0};    /** @brief Dead-time generator setup. */
  static const field32_t TIM15_BDTR_BKF      = {.msk = 0x000F0000U, .pos = 16};   /** @brief Break filter. */
  static const field32_t TIM15_DCR_DBL       = {.msk = 0x00001F00U, .pos = 8};    /** @brief DMA burst length. */
  static const field32_t TIM15_DCR_DBA       = {.msk = 0x0000001FU, .pos = 0};    /** @brief DMA base address. */
  static const field32_t TIM15_DMAR_DMAB     = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief DMA register for burst accesses. */
  static const field32_t TIM15_AF1_BKINE     = {.msk = 0x00000001U, .pos = 0};    /** @brief BRK BKIN input enable. */
  static const field32_t TIM15_AF1_BKDF1BK0E = {.msk = 0x00000100U, .pos = 8};    /** @brief BRK dfsdm1_break[0] enable. */
  static const field32_t TIM15_AF1_BKINP     = {.msk = 0x00000200U, .pos = 9};    /** @brief BRK BKIN input polarity. */

  /**** Enumerated TIM15 Register Field Definitions ****/

  static field32_t const TIM15_DIER_CCxIE[3] = {
    [1] = {.msk = 0x00000002U, .pos = 1},   /** @brief Capture/Compare 1 interrupt enable. */
    [2] = {.msk = 0x00000004U, .pos = 2},   /** @brief Capture/Compare 2 interrupt enable. */
  };

  static field32_t const TIM15_DIER_CCxDE[3] = {
    [1] = {.msk = 0x00000200U, .pos = 9},    /** @brief Capture/Compare 1 DMA request enable. */
    [2] = {.msk = 0x00000400U, .pos = 10},   /** @brief Capture/Compare 2 DMA request enable. */
  };

  static field32_t const TIM15_SR_CCxOF[3] = {
    [1] = {.msk = 0x00000200U, .pos = 9},    /** @brief Capture/Compare 1 overcapture flag. */
    [2] = {.msk = 0x00000400U, .pos = 10},   /** @brief Capture/compare 2 overcapture flag. */
  };

  static field32_t const TIM15_SR_CCxIF[3] = {
    [1] = {.msk = 0x00000002U, .pos = 1},   /** @brief Capture/compare 1 interrupt flag. */
    [2] = {.msk = 0x00000004U, .pos = 2},   /** @brief Capture/Compare 2 interrupt flag. */
  };

  static field32_t const TIM15_EGR_CCxG[3] = {
    [1] = {.msk = 0x00000002U, .pos = 1},   /** @brief Capture/compare 1 generation. */
    [2] = {.msk = 0x00000004U, .pos = 2},   /** @brief Capture/compare 2 generation. */
  };

  static field32_t const TIM15_CCMR1_OUTPUT_CCxS[3] = {
    [1] = {.msk = 0x00000003U, .pos = 0},   /** @brief Capture/Compare 1 selection. */
    [2] = {.msk = 0x00000300U, .pos = 8},   /** @brief Capture/Compare 2 selection. */
  };

  static field32_t const TIM15_CCMR1_OUTPUT_OCxFE[3] = {
    [1] = {.msk = 0x00000004U, .pos = 2},    /** @brief Output compare 1 fast enable. */
    [2] = {.msk = 0x00000400U, .pos = 10},   /** @brief Output compare 2 fast enable. */
  };

  static field32_t const TIM15_CCMR1_OUTPUT_OCxPE[3] = {
    [1] = {.msk = 0x00000008U, .pos = 3},    /** @brief Output compare 1 preload enable. */
    [2] = {.msk = 0x00000800U, .pos = 11},   /** @brief Output compare 2 preload enable. */
  };

  static field32_t const TIM15_CCMR1_OUTPUT_OCxM[3] = {
    [1] = {.msk = 0x00000070U, .pos = 4},    /** @brief Output compare 1 mode. */
    [2] = {.msk = 0x00007000U, .pos = 12},   /** @brief Output compare 2 mode. */
  };

  static field32_t const TIM15_CCMR1_OUTPUT_OCxM_3[3] = {
    [1] = {.msk = 0x00010000U, .pos = 16},   /** @brief Output compare 1 mode bit 3. */
    [2] = {.msk = 0x01000000U, .pos = 24},   /** @brief Output compare 2 mode bit 3. */
  };

  static field32_t const TIM15_CCMR1_INPUT_ICxF[3] = {
    [1] = {.msk = 0x000000F0U, .pos = 4},    /** @brief Input capture 1 filter. */
    [2] = {.msk = 0x0000F000U, .pos = 12},   /** @brief Input capture 2 filter. */
  };

  static field32_t const TIM15_CCMR1_INPUT_ICxPSC[3] = {
    [1] = {.msk = 0x0000000CU, .pos = 2},    /** @brief Input capture 1 prescaler. */
    [2] = {.msk = 0x00000C00U, .pos = 10},   /** @brief Input capture 2 prescaler. */
  };

  static field32_t const TIM15_CCER_CCxNP[3] = {
    [1] = {.msk = 0x00000008U, .pos = 3},   /** @brief Capture/Compare 1 output polarity. */
    [2] = {.msk = 0x00000080U, .pos = 7},   /** @brief Capture/Compare 2 output polarity. */
  };

  static field32_t const TIM15_CCER_CCxP[3] = {
    [1] = {.msk = 0x00000002U, .pos = 1},   /** @brief Capture/Compare 1 output polarity. */
    [2] = {.msk = 0x00000020U, .pos = 5},   /** @brief Capture/Compare 2 output polarity. */
  };

  static field32_t const TIM15_CCER_CCxE[3] = {
    [1] = {.msk = 0x00000001U, .pos = 0},   /** @brief Capture/Compare 1 output enable. */
    [2] = {.msk = 0x00000010U, .pos = 4},   /** @brief Capture/Compare 2 output enable. */
  };

  static field32_t const TIM15_AF1_BKCMPxE[3] = {
    [1] = {.msk = 0x00000002U, .pos = 1},   /** @brief BRK COMP1 enable. */
    [2] = {.msk = 0x00000004U, .pos = 2},   /** @brief BRK COMP2 enable. */
  };

  static field32_t const TIM15_AF1_BKCMPxP[3] = {
    [1] = {.msk = 0x00000400U, .pos = 10},   /** @brief BRK COMP1 input polarity. */
    [2] = {.msk = 0x00000800U, .pos = 11},   /** @brief BRK COMP2 input polarity. */
  };

  static field32_t const TIM15_TISEL_TIxSEL[3] = {
    [1] = {.msk = 0x0000000FU, .pos = 0},   /** @brief Selects TI1[0] to TI1[15] input. */
    [2] = {.msk = 0x00000F00U, .pos = 8},   /** @brief Selects TI2[0] to TI2[15] input. */
  };

  /************************************************************************************************
   * USARTx Definitions
   ************************************************************************************************/

  /**** Enumerated USARTx Register Definitions ****/

  static const rw_reg32_t USARTx_CRx[7][4] = {
    [1] = {
      [1] = (rw_reg32_t)0x40011000U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40011004U,   /** @brief Control register 2. */
      [3] = (rw_reg32_t)0x40011008U,   /** @brief Control register 3. */
    },
    [2] = {
      [1] = (rw_reg32_t)0x40004400U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40004404U,   /** @brief Control register 2. */
      [3] = (rw_reg32_t)0x40004408U,   /** @brief Control register 3. */
    },
    [3] = {
      [1] = (rw_reg32_t)0x40004800U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40004804U,   /** @brief Control register 2. */
      [3] = (rw_reg32_t)0x40004808U,   /** @brief Control register 3. */
    },
    [6] = {
      [1] = (rw_reg32_t)0x40011400U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40011404U,   /** @brief Control register 2. */
      [3] = (rw_reg32_t)0x40011408U,   /** @brief Control register 3. */
    },
  };

  static const rw_reg32_t USARTx_BRR[7] = {
    [1] = (rw_reg32_t)0x4001100CU,   /** @brief Baud rate register. */
    [2] = (rw_reg32_t)0x4000440CU,   /** @brief Baud rate register. */
    [3] = (rw_reg32_t)0x4000480CU,   /** @brief Baud rate register. */
    [6] = (rw_reg32_t)0x4001140CU,   /** @brief Baud rate register. */
  };

  static const rw_reg32_t USARTx_GTPR[7] = {
    [1] = (rw_reg32_t)0x40011010U,   /** @brief Guard time and prescaler register. */
    [2] = (rw_reg32_t)0x40004410U,   /** @brief Guard time and prescaler register. */
    [3] = (rw_reg32_t)0x40004810U,   /** @brief Guard time and prescaler register. */
    [6] = (rw_reg32_t)0x40011410U,   /** @brief Guard time and prescaler register. */
  };

  static const rw_reg32_t USARTx_RTOR[7] = {
    [1] = (rw_reg32_t)0x40011014U,   /** @brief Receiver timeout register. */
    [2] = (rw_reg32_t)0x40004414U,   /** @brief Receiver timeout register. */
    [3] = (rw_reg32_t)0x40004814U,   /** @brief Receiver timeout register. */
    [6] = (rw_reg32_t)0x40011414U,   /** @brief Receiver timeout register. */
  };

  static const rw_reg32_t USARTx_RQR[7] = {
    [1] = (rw_reg32_t)0x40011018U,   /** @brief Request register. */
    [2] = (rw_reg32_t)0x40004418U,   /** @brief Request register. */
    [3] = (rw_reg32_t)0x40004818U,   /** @brief Request register. */
    [6] = (rw_reg32_t)0x40011418U,   /** @brief Request register. */
  };

  static const ro_reg32_t USARTx_ISR[7] = {
    [1] = (ro_reg32_t)0x4001101CU,   /** @brief Interrupt & status register. */
    [2] = (ro_reg32_t)0x4000441CU,   /** @brief Interrupt & status register. */
    [3] = (ro_reg32_t)0x4000481CU,   /** @brief Interrupt & status register. */
    [6] = (ro_reg32_t)0x4001141CU,   /** @brief Interrupt & status register. */
  };

  static const rw_reg32_t USARTx_ICR[7] = {
    [1] = (rw_reg32_t)0x40011020U,   /** @brief Interrupt flag clear register. */
    [2] = (rw_reg32_t)0x40004420U,   /** @brief Interrupt flag clear register. */
    [3] = (rw_reg32_t)0x40004820U,   /** @brief Interrupt flag clear register. */
    [6] = (rw_reg32_t)0x40011420U,   /** @brief Interrupt flag clear register. */
  };

  static const ro_reg32_t USARTx_RDR[7] = {
    [1] = (ro_reg32_t)0x40011024U,   /** @brief Receive data register. */
    [2] = (ro_reg32_t)0x40004424U,   /** @brief Receive data register. */
    [3] = (ro_reg32_t)0x40004824U,   /** @brief Receive data register. */
    [6] = (ro_reg32_t)0x40011424U,   /** @brief Receive data register. */
  };

  static const rw_reg32_t USARTx_TDR[7] = {
    [1] = (rw_reg32_t)0x40011028U,   /** @brief Transmit data register. */
    [2] = (rw_reg32_t)0x40004428U,   /** @brief Transmit data register. */
    [3] = (rw_reg32_t)0x40004828U,   /** @brief Transmit data register. */
    [6] = (rw_reg32_t)0x40011428U,   /** @brief Transmit data register. */
  };

  static const rw_reg32_t USARTx_PRESC[7] = {
    [1] = (rw_reg32_t)0x4001102CU,   /** @brief USART prescaler register. */
    [2] = (rw_reg32_t)0x4000442CU,   /** @brief USART prescaler register. */
    [3] = (rw_reg32_t)0x4000482CU,   /** @brief USART prescaler register. */
    [6] = (rw_reg32_t)0x4001142CU,   /** @brief USART prescaler register. */
  };

  /**** USARTx Register Field Definitions ****/

  static const field32_t USARTx_CRx_RXFFIE      = {.msk = 0x80000000U, .pos = 31};   /** @brief RXFIFO full interrupt enable. */
  static const field32_t USARTx_CRx_TXFEIE      = {.msk = 0x40000000U, .pos = 30};   /** @brief TXFIFO empty interrupt enable. */
  static const field32_t USARTx_CRx_FIFOEN      = {.msk = 0x20000000U, .pos = 29};   /** @brief FIFO mode enable. */
  static const field32_t USARTx_CRx_EOBIE       = {.msk = 0x08000000U, .pos = 27};   /** @brief End of block interrupt enable. */
  static const field32_t USARTx_CRx_RTOIE       = {.msk = 0x04000000U, .pos = 26};   /** @brief Receiver timeout interrupt enable. */
  static const field32_t USARTx_CRx_OVER8       = {.msk = 0x00008000U, .pos = 15};   /** @brief Oversampling mode. */
  static const field32_t USARTx_CRx_CMIE        = {.msk = 0x00004000U, .pos = 14};   /** @brief Character match interrupt enable. */
  static const field32_t USARTx_CRx_MME         = {.msk = 0x00002000U, .pos = 13};   /** @brief Mute mode enable. */
  static const field32_t USARTx_CRx_WAKE        = {.msk = 0x00000800U, .pos = 11};   /** @brief Receiver wakeup method. */
  static const field32_t USARTx_CRx_PCE         = {.msk = 0x00000400U, .pos = 10};   /** @brief Parity control enable. */
  static const field32_t USARTx_CRx_PS          = {.msk = 0x00000200U, .pos = 9};    /** @brief Parity selection. */
  static const field32_t USARTx_CRx_PEIE        = {.msk = 0x00000100U, .pos = 8};    /** @brief PE interrupt enable. */
  static const field32_t USARTx_CRx_TXEIE       = {.msk = 0x00000080U, .pos = 7};    /** @brief Interrupt enable. */
  static const field32_t USARTx_CRx_TCIE        = {.msk = 0x00000040U, .pos = 6};    /** @brief Transmission complete interrupt enable. */
  static const field32_t USARTx_CRx_RXNEIE      = {.msk = 0x00000020U, .pos = 5};    /** @brief RXNE interrupt enable. */
  static const field32_t USARTx_CRx_IDLEIE      = {.msk = 0x00000010U, .pos = 4};    /** @brief IDLE interrupt enable. */
  static const field32_t USARTx_CRx_TE          = {.msk = 0x00000008U, .pos = 3};    /** @brief Transmitter enable. */
  static const field32_t USARTx_CRx_RE          = {.msk = 0x00000004U, .pos = 2};    /** @brief Receiver enable. */
  static const field32_t USARTx_CRx_UESM        = {.msk = 0x00000002U, .pos = 1};    /** @brief USART enable in stop mode. */
  static const field32_t USARTx_CRx_UE          = {.msk = 0x00000001U, .pos = 0};    /** @brief USART enable. */
  static const field32_t USARTx_BRR_BRR_4_15    = {.msk = 0x0000FFF0U, .pos = 4};    /** @brief DIV_Mantissa. */
  static const field32_t USARTx_BRR_BRR_0_3     = {.msk = 0x0000000FU, .pos = 0};    /** @brief DIV_Fraction. */
  static const field32_t USARTx_GTPR_GT         = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Guard time value. */
  static const field32_t USARTx_GTPR_PSC        = {.msk = 0x000000FFU, .pos = 0};    /** @brief Prescaler value. */
  static const field32_t USARTx_RTOR_BLEN       = {.msk = 0xFF000000U, .pos = 24};   /** @brief Block length. */
  static const field32_t USARTx_RTOR_RTO        = {.msk = 0x00FFFFFFU, .pos = 0};    /** @brief Receiver timeout value. */
  static const field32_t USARTx_RQR_TXFRQ       = {.msk = 0x00000010U, .pos = 4};    /** @brief Transmit data flush request. */
  static const field32_t USARTx_RQR_RXFRQ       = {.msk = 0x00000008U, .pos = 3};    /** @brief Receive data flush request. */
  static const field32_t USARTx_RQR_MMRQ        = {.msk = 0x00000004U, .pos = 2};    /** @brief Mute mode request. */
  static const field32_t USARTx_RQR_SBKRQ       = {.msk = 0x00000002U, .pos = 1};    /** @brief Send break request. */
  static const field32_t USARTx_RQR_ABRRQ       = {.msk = 0x00000001U, .pos = 0};    /** @brief Auto baud rate request. */
  static const field32_t USARTx_ISR_TXFT        = {.msk = 0x08000000U, .pos = 27};   /** @brief TXFIFO threshold flag. */
  static const field32_t USARTx_ISR_RXFT        = {.msk = 0x04000000U, .pos = 26};   /** @brief RXFIFO threshold flag. */
  static const field32_t USARTx_ISR_TCBGT       = {.msk = 0x02000000U, .pos = 25};   /** @brief Transmission complete before guard time flag. */
  static const field32_t USARTx_ISR_RXFF        = {.msk = 0x01000000U, .pos = 24};   /** @brief RXFIFO full. */
  static const field32_t USARTx_ISR_TXFE        = {.msk = 0x00800000U, .pos = 23};   /** @brief TXFIFO empty. */
  static const field32_t USARTx_ISR_REACK       = {.msk = 0x00400000U, .pos = 22};   /** @brief REACK. */
  static const field32_t USARTx_ISR_TEACK       = {.msk = 0x00200000U, .pos = 21};   /** @brief TEACK. */
  static const field32_t USARTx_ISR_WUF         = {.msk = 0x00100000U, .pos = 20};   /** @brief WUF. */
  static const field32_t USARTx_ISR_RWU         = {.msk = 0x00080000U, .pos = 19};   /** @brief RWU. */
  static const field32_t USARTx_ISR_SBKF        = {.msk = 0x00040000U, .pos = 18};   /** @brief SBKF. */
  static const field32_t USARTx_ISR_CMF         = {.msk = 0x00020000U, .pos = 17};   /** @brief CMF. */
  static const field32_t USARTx_ISR_BUSY        = {.msk = 0x00010000U, .pos = 16};   /** @brief BUSY. */
  static const field32_t USARTx_ISR_ABRF        = {.msk = 0x00008000U, .pos = 15};   /** @brief ABRF. */
  static const field32_t USARTx_ISR_ABRE        = {.msk = 0x00004000U, .pos = 14};   /** @brief ABRE. */
  static const field32_t USARTx_ISR_UDR         = {.msk = 0x00002000U, .pos = 13};   /** @brief SPI slave underrun error flag. */
  static const field32_t USARTx_ISR_EOBF        = {.msk = 0x00001000U, .pos = 12};   /** @brief EOBF. */
  static const field32_t USARTx_ISR_RTOF        = {.msk = 0x00000800U, .pos = 11};   /** @brief RTOF. */
  static const field32_t USARTx_ISR_CTS         = {.msk = 0x00000400U, .pos = 10};   /** @brief CTS. */
  static const field32_t USARTx_ISR_CTSIF       = {.msk = 0x00000200U, .pos = 9};    /** @brief CTSIF. */
  static const field32_t USARTx_ISR_LBDF        = {.msk = 0x00000100U, .pos = 8};    /** @brief LBDF. */
  static const field32_t USARTx_ISR_TXE         = {.msk = 0x00000080U, .pos = 7};    /** @brief TXE. */
  static const field32_t USARTx_ISR_TC          = {.msk = 0x00000040U, .pos = 6};    /** @brief TC. */
  static const field32_t USARTx_ISR_RXNE        = {.msk = 0x00000020U, .pos = 5};    /** @brief RXNE. */
  static const field32_t USARTx_ISR_IDLE        = {.msk = 0x00000010U, .pos = 4};    /** @brief IDLE. */
  static const field32_t USARTx_ISR_ORE         = {.msk = 0x00000008U, .pos = 3};    /** @brief ORE. */
  static const field32_t USARTx_ISR_NF          = {.msk = 0x00000004U, .pos = 2};    /** @brief NF. */
  static const field32_t USARTx_ISR_FE          = {.msk = 0x00000002U, .pos = 1};    /** @brief FE. */
  static const field32_t USARTx_ISR_PE          = {.msk = 0x00000001U, .pos = 0};    /** @brief PE. */
  static const field32_t USARTx_ICR_WUCF        = {.msk = 0x00100000U, .pos = 20};   /** @brief Wakeup from stop mode clear flag. */
  static const field32_t USARTx_ICR_CMCF        = {.msk = 0x00020000U, .pos = 17};   /** @brief Character match clear flag. */
  static const field32_t USARTx_ICR_UDRCF       = {.msk = 0x00002000U, .pos = 13};   /** @brief SPI slave underrun clear flag. */
  static const field32_t USARTx_ICR_EOBCF       = {.msk = 0x00001000U, .pos = 12};   /** @brief End of block clear flag. */
  static const field32_t USARTx_ICR_RTOCF       = {.msk = 0x00000800U, .pos = 11};   /** @brief Receiver timeout clear flag. */
  static const field32_t USARTx_ICR_CTSCF       = {.msk = 0x00000200U, .pos = 9};    /** @brief CTS clear flag. */
  static const field32_t USARTx_ICR_LBDCF       = {.msk = 0x00000100U, .pos = 8};    /** @brief LIN break detection clear flag. */
  static const field32_t USARTx_ICR_TCBGTC      = {.msk = 0x00000080U, .pos = 7};    /** @brief Transmission complete before guard time clear flag. */
  static const field32_t USARTx_ICR_TCCF        = {.msk = 0x00000040U, .pos = 6};    /** @brief Transmission complete clear flag. */
  static const field32_t USARTx_ICR_TXFECF      = {.msk = 0x00000020U, .pos = 5};    /** @brief TXFIFO empty clear flag. */
  static const field32_t USARTx_ICR_IDLECF      = {.msk = 0x00000010U, .pos = 4};    /** @brief Idle line detected clear flag. */
  static const field32_t USARTx_ICR_ORECF       = {.msk = 0x00000008U, .pos = 3};    /** @brief Overrun error clear flag. */
  static const field32_t USARTx_ICR_NCF         = {.msk = 0x00000004U, .pos = 2};    /** @brief Noise detected clear flag. */
  static const field32_t USARTx_ICR_FECF        = {.msk = 0x00000002U, .pos = 1};    /** @brief Framing error clear flag. */
  static const field32_t USARTx_ICR_PECF        = {.msk = 0x00000001U, .pos = 0};    /** @brief Parity error clear flag. */
  static const field32_t USARTx_RDR_RDR         = {.msk = 0x000001FFU, .pos = 0};    /** @brief Receive data value. */
  static const field32_t USARTx_TDR_TDR         = {.msk = 0x000001FFU, .pos = 0};    /** @brief Transmit data value. */
  static const field32_t USARTx_PRESC_PRESCALER = {.msk = 0x0000000FU, .pos = 0};    /** @brief Clock prescaler. */

  /**** Enumerated USARTx Register Field Definitions ****/

  static field32_t const USARTx_CRx_Mx[2] = {
    [0] = {.msk = 0x00001000U, .pos = 12},   /** @brief Word length. */
    [1] = {.msk = 0x10000000U, .pos = 28},   /** @brief Word length. */
  };

  static field32_t const USARTx_CRx_DEATx[5] = {
    [0] = {.msk = 0x00200000U, .pos = 21},   /** @brief DEAT0. */
    [1] = {.msk = 0x00400000U, .pos = 22},   /** @brief DEAT1. */
    [2] = {.msk = 0x00800000U, .pos = 23},   /** @brief DEAT2. */
    [3] = {.msk = 0x01000000U, .pos = 24},   /** @brief DEAT3. */
    [4] = {.msk = 0x02000000U, .pos = 25},   /** @brief Driver enable assertion time. */
  };

  static field32_t const USARTx_CRx_DEDTx[5] = {
    [0] = {.msk = 0x00010000U, .pos = 16},   /** @brief DEDT0. */
    [1] = {.msk = 0x00020000U, .pos = 17},   /** @brief DEDT1. */
    [2] = {.msk = 0x00040000U, .pos = 18},   /** @brief DEDT2. */
    [3] = {.msk = 0x00080000U, .pos = 19},   /** @brief DEDT3. */
    [4] = {.msk = 0x00100000U, .pos = 20},   /** @brief Driver enable de-assertion time. */
  };

  /************************************************************************************************
   * UARTx Definitions
   ************************************************************************************************/

  /**** Enumerated UARTx Register Definitions ****/

  static const rw_reg32_t UARTx_CRx[9][4] = {
    [4] = {
      [1] = (rw_reg32_t)0x40004C00U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40004C04U,   /** @brief Control register 2. */
      [3] = (rw_reg32_t)0x40004C08U,   /** @brief Control register 3. */
    },
    [5] = {
      [1] = (rw_reg32_t)0x40005000U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40005004U,   /** @brief Control register 2. */
      [3] = (rw_reg32_t)0x40005008U,   /** @brief Control register 3. */
    },
    [7] = {
      [1] = (rw_reg32_t)0x40007800U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40007804U,   /** @brief Control register 2. */
      [3] = (rw_reg32_t)0x40007808U,   /** @brief Control register 3. */
    },
    [8] = {
      [1] = (rw_reg32_t)0x40007C00U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40007C04U,   /** @brief Control register 2. */
      [3] = (rw_reg32_t)0x40007C08U,   /** @brief Control register 3. */
    },
  };

  static const rw_reg32_t UARTx_BRR[9] = {
    [4] = (rw_reg32_t)0x40004C0CU,   /** @brief Baud rate register. */
    [5] = (rw_reg32_t)0x4000500CU,   /** @brief Baud rate register. */
    [7] = (rw_reg32_t)0x4000780CU,   /** @brief Baud rate register. */
    [8] = (rw_reg32_t)0x40007C0CU,   /** @brief Baud rate register. */
  };

  static const rw_reg32_t UARTx_GTPR[9] = {
    [4] = (rw_reg32_t)0x40004C10U,   /** @brief Guard time and prescaler register. */
    [5] = (rw_reg32_t)0x40005010U,   /** @brief Guard time and prescaler register. */
    [7] = (rw_reg32_t)0x40007810U,   /** @brief Guard time and prescaler register. */
    [8] = (rw_reg32_t)0x40007C10U,   /** @brief Guard time and prescaler register. */
  };

  static const rw_reg32_t UARTx_RTOR[9] = {
    [4] = (rw_reg32_t)0x40004C14U,   /** @brief Receiver timeout register. */
    [5] = (rw_reg32_t)0x40005014U,   /** @brief Receiver timeout register. */
    [7] = (rw_reg32_t)0x40007814U,   /** @brief Receiver timeout register. */
    [8] = (rw_reg32_t)0x40007C14U,   /** @brief Receiver timeout register. */
  };

  static const rw_reg32_t UARTx_RQR[9] = {
    [4] = (rw_reg32_t)0x40004C18U,   /** @brief Request register. */
    [5] = (rw_reg32_t)0x40005018U,   /** @brief Request register. */
    [7] = (rw_reg32_t)0x40007818U,   /** @brief Request register. */
    [8] = (rw_reg32_t)0x40007C18U,   /** @brief Request register. */
  };

  static const ro_reg32_t UARTx_ISR[9] = {
    [4] = (ro_reg32_t)0x40004C1CU,   /** @brief Interrupt & status register. */
    [5] = (ro_reg32_t)0x4000501CU,   /** @brief Interrupt & status register. */
    [7] = (ro_reg32_t)0x4000781CU,   /** @brief Interrupt & status register. */
    [8] = (ro_reg32_t)0x40007C1CU,   /** @brief Interrupt & status register. */
  };

  static const rw_reg32_t UARTx_ICR[9] = {
    [4] = (rw_reg32_t)0x40004C20U,   /** @brief Interrupt flag clear register. */
    [5] = (rw_reg32_t)0x40005020U,   /** @brief Interrupt flag clear register. */
    [7] = (rw_reg32_t)0x40007820U,   /** @brief Interrupt flag clear register. */
    [8] = (rw_reg32_t)0x40007C20U,   /** @brief Interrupt flag clear register. */
  };

  static const ro_reg32_t UARTx_RDR[9] = {
    [4] = (ro_reg32_t)0x40004C24U,   /** @brief Receive data register. */
    [5] = (ro_reg32_t)0x40005024U,   /** @brief Receive data register. */
    [7] = (ro_reg32_t)0x40007824U,   /** @brief Receive data register. */
    [8] = (ro_reg32_t)0x40007C24U,   /** @brief Receive data register. */
  };

  static const rw_reg32_t UARTx_TDR[9] = {
    [4] = (rw_reg32_t)0x40004C28U,   /** @brief Transmit data register. */
    [5] = (rw_reg32_t)0x40005028U,   /** @brief Transmit data register. */
    [7] = (rw_reg32_t)0x40007828U,   /** @brief Transmit data register. */
    [8] = (rw_reg32_t)0x40007C28U,   /** @brief Transmit data register. */
  };

  static const rw_reg32_t UARTx_PRESC[9] = {
    [4] = (rw_reg32_t)0x40004C2CU,   /** @brief USART prescaler register. */
    [5] = (rw_reg32_t)0x4000502CU,   /** @brief USART prescaler register. */
    [7] = (rw_reg32_t)0x4000782CU,   /** @brief USART prescaler register. */
    [8] = (rw_reg32_t)0x40007C2CU,   /** @brief USART prescaler register. */
  };

  /**** UARTx Register Field Definitions ****/

  static const field32_t UARTx_CRx_RXFFIE      = {.msk = 0x80000000U, .pos = 31};   /** @brief RXFIFO full interrupt enable. */
  static const field32_t UARTx_CRx_TXFEIE      = {.msk = 0x40000000U, .pos = 30};   /** @brief TXFIFO empty interrupt enable. */
  static const field32_t UARTx_CRx_FIFOEN      = {.msk = 0x20000000U, .pos = 29};   /** @brief FIFO mode enable. */
  static const field32_t UARTx_CRx_EOBIE       = {.msk = 0x08000000U, .pos = 27};   /** @brief End of block interrupt enable. */
  static const field32_t UARTx_CRx_RTOIE       = {.msk = 0x04000000U, .pos = 26};   /** @brief Receiver timeout interrupt enable. */
  static const field32_t UARTx_CRx_OVER8       = {.msk = 0x00008000U, .pos = 15};   /** @brief Oversampling mode. */
  static const field32_t UARTx_CRx_CMIE        = {.msk = 0x00004000U, .pos = 14};   /** @brief Character match interrupt enable. */
  static const field32_t UARTx_CRx_MME         = {.msk = 0x00002000U, .pos = 13};   /** @brief Mute mode enable. */
  static const field32_t UARTx_CRx_WAKE        = {.msk = 0x00000800U, .pos = 11};   /** @brief Receiver wakeup method. */
  static const field32_t UARTx_CRx_PCE         = {.msk = 0x00000400U, .pos = 10};   /** @brief Parity control enable. */
  static const field32_t UARTx_CRx_PS          = {.msk = 0x00000200U, .pos = 9};    /** @brief Parity selection. */
  static const field32_t UARTx_CRx_PEIE        = {.msk = 0x00000100U, .pos = 8};    /** @brief PE interrupt enable. */
  static const field32_t UARTx_CRx_TXEIE       = {.msk = 0x00000080U, .pos = 7};    /** @brief Interrupt enable. */
  static const field32_t UARTx_CRx_TCIE        = {.msk = 0x00000040U, .pos = 6};    /** @brief Transmission complete interrupt enable. */
  static const field32_t UARTx_CRx_RXNEIE      = {.msk = 0x00000020U, .pos = 5};    /** @brief RXNE interrupt enable. */
  static const field32_t UARTx_CRx_IDLEIE      = {.msk = 0x00000010U, .pos = 4};    /** @brief IDLE interrupt enable. */
  static const field32_t UARTx_CRx_TE          = {.msk = 0x00000008U, .pos = 3};    /** @brief Transmitter enable. */
  static const field32_t UARTx_CRx_RE          = {.msk = 0x00000004U, .pos = 2};    /** @brief Receiver enable. */
  static const field32_t UARTx_CRx_UESM        = {.msk = 0x00000002U, .pos = 1};    /** @brief USART enable in stop mode. */
  static const field32_t UARTx_CRx_UE          = {.msk = 0x00000001U, .pos = 0};    /** @brief USART enable. */
  static const field32_t UARTx_BRR_BRR_4_15    = {.msk = 0x0000FFF0U, .pos = 4};    /** @brief DIV_Mantissa. */
  static const field32_t UARTx_BRR_BRR_0_3     = {.msk = 0x0000000FU, .pos = 0};    /** @brief DIV_Fraction. */
  static const field32_t UARTx_GTPR_GT         = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Guard time value. */
  static const field32_t UARTx_GTPR_PSC        = {.msk = 0x000000FFU, .pos = 0};    /** @brief Prescaler value. */
  static const field32_t UARTx_RTOR_BLEN       = {.msk = 0xFF000000U, .pos = 24};   /** @brief Block length. */
  static const field32_t UARTx_RTOR_RTO        = {.msk = 0x00FFFFFFU, .pos = 0};    /** @brief Receiver timeout value. */
  static const field32_t UARTx_RQR_TXFRQ       = {.msk = 0x00000010U, .pos = 4};    /** @brief Transmit data flush request. */
  static const field32_t UARTx_RQR_RXFRQ       = {.msk = 0x00000008U, .pos = 3};    /** @brief Receive data flush request. */
  static const field32_t UARTx_RQR_MMRQ        = {.msk = 0x00000004U, .pos = 2};    /** @brief Mute mode request. */
  static const field32_t UARTx_RQR_SBKRQ       = {.msk = 0x00000002U, .pos = 1};    /** @brief Send break request. */
  static const field32_t UARTx_RQR_ABRRQ       = {.msk = 0x00000001U, .pos = 0};    /** @brief Auto baud rate request. */
  static const field32_t UARTx_ISR_TXFT        = {.msk = 0x08000000U, .pos = 27};   /** @brief TXFIFO threshold flag. */
  static const field32_t UARTx_ISR_RXFT        = {.msk = 0x04000000U, .pos = 26};   /** @brief RXFIFO threshold flag. */
  static const field32_t UARTx_ISR_TCBGT       = {.msk = 0x02000000U, .pos = 25};   /** @brief Transmission complete before guard time flag. */
  static const field32_t UARTx_ISR_RXFF        = {.msk = 0x01000000U, .pos = 24};   /** @brief RXFIFO full. */
  static const field32_t UARTx_ISR_TXFE        = {.msk = 0x00800000U, .pos = 23};   /** @brief TXFIFO empty. */
  static const field32_t UARTx_ISR_REACK       = {.msk = 0x00400000U, .pos = 22};   /** @brief REACK. */
  static const field32_t UARTx_ISR_TEACK       = {.msk = 0x00200000U, .pos = 21};   /** @brief TEACK. */
  static const field32_t UARTx_ISR_WUF         = {.msk = 0x00100000U, .pos = 20};   /** @brief WUF. */
  static const field32_t UARTx_ISR_RWU         = {.msk = 0x00080000U, .pos = 19};   /** @brief RWU. */
  static const field32_t UARTx_ISR_SBKF        = {.msk = 0x00040000U, .pos = 18};   /** @brief SBKF. */
  static const field32_t UARTx_ISR_CMF         = {.msk = 0x00020000U, .pos = 17};   /** @brief CMF. */
  static const field32_t UARTx_ISR_BUSY        = {.msk = 0x00010000U, .pos = 16};   /** @brief BUSY. */
  static const field32_t UARTx_ISR_ABRF        = {.msk = 0x00008000U, .pos = 15};   /** @brief ABRF. */
  static const field32_t UARTx_ISR_ABRE        = {.msk = 0x00004000U, .pos = 14};   /** @brief ABRE. */
  static const field32_t UARTx_ISR_UDR         = {.msk = 0x00002000U, .pos = 13};   /** @brief SPI slave underrun error flag. */
  static const field32_t UARTx_ISR_EOBF        = {.msk = 0x00001000U, .pos = 12};   /** @brief EOBF. */
  static const field32_t UARTx_ISR_RTOF        = {.msk = 0x00000800U, .pos = 11};   /** @brief RTOF. */
  static const field32_t UARTx_ISR_CTS         = {.msk = 0x00000400U, .pos = 10};   /** @brief CTS. */
  static const field32_t UARTx_ISR_CTSIF       = {.msk = 0x00000200U, .pos = 9};    /** @brief CTSIF. */
  static const field32_t UARTx_ISR_LBDF        = {.msk = 0x00000100U, .pos = 8};    /** @brief LBDF. */
  static const field32_t UARTx_ISR_TXE         = {.msk = 0x00000080U, .pos = 7};    /** @brief TXE. */
  static const field32_t UARTx_ISR_TC          = {.msk = 0x00000040U, .pos = 6};    /** @brief TC. */
  static const field32_t UARTx_ISR_RXNE        = {.msk = 0x00000020U, .pos = 5};    /** @brief RXNE. */
  static const field32_t UARTx_ISR_IDLE        = {.msk = 0x00000010U, .pos = 4};    /** @brief IDLE. */
  static const field32_t UARTx_ISR_ORE         = {.msk = 0x00000008U, .pos = 3};    /** @brief ORE. */
  static const field32_t UARTx_ISR_NF          = {.msk = 0x00000004U, .pos = 2};    /** @brief NF. */
  static const field32_t UARTx_ISR_FE          = {.msk = 0x00000002U, .pos = 1};    /** @brief FE. */
  static const field32_t UARTx_ISR_PE          = {.msk = 0x00000001U, .pos = 0};    /** @brief PE. */
  static const field32_t UARTx_ICR_WUCF        = {.msk = 0x00100000U, .pos = 20};   /** @brief Wakeup from stop mode clear flag. */
  static const field32_t UARTx_ICR_CMCF        = {.msk = 0x00020000U, .pos = 17};   /** @brief Character match clear flag. */
  static const field32_t UARTx_ICR_UDRCF       = {.msk = 0x00002000U, .pos = 13};   /** @brief SPI slave underrun clear flag. */
  static const field32_t UARTx_ICR_EOBCF       = {.msk = 0x00001000U, .pos = 12};   /** @brief End of block clear flag. */
  static const field32_t UARTx_ICR_RTOCF       = {.msk = 0x00000800U, .pos = 11};   /** @brief Receiver timeout clear flag. */
  static const field32_t UARTx_ICR_CTSCF       = {.msk = 0x00000200U, .pos = 9};    /** @brief CTS clear flag. */
  static const field32_t UARTx_ICR_LBDCF       = {.msk = 0x00000100U, .pos = 8};    /** @brief LIN break detection clear flag. */
  static const field32_t UARTx_ICR_TCBGTC      = {.msk = 0x00000080U, .pos = 7};    /** @brief Transmission complete before guard time clear flag. */
  static const field32_t UARTx_ICR_TCCF        = {.msk = 0x00000040U, .pos = 6};    /** @brief Transmission complete clear flag. */
  static const field32_t UARTx_ICR_TXFECF      = {.msk = 0x00000020U, .pos = 5};    /** @brief TXFIFO empty clear flag. */
  static const field32_t UARTx_ICR_IDLECF      = {.msk = 0x00000010U, .pos = 4};    /** @brief Idle line detected clear flag. */
  static const field32_t UARTx_ICR_ORECF       = {.msk = 0x00000008U, .pos = 3};    /** @brief Overrun error clear flag. */
  static const field32_t UARTx_ICR_NCF         = {.msk = 0x00000004U, .pos = 2};    /** @brief Noise detected clear flag. */
  static const field32_t UARTx_ICR_FECF        = {.msk = 0x00000002U, .pos = 1};    /** @brief Framing error clear flag. */
  static const field32_t UARTx_ICR_PECF        = {.msk = 0x00000001U, .pos = 0};    /** @brief Parity error clear flag. */
  static const field32_t UARTx_RDR_RDR         = {.msk = 0x000001FFU, .pos = 0};    /** @brief Receive data value. */
  static const field32_t UARTx_TDR_TDR         = {.msk = 0x000001FFU, .pos = 0};    /** @brief Transmit data value. */
  static const field32_t UARTx_PRESC_PRESCALER = {.msk = 0x0000000FU, .pos = 0};    /** @brief Clock prescaler. */

  /**** Enumerated UARTx Register Field Definitions ****/

  static field32_t const UARTx_CRx_Mx[2] = {
    [0] = {.msk = 0x00001000U, .pos = 12},   /** @brief Word length. */
    [1] = {.msk = 0x10000000U, .pos = 28},   /** @brief Word length. */
  };

  static field32_t const UARTx_CRx_DEATx[5] = {
    [0] = {.msk = 0x00200000U, .pos = 21},   /** @brief DEAT0. */
    [1] = {.msk = 0x00400000U, .pos = 22},   /** @brief DEAT1. */
    [2] = {.msk = 0x00800000U, .pos = 23},   /** @brief DEAT2. */
    [3] = {.msk = 0x01000000U, .pos = 24},   /** @brief DEAT3. */
    [4] = {.msk = 0x02000000U, .pos = 25},   /** @brief Driver enable assertion time. */
  };

  static field32_t const UARTx_CRx_DEDTx[5] = {
    [0] = {.msk = 0x00010000U, .pos = 16},   /** @brief DEDT0. */
    [1] = {.msk = 0x00020000U, .pos = 17},   /** @brief DEDT1. */
    [2] = {.msk = 0x00040000U, .pos = 18},   /** @brief DEDT2. */
    [3] = {.msk = 0x00080000U, .pos = 19},   /** @brief DEDT3. */
    [4] = {.msk = 0x00100000U, .pos = 20},   /** @brief Driver enable de-assertion time. */
  };

  /************************************************************************************************
   * A_TIMx Definitions
   ************************************************************************************************/

  /**** Enumerated A_TIMx Register Definitions ****/

  static const rw_reg32_t A_TIMx_CRx[9][3] = {
    [1] = {
      [1] = (rw_reg32_t)0x40010000U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40010004U,   /** @brief Control register 2. */
    },
    [8] = {
      [1] = (rw_reg32_t)0x40010400U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40010404U,   /** @brief Control register 2. */
    },
  };

  static const rw_reg32_t A_TIMx_SMCR[9] = {
    [1] = (rw_reg32_t)0x40010008U,   /** @brief Slave mode control register. */
    [8] = (rw_reg32_t)0x40010408U,   /** @brief Slave mode control register. */
  };

  static const rw_reg32_t A_TIMx_DIER[9] = {
    [1] = (rw_reg32_t)0x4001000CU,   /** @brief DMA/Interrupt enable register. */
    [8] = (rw_reg32_t)0x4001040CU,   /** @brief DMA/Interrupt enable register. */
  };

  static const rw_reg32_t A_TIMx_SR[9] = {
    [1] = (rw_reg32_t)0x40010010U,   /** @brief Status register. */
    [8] = (rw_reg32_t)0x40010410U,   /** @brief Status register. */
  };

  static const rw_reg32_t A_TIMx_EGR[9] = {
    [1] = (rw_reg32_t)0x40010014U,   /** @brief Event generation register. */
    [8] = (rw_reg32_t)0x40010414U,   /** @brief Event generation register. */
  };

  static const rw_reg32_t A_TIMx_CCMRx_OUTPUT[9][4] = {
    [1] = {
      [1] = (rw_reg32_t)0x40010018U,   /** @brief Capture/compare mode register 1 (output mode). */
      [2] = (rw_reg32_t)0x4001001CU,   /** @brief Capture/compare mode register 2 (output mode). */
      [3] = (rw_reg32_t)0x40010054U,   /** @brief Capture/compare mode register 3 (output mode). */
    },
    [8] = {
      [1] = (rw_reg32_t)0x40010418U,   /** @brief Capture/compare mode register 1 (output mode). */
      [2] = (rw_reg32_t)0x4001041CU,   /** @brief Capture/compare mode register 2 (output mode). */
      [3] = (rw_reg32_t)0x40010454U,   /** @brief Capture/compare mode register 3 (output mode). */
    },
  };

  static const rw_reg32_t A_TIMx_CCMRx_INPUT[9][3] = {
    [1] = {
      [1] = (rw_reg32_t)0x40010018U,   /** @brief Capture/compare mode register 1 (input mode). */
      [2] = (rw_reg32_t)0x4001001CU,   /** @brief Capture/compare mode register 2 (input mode). */
    },
    [8] = {
      [1] = (rw_reg32_t)0x40010418U,   /** @brief Capture/compare mode register 1 (input mode). */
      [2] = (rw_reg32_t)0x4001041CU,   /** @brief Capture/compare mode register 2 (input mode). */
    },
  };

  static const rw_reg32_t A_TIMx_CCER[9] = {
    [1] = (rw_reg32_t)0x40010020U,   /** @brief Capture/compare enable register. */
    [8] = (rw_reg32_t)0x40010420U,   /** @brief Capture/compare enable register. */
  };

  static const rw_reg32_t A_TIMx_CNT[9] = {
    [1] = (rw_reg32_t)0x40010024U,   /** @brief Counter. */
    [8] = (rw_reg32_t)0x40010424U,   /** @brief Counter. */
  };

  static const rw_reg32_t A_TIMx_PSC[9] = {
    [1] = (rw_reg32_t)0x40010028U,   /** @brief Prescaler. */
    [8] = (rw_reg32_t)0x40010428U,   /** @brief Prescaler. */
  };

  static const rw_reg32_t A_TIMx_ARR[9] = {
    [1] = (rw_reg32_t)0x4001002CU,   /** @brief Auto-reload register. */
    [8] = (rw_reg32_t)0x4001042CU,   /** @brief Auto-reload register. */
  };

  static const rw_reg32_t A_TIMx_CCRx[9][6] = {
    [1] = {
      [1] = (rw_reg32_t)0x40010034U,   /** @brief Capture/compare register 1. */
      [2] = (rw_reg32_t)0x40010038U,   /** @brief Capture/compare register 2. */
      [3] = (rw_reg32_t)0x4001003CU,   /** @brief Capture/compare register 3. */
      [4] = (rw_reg32_t)0x40010040U,   /** @brief Capture/compare register 4. */
      [5] = (rw_reg32_t)0x40010058U,   /** @brief Capture/compare register 5. */
    },
    [8] = {
      [1] = (rw_reg32_t)0x40010434U,   /** @brief Capture/compare register 1. */
      [2] = (rw_reg32_t)0x40010438U,   /** @brief Capture/compare register 2. */
      [3] = (rw_reg32_t)0x4001043CU,   /** @brief Capture/compare register 3. */
      [4] = (rw_reg32_t)0x40010440U,   /** @brief Capture/compare register 4. */
      [5] = (rw_reg32_t)0x40010458U,   /** @brief Capture/compare register 5. */
    },
  };

  static const rw_reg32_t A_TIMx_DCR[9] = {
    [1] = (rw_reg32_t)0x40010048U,   /** @brief DMA control register. */
    [8] = (rw_reg32_t)0x40010448U,   /** @brief DMA control register. */
  };

  static const rw_reg32_t A_TIMx_DMAR[9] = {
    [1] = (rw_reg32_t)0x4001004CU,   /** @brief DMA address for full transfer. */
    [8] = (rw_reg32_t)0x4001044CU,   /** @brief DMA address for full transfer. */
  };

  static const rw_reg32_t A_TIMx_RCR[9] = {
    [1] = (rw_reg32_t)0x40010030U,   /** @brief Repetition counter register. */
    [8] = (rw_reg32_t)0x40010430U,   /** @brief Repetition counter register. */
  };

  static const rw_reg32_t A_TIMx_BDTR[9] = {
    [1] = (rw_reg32_t)0x40010044U,   /** @brief Break and dead-time register. */
    [8] = (rw_reg32_t)0x40010444U,   /** @brief Break and dead-time register. */
  };

  static const rw_reg32_t A_TIMx_CRR6[9] = {
    [1] = (rw_reg32_t)0x4001005CU,   /** @brief Capture/compare register 6. */
    [8] = (rw_reg32_t)0x4001045CU,   /** @brief Capture/compare register 6. */
  };

  static const rw_reg32_t A_TIMx_AFx[9][3] = {
    [1] = {
      [1] = (rw_reg32_t)0x40010060U,   /** @brief TIM1 alternate function option register 1. */
      [2] = (rw_reg32_t)0x40010064U,   /** @brief TIM1 alternate function odfsdm1_breakster 2. */
    },
    [8] = {
      [1] = (rw_reg32_t)0x40010460U,   /** @brief TIM1 alternate function option register 1. */
      [2] = (rw_reg32_t)0x40010464U,   /** @brief TIM1 alternate function odfsdm1_breakster 2. */
    },
  };

  static const rw_reg32_t A_TIMx_TISEL[9] = {
    [1] = (rw_reg32_t)0x40010068U,   /** @brief TIM1 timer input selection register. */
    [8] = (rw_reg32_t)0x40010468U,   /** @brief TIM1 timer input selection register. */
  };

  /**** A_TIMx Register Field Definitions ****/

  static const field32_t A_TIMx_CRx_CEN            = {.msk = 0x00000001U, .pos = 0};    /** @brief Counter enable. */
  static const field32_t A_TIMx_CRx_UDIS           = {.msk = 0x00000002U, .pos = 1};    /** @brief Update disable. */
  static const field32_t A_TIMx_CRx_URS            = {.msk = 0x00000004U, .pos = 2};    /** @brief Update request source. */
  static const field32_t A_TIMx_CRx_OPM            = {.msk = 0x00000008U, .pos = 3};    /** @brief One-pulse mode. */
  static const field32_t A_TIMx_CRx_DIR            = {.msk = 0x00000010U, .pos = 4};    /** @brief Direction. */
  static const field32_t A_TIMx_CRx_CMS            = {.msk = 0x00000060U, .pos = 5};    /** @brief Center-aligned mode selection. */
  static const field32_t A_TIMx_CRx_ARPE           = {.msk = 0x00000080U, .pos = 7};    /** @brief Auto-reload preload enable. */
  static const field32_t A_TIMx_CRx_CKD            = {.msk = 0x00000300U, .pos = 8};    /** @brief Clock division. */
  static const field32_t A_TIMx_CRx_UIFREMAP       = {.msk = 0x00000800U, .pos = 11};   /** @brief UIF status bit remapping. */
  static const field32_t A_TIMx_SMCR_SMS           = {.msk = 0x00000007U, .pos = 0};    /** @brief Slave mode selection. */
  static const field32_t A_TIMx_SMCR_TS            = {.msk = 0x00000070U, .pos = 4};    /** @brief Trigger selection. */
  static const field32_t A_TIMx_SMCR_MSM           = {.msk = 0x00000080U, .pos = 7};    /** @brief Master/Slave mode. */
  static const field32_t A_TIMx_SMCR_ETF           = {.msk = 0x00000F00U, .pos = 8};    /** @brief External trigger filter. */
  static const field32_t A_TIMx_SMCR_ETPS          = {.msk = 0x00003000U, .pos = 12};   /** @brief External trigger prescaler. */
  static const field32_t A_TIMx_SMCR_ECE           = {.msk = 0x00004000U, .pos = 14};   /** @brief External clock enable. */
  static const field32_t A_TIMx_SMCR_ETP           = {.msk = 0x00008000U, .pos = 15};   /** @brief External trigger polarity. */
  static const field32_t A_TIMx_SMCR_SMS_3         = {.msk = 0x00010000U, .pos = 16};   /** @brief Slave mode selection - bit 3. */
  static const field32_t A_TIMx_SMCR_TS_4_3        = {.msk = 0x00300000U, .pos = 20};   /** @brief Trigger selection - bit 4:3. */
  static const field32_t A_TIMx_DIER_TDE           = {.msk = 0x00004000U, .pos = 14};   /** @brief Trigger DMA request enable. */
  static const field32_t A_TIMx_DIER_COMDE         = {.msk = 0x00002000U, .pos = 13};   /** @brief COM DMA request enable. */
  static const field32_t A_TIMx_DIER_UDE           = {.msk = 0x00000100U, .pos = 8};    /** @brief Update DMA request enable. */
  static const field32_t A_TIMx_DIER_TIE           = {.msk = 0x00000040U, .pos = 6};    /** @brief Trigger interrupt enable. */
  static const field32_t A_TIMx_DIER_UIE           = {.msk = 0x00000001U, .pos = 0};    /** @brief Update interrupt enable. */
  static const field32_t A_TIMx_DIER_BIE           = {.msk = 0x00000080U, .pos = 7};    /** @brief Break interrupt enable. */
  static const field32_t A_TIMx_DIER_COMIE         = {.msk = 0x00000020U, .pos = 5};    /** @brief COM interrupt enable. */
  static const field32_t A_TIMx_SR_SBIF            = {.msk = 0x00002000U, .pos = 13};   /** @brief System break interrupt flag. */
  static const field32_t A_TIMx_SR_B2IF            = {.msk = 0x00000100U, .pos = 8};    /** @brief Break 2 interrupt flag. */
  static const field32_t A_TIMx_SR_BIF             = {.msk = 0x00000080U, .pos = 7};    /** @brief Break interrupt flag. */
  static const field32_t A_TIMx_SR_TIF             = {.msk = 0x00000040U, .pos = 6};    /** @brief Trigger interrupt flag. */
  static const field32_t A_TIMx_SR_COMIF           = {.msk = 0x00000020U, .pos = 5};    /** @brief COM interrupt flag. */
  static const field32_t A_TIMx_SR_UIF             = {.msk = 0x00000001U, .pos = 0};    /** @brief Update interrupt flag. */
  static const field32_t A_TIMx_EGR_UG             = {.msk = 0x00000001U, .pos = 0};    /** @brief Update generation. */
  static const field32_t A_TIMx_EGR_COMG           = {.msk = 0x00000020U, .pos = 5};    /** @brief Capture/Compare control update generation. */
  static const field32_t A_TIMx_EGR_TG             = {.msk = 0x00000040U, .pos = 6};    /** @brief Trigger generation. */
  static const field32_t A_TIMx_EGR_BG             = {.msk = 0x00000080U, .pos = 7};    /** @brief Break generation. */
  static const field32_t A_TIMx_EGR_B2G            = {.msk = 0x00000100U, .pos = 8};    /** @brief Break 2 generation. */
  static const field32_t A_TIMx_CCMRx_INPUT_IC2PCS = {.msk = 0x00000C00U, .pos = 10};   /** @brief Input capture 2 prescaler. */
  static const field32_t A_TIMx_CCMRx_INPUT_ICPCS  = {.msk = 0x0000000CU, .pos = 2};    /** @brief Input capture 1 prescaler. */
  static const field32_t A_TIMx_CNT_CNT            = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Counter value. */
  static const field32_t A_TIMx_CNT_UIFCPY         = {.msk = 0x80000000U, .pos = 31};   /** @brief UIF copy. */
  static const field32_t A_TIMx_PSC_PSC            = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Prescaler value. */
  static const field32_t A_TIMx_ARR_ARR            = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Auto-reload value. */
  static const field32_t A_TIMx_CCRx_CCR1          = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Capture/Compare 1 value. */
  static const field32_t A_TIMx_DCR_DBL            = {.msk = 0x00001F00U, .pos = 8};    /** @brief DMA burst length. */
  static const field32_t A_TIMx_DCR_DBA            = {.msk = 0x0000001FU, .pos = 0};    /** @brief DMA base address. */
  static const field32_t A_TIMx_DMAR_DMAB          = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief DMA register for burst accesses. */
  static const field32_t A_TIMx_RCR_REP            = {.msk = 0x000000FFU, .pos = 0};    /** @brief Repetition counter value. */
  static const field32_t A_TIMx_BDTR_DTG           = {.msk = 0x000000FFU, .pos = 0};    /** @brief Dead-time generator setup. */
  static const field32_t A_TIMx_BDTR_LOCK          = {.msk = 0x00000300U, .pos = 8};    /** @brief Lock configuration. */
  static const field32_t A_TIMx_BDTR_OSSI          = {.msk = 0x00000400U, .pos = 10};   /** @brief Off-state selection for idle mode. */
  static const field32_t A_TIMx_BDTR_OSSR          = {.msk = 0x00000800U, .pos = 11};   /** @brief Off-state selection for run mode. */
  static const field32_t A_TIMx_BDTR_BKE           = {.msk = 0x00001000U, .pos = 12};   /** @brief Break enable. */
  static const field32_t A_TIMx_BDTR_BKP           = {.msk = 0x00002000U, .pos = 13};   /** @brief Break polarity. */
  static const field32_t A_TIMx_BDTR_AOE           = {.msk = 0x00004000U, .pos = 14};   /** @brief Automatic output enable. */
  static const field32_t A_TIMx_BDTR_MOE           = {.msk = 0x00008000U, .pos = 15};   /** @brief Main output enable. */
  static const field32_t A_TIMx_BDTR_BKF           = {.msk = 0x000F0000U, .pos = 16};   /** @brief Break filter. */
  static const field32_t A_TIMx_BDTR_BK2F          = {.msk = 0x00F00000U, .pos = 20};   /** @brief Break 2 filter. */
  static const field32_t A_TIMx_BDTR_BK2E          = {.msk = 0x01000000U, .pos = 24};   /** @brief Break 2 enable. */
  static const field32_t A_TIMx_BDTR_BK2P          = {.msk = 0x02000000U, .pos = 25};   /** @brief Break 2 polarity. */
  static const field32_t A_TIMx_CRR6_CCR6          = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Capture/Compare 6 value. */
  static const field32_t A_TIMx_AFx_BKINE          = {.msk = 0x00000001U, .pos = 0};    /** @brief BRK BKIN input enable. */
  static const field32_t A_TIMx_AFx_BKDF1BK0E      = {.msk = 0x00000100U, .pos = 8};    /** @brief BRK dfsdm1_break[0] enable. */
  static const field32_t A_TIMx_AFx_BKINP          = {.msk = 0x00000200U, .pos = 9};    /** @brief BRK BKIN input polarity. */
  static const field32_t A_TIMx_AFx_ETRSEL         = {.msk = 0x0003C000U, .pos = 14};   /** @brief ETR source selection. */

  /**** Enumerated A_TIMx Register Field Definitions ****/

  static field32_t const A_TIMx_DIER_CCxDE[5] = {
    [1] = {.msk = 0x00000200U, .pos = 9},    /** @brief Capture/Compare 1 DMA request enable. */
    [2] = {.msk = 0x00000400U, .pos = 10},   /** @brief Capture/Compare 2 DMA request enable. */
    [3] = {.msk = 0x00000800U, .pos = 11},   /** @brief Capture/Compare 3 DMA request enable. */
    [4] = {.msk = 0x00001000U, .pos = 12},   /** @brief Capture/Compare 4 DMA request enable. */
  };

  static field32_t const A_TIMx_DIER_CCxIE[5] = {
    [1] = {.msk = 0x00000002U, .pos = 1},   /** @brief Capture/Compare 1 interrupt enable. */
    [2] = {.msk = 0x00000004U, .pos = 2},   /** @brief Capture/Compare 2 interrupt enable. */
    [3] = {.msk = 0x00000008U, .pos = 3},   /** @brief Capture/Compare 3 interrupt enable. */
    [4] = {.msk = 0x00000010U, .pos = 4},   /** @brief Capture/Compare 4 interrupt enable. */
  };

  static field32_t const A_TIMx_SR_CCxIF[7] = {
    [1] = {.msk = 0x00000002U, .pos = 1},    /** @brief Capture/compare 1 interrupt flag. */
    [2] = {.msk = 0x00000004U, .pos = 2},    /** @brief Capture/Compare 2 interrupt flag. */
    [3] = {.msk = 0x00000008U, .pos = 3},    /** @brief Capture/Compare 3 interrupt flag. */
    [4] = {.msk = 0x00000010U, .pos = 4},    /** @brief Capture/Compare 4 interrupt flag. */
    [5] = {.msk = 0x00010000U, .pos = 16},   /** @brief Compare 5 interrupt flag. */
    [6] = {.msk = 0x00020000U, .pos = 17},   /** @brief Compare 6 interrupt flag. */
  };

  static field32_t const A_TIMx_SR_CCxOF[5] = {
    [1] = {.msk = 0x00000200U, .pos = 9},    /** @brief Capture/Compare 1 overcapture flag. */
    [2] = {.msk = 0x00000400U, .pos = 10},   /** @brief Capture/compare 2 overcapture flag. */
    [3] = {.msk = 0x00000800U, .pos = 11},   /** @brief Capture/Compare 3 overcapture flag. */
    [4] = {.msk = 0x00001000U, .pos = 12},   /** @brief Capture/Compare 4 overcapture flag. */
  };

  static field32_t const A_TIMx_EGR_CCxG[5] = {
    [1] = {.msk = 0x00000002U, .pos = 1},   /** @brief Capture/compare 1 generation. */
    [2] = {.msk = 0x00000004U, .pos = 2},   /** @brief Capture/compare 2 generation. */
    [3] = {.msk = 0x00000008U, .pos = 3},   /** @brief Capture/compare 3 generation. */
    [4] = {.msk = 0x00000010U, .pos = 4},   /** @brief Capture/compare 4 generation. */
  };

  static field32_t const A_TIMx_CCMRx_OUTPUT_CCxS[3] = {
    [1] = {.msk = 0x00000003U, .pos = 0},   /** @brief Capture/Compare 1 selection. */
    [2] = {.msk = 0x00000300U, .pos = 8},   /** @brief Capture/Compare 2 selection. */
  };

  static field32_t const A_TIMx_CCMRx_OUTPUT_OCxFE[3] = {
    [1] = {.msk = 0x00000004U, .pos = 2},    /** @brief Output compare 1 fast enable. */
    [2] = {.msk = 0x00000400U, .pos = 10},   /** @brief Output compare 2 fast enable. */
  };

  static field32_t const A_TIMx_CCMRx_OUTPUT_OCxPE[3] = {
    [1] = {.msk = 0x00000008U, .pos = 3},    /** @brief Output compare 1 preload enable. */
    [2] = {.msk = 0x00000800U, .pos = 11},   /** @brief Output compare 2 preload enable. */
  };

  static field32_t const A_TIMx_CCMRx_OUTPUT_OCxM[3] = {
    [1] = {.msk = 0x00000070U, .pos = 4},    /** @brief Output compare 1 mode. */
    [2] = {.msk = 0x00007000U, .pos = 12},   /** @brief Output compare 2 mode. */
  };

  static field32_t const A_TIMx_CCMRx_OUTPUT_OCxCE[3] = {
    [1] = {.msk = 0x00000080U, .pos = 7},    /** @brief Output compare 1 clear enable. */
    [2] = {.msk = 0x00008000U, .pos = 15},   /** @brief Output compare 2 clear enable. */
  };

  static field32_t const A_TIMx_CCMRx_OUTPUT_OCxM_3[3] = {
    [1] = {.msk = 0x00010000U, .pos = 16},   /** @brief Output compare 1 mode - bit 3. */
    [2] = {.msk = 0x01000000U, .pos = 24},   /** @brief Output compare 2 mode - bit 3. */
  };

  static field32_t const A_TIMx_CCMRx_INPUT_ICxF[3] = {
    [1] = {.msk = 0x000000F0U, .pos = 4},    /** @brief Input capture 1 filter. */
    [2] = {.msk = 0x0000F000U, .pos = 12},   /** @brief Input capture 2 filter. */
  };

  static field32_t const A_TIMx_CCER_CCxE[7] = {
    [1] = {.msk = 0x00000001U, .pos = 0},    /** @brief Capture/Compare 1 output enable. */
    [2] = {.msk = 0x00000010U, .pos = 4},    /** @brief Capture/Compare 2 output enable. */
    [3] = {.msk = 0x00000100U, .pos = 8},    /** @brief Capture/Compare 3 output enable. */
    [4] = {.msk = 0x00001000U, .pos = 12},   /** @brief Capture/Compare 4 output enable. */
    [5] = {.msk = 0x00010000U, .pos = 16},   /** @brief Capture/Compare 5 output enable. */
    [6] = {.msk = 0x00100000U, .pos = 20},   /** @brief Capture/Compare 6 output enable. */
  };

  static field32_t const A_TIMx_CCER_CCxP[7] = {
    [1] = {.msk = 0x00000002U, .pos = 1},    /** @brief Capture/Compare 1 output polarity. */
    [2] = {.msk = 0x00000020U, .pos = 5},    /** @brief Capture/Compare 2 output polarity. */
    [3] = {.msk = 0x00000200U, .pos = 9},    /** @brief Capture/Compare 3 output polarity. */
    [4] = {.msk = 0x00002000U, .pos = 13},   /** @brief Capture/Compare 3 output polarity. */
    [5] = {.msk = 0x00020000U, .pos = 17},   /** @brief Capture/Compare 5 output polarity. */
    [6] = {.msk = 0x00200000U, .pos = 21},   /** @brief Capture/Compare 6 output polarity. */
  };

  static field32_t const A_TIMx_CCER_CCxNE[4] = {
    [1] = {.msk = 0x00000004U, .pos = 2},    /** @brief Capture/Compare 1 complementary output enable. */
    [2] = {.msk = 0x00000040U, .pos = 6},    /** @brief Capture/Compare 2 complementary output enable. */
    [3] = {.msk = 0x00000400U, .pos = 10},   /** @brief Capture/Compare 3 complementary output enable. */
  };

  static field32_t const A_TIMx_CCER_CCxNP[5] = {
    [1] = {.msk = 0x00000008U, .pos = 3},    /** @brief Capture/Compare 1 output polarity. */
    [2] = {.msk = 0x00000080U, .pos = 7},    /** @brief Capture/Compare 2 output polarity. */
    [3] = {.msk = 0x00000800U, .pos = 11},   /** @brief Capture/Compare 3 output polarity. */
    [4] = {.msk = 0x00008000U, .pos = 15},   /** @brief Capture/Compare 4 complementary output polarity. */
  };

  static field32_t const A_TIMx_AFx_BKCMPxE[3] = {
    [1] = {.msk = 0x00000002U, .pos = 1},   /** @brief BRK COMP1 enable. */
    [2] = {.msk = 0x00000004U, .pos = 2},   /** @brief BRK COMP2 enable. */
  };

  static field32_t const A_TIMx_AFx_BKCMPxP[3] = {
    [1] = {.msk = 0x00000400U, .pos = 10},   /** @brief BRK COMP1 input polarity. */
    [2] = {.msk = 0x00000800U, .pos = 11},   /** @brief BRK COMP2 input polarity. */
  };

  static field32_t const A_TIMx_TISEL_TIxSEL[5] = {
    [1] = {.msk = 0x0000000FU, .pos = 0},    /** @brief Selects TI1[0] to TI1[15] input. */
    [2] = {.msk = 0x00000F00U, .pos = 8},    /** @brief Selects TI2[0] to TI2[15] input. */
    [3] = {.msk = 0x000F0000U, .pos = 16},   /** @brief Selects TI3[0] to TI3[15] input. */
    [4] = {.msk = 0x0F000000U, .pos = 24},   /** @brief Selects TI4[0] to TI4[15] input. */
  };

  /************************************************************************************************
   * FDCANx Definitions
   ************************************************************************************************/

  /**** Enumerated FDCANx Register Definitions ****/

  static const ro_reg32_t FDCANx_FDCAN_CREL[3] = {
    [1] = (ro_reg32_t)0x4000A000U,   /** @brief FDCAN core release register. */
    [2] = (ro_reg32_t)0x4000A400U,   /** @brief FDCAN core release register. */
  };

  static const ro_reg32_t FDCANx_FDCAN_ENDN[3] = {
    [1] = (ro_reg32_t)0x4000A004U,   /** @brief FDCAN core release register. */
    [2] = (ro_reg32_t)0x4000A404U,   /** @brief FDCAN core release register. */
  };

  static const ro_reg32_t FDCANx_FDCAN_DBTP[3] = {
    [1] = (ro_reg32_t)0x4000A00CU,   /** @brief FDCAN data bit timing and prescaler register. */
    [2] = (ro_reg32_t)0x4000A40CU,   /** @brief FDCAN data bit timing and prescaler register. */
  };

  static const ro_reg32_t FDCANx_FDCAN_TEST[3] = {
    [1] = (ro_reg32_t)0x4000A010U,   /** @brief FDCAN test register. */
    [2] = (ro_reg32_t)0x4000A410U,   /** @brief FDCAN test register. */
  };

  static const ro_reg32_t FDCANx_FDCAN_RWD[3] = {
    [1] = (ro_reg32_t)0x4000A014U,   /** @brief FDCAN RAM watchdog register. */
    [2] = (ro_reg32_t)0x4000A414U,   /** @brief FDCAN RAM watchdog register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_CCCR[3] = {
    [1] = (rw_reg32_t)0x4000A018U,   /** @brief FDCAN CC control register. */
    [2] = (rw_reg32_t)0x4000A418U,   /** @brief FDCAN CC control register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_NBTP[3] = {
    [1] = (rw_reg32_t)0x4000A01CU,   /** @brief FDCAN nominal bit timing and prescaler register. */
    [2] = (rw_reg32_t)0x4000A41CU,   /** @brief FDCAN nominal bit timing and prescaler register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TSCC[3] = {
    [1] = (rw_reg32_t)0x4000A020U,   /** @brief FDCAN timestamp counter configuration register. */
    [2] = (rw_reg32_t)0x4000A420U,   /** @brief FDCAN timestamp counter configuration register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TSCV[3] = {
    [1] = (rw_reg32_t)0x4000A024U,   /** @brief FDCAN timestamp counter value register. */
    [2] = (rw_reg32_t)0x4000A424U,   /** @brief FDCAN timestamp counter value register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TOCC[3] = {
    [1] = (rw_reg32_t)0x4000A028U,   /** @brief FDCAN timeout counter configuration register. */
    [2] = (rw_reg32_t)0x4000A428U,   /** @brief FDCAN timeout counter configuration register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TOCV[3] = {
    [1] = (rw_reg32_t)0x4000A02CU,   /** @brief FDCAN timeout counter value register. */
    [2] = (rw_reg32_t)0x4000A42CU,   /** @brief FDCAN timeout counter value register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_ECR[3] = {
    [1] = (rw_reg32_t)0x4000A040U,   /** @brief FDCAN error counter register. */
    [2] = (rw_reg32_t)0x4000A440U,   /** @brief FDCAN error counter register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_PSR[3] = {
    [1] = (rw_reg32_t)0x4000A044U,   /** @brief FDCAN protocol status register. */
    [2] = (rw_reg32_t)0x4000A444U,   /** @brief FDCAN protocol status register. */
  };

  static const ro_reg32_t FDCANx_FDCAN_TDCR[3] = {
    [1] = (ro_reg32_t)0x4000A048U,   /** @brief FDCAN transmitter delay compensation register. */
    [2] = (ro_reg32_t)0x4000A448U,   /** @brief FDCAN transmitter delay compensation register. */
  };

  static const ro_reg32_t FDCANx_FDCAN_IR[3] = {
    [1] = (ro_reg32_t)0x4000A050U,   /** @brief FDCAN interrupt register. */
    [2] = (ro_reg32_t)0x4000A450U,   /** @brief FDCAN interrupt register. */
  };

  static const ro_reg32_t FDCANx_FDCAN_IE[3] = {
    [1] = (ro_reg32_t)0x4000A054U,   /** @brief FDCAN interrupt enable register. */
    [2] = (ro_reg32_t)0x4000A454U,   /** @brief FDCAN interrupt enable register. */
  };

  static const ro_reg32_t FDCANx_FDCAN_ILS[3] = {
    [1] = (ro_reg32_t)0x4000A058U,   /** @brief FDCAN interrupt line select register. */
    [2] = (ro_reg32_t)0x4000A458U,   /** @brief FDCAN interrupt line select register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_ILE[3] = {
    [1] = (rw_reg32_t)0x4000A05CU,   /** @brief FDCAN interrupt line enable register. */
    [2] = (rw_reg32_t)0x4000A45CU,   /** @brief FDCAN interrupt line enable register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_GFC[3] = {
    [1] = (rw_reg32_t)0x4000A080U,   /** @brief FDCAN global filter configuration register. */
    [2] = (rw_reg32_t)0x4000A480U,   /** @brief FDCAN global filter configuration register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_SIDFC[3] = {
    [1] = (rw_reg32_t)0x4000A084U,   /** @brief FDCAN standard ID filter configuration register. */
    [2] = (rw_reg32_t)0x4000A484U,   /** @brief FDCAN standard ID filter configuration register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_XIDFC[3] = {
    [1] = (rw_reg32_t)0x4000A088U,   /** @brief FDCAN extended ID filter configuration register. */
    [2] = (rw_reg32_t)0x4000A488U,   /** @brief FDCAN extended ID filter configuration register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_XIDAM[3] = {
    [1] = (rw_reg32_t)0x4000A090U,   /** @brief FDCAN extended ID and mask register. */
    [2] = (rw_reg32_t)0x4000A490U,   /** @brief FDCAN extended ID and mask register. */
  };

  static const ro_reg32_t FDCANx_FDCAN_HPMS[3] = {
    [1] = (ro_reg32_t)0x4000A094U,   /** @brief FDCAN high priority message status register. */
    [2] = (ro_reg32_t)0x4000A494U,   /** @brief FDCAN high priority message status register. */
  };

  static const ro_reg32_t FDCANx_FDCAN_NDATx[3][3] = {
    [1] = {
      [1] = (ro_reg32_t)0x4000A098U,   /** @brief FDCAN new data 1 register. */
      [2] = (ro_reg32_t)0x4000A09CU,   /** @brief FDCAN new data 2 register. */
    },
    [2] = {
      [1] = (ro_reg32_t)0x4000A498U,   /** @brief FDCAN new data 1 register. */
      [2] = (ro_reg32_t)0x4000A49CU,   /** @brief FDCAN new data 2 register. */
    },
  };

  static const rw_reg32_t FDCANx_FDCAN_RXFxC[3][2] = {
    [1] = {
      [0] = (rw_reg32_t)0x4000A0A0U,   /** @brief FDCAN rx FIFO 0 configuration register. */
      [1] = (rw_reg32_t)0x4000A0B0U,   /** @brief FDCAN rx FIFO 1 configuration register. */
    },
    [2] = {
      [0] = (rw_reg32_t)0x4000A4A0U,   /** @brief FDCAN rx FIFO 0 configuration register. */
      [1] = (rw_reg32_t)0x4000A4B0U,   /** @brief FDCAN rx FIFO 1 configuration register. */
    },
  };

  static const rw_reg32_t FDCANx_FDCAN_RXFxS[3][2] = {
    [1] = {
      [0] = (rw_reg32_t)0x4000A0A4U,   /** @brief FDCAN rx FIFO 0 status register. */
      [1] = (rw_reg32_t)0x4000A0B4U,   /** @brief FDCAN rx FIFO 1 status register. */
    },
    [2] = {
      [0] = (rw_reg32_t)0x4000A4A4U,   /** @brief FDCAN rx FIFO 0 status register. */
      [1] = (rw_reg32_t)0x4000A4B4U,   /** @brief FDCAN rx FIFO 1 status register. */
    },
  };

  static const rw_reg32_t FDCANx_FDCAN_RXFxA[3][2] = {
    [1] = {
      [0] = (rw_reg32_t)0x4000A0A8U,   /** @brief CAN rx FIFO 0 acknowledge register. */
      [1] = (rw_reg32_t)0x4000A0B8U,   /** @brief FDCAN rx FIFO 1 acknowledge register. */
    },
    [2] = {
      [0] = (rw_reg32_t)0x4000A4A8U,   /** @brief CAN rx FIFO 0 acknowledge register. */
      [1] = (rw_reg32_t)0x4000A4B8U,   /** @brief FDCAN rx FIFO 1 acknowledge register. */
    },
  };

  static const rw_reg32_t FDCANx_FDCAN_RXBC[3] = {
    [1] = (rw_reg32_t)0x4000A0ACU,   /** @brief FDCAN rx buffer configuration register. */
    [2] = (rw_reg32_t)0x4000A4ACU,   /** @brief FDCAN rx buffer configuration register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_RXESC[3] = {
    [1] = (rw_reg32_t)0x4000A0BCU,   /** @brief FDCAN rx buffer element size configuration register. */
    [2] = (rw_reg32_t)0x4000A4BCU,   /** @brief FDCAN rx buffer element size configuration register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TXBC[3] = {
    [1] = (rw_reg32_t)0x4000A0C0U,   /** @brief FDCAN tx buffer configuration register. */
    [2] = (rw_reg32_t)0x4000A4C0U,   /** @brief FDCAN tx buffer configuration register. */
  };

  static const ro_reg32_t FDCANx_FDCAN_TXFQS[3] = {
    [1] = (ro_reg32_t)0x4000A0C4U,   /** @brief FDCAN tx fifo/queue status register. */
    [2] = (ro_reg32_t)0x4000A4C4U,   /** @brief FDCAN tx fifo/queue status register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TXESC[3] = {
    [1] = (rw_reg32_t)0x4000A0C8U,   /** @brief FDCAN tx buffer element size configuration register. */
    [2] = (rw_reg32_t)0x4000A4C8U,   /** @brief FDCAN tx buffer element size configuration register. */
  };

  static const ro_reg32_t FDCANx_FDCAN_TXBRP[3] = {
    [1] = (ro_reg32_t)0x4000A0CCU,   /** @brief FDCAN tx buffer request pending register. */
    [2] = (ro_reg32_t)0x4000A4CCU,   /** @brief FDCAN tx buffer request pending register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TXBAR[3] = {
    [1] = (rw_reg32_t)0x4000A0D0U,   /** @brief FDCAN tx buffer add request register. */
    [2] = (rw_reg32_t)0x4000A4D0U,   /** @brief FDCAN tx buffer add request register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TXBCR[3] = {
    [1] = (rw_reg32_t)0x4000A0D4U,   /** @brief FDCAN tx buffer cancellation request register. */
    [2] = (rw_reg32_t)0x4000A4D4U,   /** @brief FDCAN tx buffer cancellation request register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TXBTO[3] = {
    [1] = (rw_reg32_t)0x4000A0D8U,   /** @brief FDCAN tx buffer transmission occurred register. */
    [2] = (rw_reg32_t)0x4000A4D8U,   /** @brief FDCAN tx buffer transmission occurred register. */
  };

  static const ro_reg32_t FDCANx_FDCAN_TXBCF[3] = {
    [1] = (ro_reg32_t)0x4000A0DCU,   /** @brief FDCAN tx buffer cancellation finished register. */
    [2] = (ro_reg32_t)0x4000A4DCU,   /** @brief FDCAN tx buffer cancellation finished register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TXBTIE[3] = {
    [1] = (rw_reg32_t)0x4000A0E0U,   /** @brief FDCAN tx buffer transmission interrupt enable register. */
    [2] = (rw_reg32_t)0x4000A4E0U,   /** @brief FDCAN tx buffer transmission interrupt enable register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TXBCIE[3] = {
    [1] = (rw_reg32_t)0x4000A0E4U,   /** @brief FDCAN tx buffer cancellation finished interrupt enable register. */
    [2] = (rw_reg32_t)0x4000A4E4U,   /** @brief FDCAN tx buffer cancellation finished interrupt enable register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TXEFC[3] = {
    [1] = (rw_reg32_t)0x4000A0F0U,   /** @brief FDCAN tx event FIFO configuration register. */
    [2] = (rw_reg32_t)0x4000A4F0U,   /** @brief FDCAN tx event FIFO configuration register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TXEFS[3] = {
    [1] = (rw_reg32_t)0x4000A0F4U,   /** @brief FDCAN tx event FIFO status register. */
    [2] = (rw_reg32_t)0x4000A4F4U,   /** @brief FDCAN tx event FIFO status register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TXEFA[3] = {
    [1] = (rw_reg32_t)0x4000A0F8U,   /** @brief FDCAN tx event FIFO acknowledge register. */
    [2] = (rw_reg32_t)0x4000A4F8U,   /** @brief FDCAN tx event FIFO acknowledge register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TTTMC[3] = {
    [1] = (rw_reg32_t)0x4000A100U,   /** @brief FDCAN TT trigger memory configuration register. */
    [2] = (rw_reg32_t)0x4000A500U,   /** @brief FDCAN TT trigger memory configuration register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TTRMC[3] = {
    [1] = (rw_reg32_t)0x4000A104U,   /** @brief FDCAN TT reference message configuration register. */
    [2] = (rw_reg32_t)0x4000A504U,   /** @brief FDCAN TT reference message configuration register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TTOCF[3] = {
    [1] = (rw_reg32_t)0x4000A108U,   /** @brief FDCAN TT operation configuration register. */
    [2] = (rw_reg32_t)0x4000A508U,   /** @brief FDCAN TT operation configuration register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TTMLM[3] = {
    [1] = (rw_reg32_t)0x4000A10CU,   /** @brief FDCAN TT matrix limits register. */
    [2] = (rw_reg32_t)0x4000A50CU,   /** @brief FDCAN TT matrix limits register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TURCF[3] = {
    [1] = (rw_reg32_t)0x4000A110U,   /** @brief FDCAN TUR configuration register. */
    [2] = (rw_reg32_t)0x4000A510U,   /** @brief FDCAN TUR configuration register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TTOCN[3] = {
    [1] = (rw_reg32_t)0x4000A114U,   /** @brief FDCAN TT operation control register. */
    [2] = (rw_reg32_t)0x4000A514U,   /** @brief FDCAN TT operation control register. */
  };

  static const rw_reg32_t FDCANx_CAN_TTGTP[3] = {
    [1] = (rw_reg32_t)0x4000A118U,   /** @brief FDCAN TT global time preset register. */
    [2] = (rw_reg32_t)0x4000A518U,   /** @brief FDCAN TT global time preset register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TTTMK[3] = {
    [1] = (rw_reg32_t)0x4000A11CU,   /** @brief FDCAN TT time mark register. */
    [2] = (rw_reg32_t)0x4000A51CU,   /** @brief FDCAN TT time mark register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TTIR[3] = {
    [1] = (rw_reg32_t)0x4000A120U,   /** @brief FDCAN TT interrupt register. */
    [2] = (rw_reg32_t)0x4000A520U,   /** @brief FDCAN TT interrupt register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TTIE[3] = {
    [1] = (rw_reg32_t)0x4000A124U,   /** @brief FDCAN TT interrupt enable register. */
    [2] = (rw_reg32_t)0x4000A524U,   /** @brief FDCAN TT interrupt enable register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TTILS[3] = {
    [1] = (rw_reg32_t)0x4000A128U,   /** @brief FDCAN TT interrupt line select register. */
    [2] = (rw_reg32_t)0x4000A528U,   /** @brief FDCAN TT interrupt line select register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TTOST[3] = {
    [1] = (rw_reg32_t)0x4000A12CU,   /** @brief FDCAN TT operation status register. */
    [2] = (rw_reg32_t)0x4000A52CU,   /** @brief FDCAN TT operation status register. */
  };

  static const ro_reg32_t FDCANx_FDCAN_TURNA[3] = {
    [1] = (ro_reg32_t)0x4000A130U,   /** @brief FDCAN TUR numerator actual register. */
    [2] = (ro_reg32_t)0x4000A530U,   /** @brief FDCAN TUR numerator actual register. */
  };

  static const ro_reg32_t FDCANx_FDCAN_TTLGT[3] = {
    [1] = (ro_reg32_t)0x4000A134U,   /** @brief FDCAN TT local and global time register. */
    [2] = (ro_reg32_t)0x4000A534U,   /** @brief FDCAN TT local and global time register. */
  };

  static const ro_reg32_t FDCANx_FDCAN_TTCTC[3] = {
    [1] = (ro_reg32_t)0x4000A138U,   /** @brief FDCAN TT cycle time and count register. */
    [2] = (ro_reg32_t)0x4000A538U,   /** @brief FDCAN TT cycle time and count register. */
  };

  static const ro_reg32_t FDCANx_FDCAN_TTCPT[3] = {
    [1] = (ro_reg32_t)0x4000A13CU,   /** @brief FDCAN TT capture time register. */
    [2] = (ro_reg32_t)0x4000A53CU,   /** @brief FDCAN TT capture time register. */
  };

  static const ro_reg32_t FDCANx_FDCAN_TTCSM[3] = {
    [1] = (ro_reg32_t)0x4000A140U,   /** @brief FDCAN TT cycle sync mark register. */
    [2] = (ro_reg32_t)0x4000A540U,   /** @brief FDCAN TT cycle sync mark register. */
  };

  static const rw_reg32_t FDCANx_FDCAN_TTTS[3] = {
    [1] = (rw_reg32_t)0x4000A300U,   /** @brief FDCAN TT trigger select register. */
    [2] = (rw_reg32_t)0x4000A700U,   /** @brief FDCAN TT trigger select register. */
  };

  /**** FDCANx Register Field Definitions ****/

  static const field32_t FDCANx_FDCAN_CREL_REL     = {.msk = 0xF0000000U, .pos = 28};   /** @brief Core release. */
  static const field32_t FDCANx_FDCAN_CREL_STEP    = {.msk = 0x0F000000U, .pos = 24};   /** @brief Step of core release. */
  static const field32_t FDCANx_FDCAN_CREL_SUBSTEP = {.msk = 0x00F00000U, .pos = 20};   /** @brief Sub-step of core release. */
  static const field32_t FDCANx_FDCAN_CREL_YEAR    = {.msk = 0x000F0000U, .pos = 16};   /** @brief Timestamp year. */
  static const field32_t FDCANx_FDCAN_CREL_MON     = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Timestamp month. */
  static const field32_t FDCANx_FDCAN_CREL_DAY     = {.msk = 0x000000FFU, .pos = 0};    /** @brief Timestamp day. */
  static const field32_t FDCANx_FDCAN_DBTP_DSJW    = {.msk = 0x0000000FU, .pos = 0};    /** @brief Synchronization jump width. */
  static const field32_t FDCANx_FDCAN_DBTP_DBRP    = {.msk = 0x001F0000U, .pos = 16};   /** @brief Data bit rate prescaler. */
  static const field32_t FDCANx_FDCAN_DBTP_TDC     = {.msk = 0x00800000U, .pos = 23};   /** @brief Transceiver delay compensation. */
  static const field32_t FDCANx_FDCAN_TEST_LBCK    = {.msk = 0x00000010U, .pos = 4};    /** @brief Loop back mode. */
  static const field32_t FDCANx_FDCAN_TEST_TX      = {.msk = 0x00000060U, .pos = 5};    /** @brief Loop back mode. */
  static const field32_t FDCANx_FDCAN_TEST_RX      = {.msk = 0x00000080U, .pos = 7};    /** @brief Control of transmit pin. */
  static const field32_t FDCANx_FDCAN_RWD_WDV      = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Watchdog value. */
  static const field32_t FDCANx_FDCAN_RWD_WDC      = {.msk = 0x000000FFU, .pos = 0};    /** @brief Watchdog configuration. */
  static const field32_t FDCANx_FDCAN_CCCR_INIT    = {.msk = 0x00000001U, .pos = 0};    /** @brief Initialization. */
  static const field32_t FDCANx_FDCAN_CCCR_CCE     = {.msk = 0x00000002U, .pos = 1};    /** @brief Configuration change enable. */
  static const field32_t FDCANx_FDCAN_CCCR_ASM     = {.msk = 0x00000004U, .pos = 2};    /** @brief ASM restricted operation mode. */
  static const field32_t FDCANx_FDCAN_CCCR_CSA     = {.msk = 0x00000008U, .pos = 3};    /** @brief Clock stop acknowledge. */
  static const field32_t FDCANx_FDCAN_CCCR_CSR     = {.msk = 0x00000010U, .pos = 4};    /** @brief Clock stop request. */
  static const field32_t FDCANx_FDCAN_CCCR_MON     = {.msk = 0x00000020U, .pos = 5};    /** @brief Bus monitoring mode. */
  static const field32_t FDCANx_FDCAN_CCCR_DAR     = {.msk = 0x00000040U, .pos = 6};    /** @brief Disable automatic retransmission. */
  static const field32_t FDCANx_FDCAN_CCCR_TEST    = {.msk = 0x00000080U, .pos = 7};    /** @brief Test mode enable. */
  static const field32_t FDCANx_FDCAN_CCCR_FDOE    = {.msk = 0x00000100U, .pos = 8};    /** @brief FD operation enable. */
  static const field32_t FDCANx_FDCAN_CCCR_BSE     = {.msk = 0x00000200U, .pos = 9};    /** @brief FDCAN bit rate switching. */
  static const field32_t FDCANx_FDCAN_CCCR_PXHD    = {.msk = 0x00001000U, .pos = 12};   /** @brief Protocol exception handling disable. */
  static const field32_t FDCANx_FDCAN_CCCR_EFBI    = {.msk = 0x00002000U, .pos = 13};   /** @brief Edge filtering during bus integration. */
  static const field32_t FDCANx_FDCAN_CCCR_TXP     = {.msk = 0x00004000U, .pos = 14};   /** @brief TXP. */
  static const field32_t FDCANx_FDCAN_CCCR_NISO    = {.msk = 0x00008000U, .pos = 15};   /** @brief Non ISO operation. */
  static const field32_t FDCANx_FDCAN_NBTP_NSJW    = {.msk = 0xFE000000U, .pos = 25};   /** @brief NSJW: nominal (re)synchronization jump width. */
  static const field32_t FDCANx_FDCAN_NBTP_NBRP    = {.msk = 0x01FF0000U, .pos = 16};   /** @brief Bit rate prescaler. */
  static const field32_t FDCANx_FDCAN_NBTP_NTSEG1  = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Nominal time segment before sample point. */
  static const field32_t FDCANx_FDCAN_NBTP_TSEG2   = {.msk = 0x0000007FU, .pos = 0};    /** @brief Nominal time segment after sample point. */
  static const field32_t FDCANx_FDCAN_TSCC_TCP     = {.msk = 0x000F0000U, .pos = 16};   /** @brief Timestamp counter prescaler. */
  static const field32_t FDCANx_FDCAN_TSCC_TSS     = {.msk = 0x00000003U, .pos = 0};    /** @brief Timestamp select. */
  static const field32_t FDCANx_FDCAN_TSCV_TSC     = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timestamp counter. */
  static const field32_t FDCANx_FDCAN_TOCC_ETOC    = {.msk = 0x00000001U, .pos = 0};    /** @brief Enable timeout counter. */
  static const field32_t FDCANx_FDCAN_TOCC_TOS     = {.msk = 0x00000006U, .pos = 1};    /** @brief Timeout select. */
  static const field32_t FDCANx_FDCAN_TOCC_TOP     = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief Timeout period. */
  static const field32_t FDCANx_FDCAN_TOCV_TOC     = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Timeout counter. */
  static const field32_t FDCANx_FDCAN_ECR_CEL      = {.msk = 0x00FF0000U, .pos = 16};   /** @brief AN error logging. */
  static const field32_t FDCANx_FDCAN_ECR_RP       = {.msk = 0x00008000U, .pos = 15};   /** @brief Receive error passive. */
  static const field32_t FDCANx_FDCAN_ECR_TREC     = {.msk = 0x00007F00U, .pos = 8};    /** @brief Receive error counter. */
  static const field32_t FDCANx_FDCAN_ECR_TEC      = {.msk = 0x000000FFU, .pos = 0};    /** @brief Transmit error counter. */
  static const field32_t FDCANx_FDCAN_PSR_LEC      = {.msk = 0x00000007U, .pos = 0};    /** @brief Last error code. */
  static const field32_t FDCANx_FDCAN_PSR_ACT      = {.msk = 0x00000018U, .pos = 3};    /** @brief Activity. */
  static const field32_t FDCANx_FDCAN_PSR_EP       = {.msk = 0x00000020U, .pos = 5};    /** @brief Error passive. */
  static const field32_t FDCANx_FDCAN_PSR_EW       = {.msk = 0x00000040U, .pos = 6};    /** @brief Warning status. */
  static const field32_t FDCANx_FDCAN_PSR_BO       = {.msk = 0x00000080U, .pos = 7};    /** @brief Bus_Off status. */
  static const field32_t FDCANx_FDCAN_PSR_DLEC     = {.msk = 0x00000700U, .pos = 8};    /** @brief Data last error code. */
  static const field32_t FDCANx_FDCAN_PSR_RESI     = {.msk = 0x00000800U, .pos = 11};   /** @brief ESI flag of last received FDCAN message. */
  static const field32_t FDCANx_FDCAN_PSR_RBRS     = {.msk = 0x00001000U, .pos = 12};   /** @brief BRS flag of last received FDCAN message. */
  static const field32_t FDCANx_FDCAN_PSR_REDL     = {.msk = 0x00002000U, .pos = 13};   /** @brief Received FDCAN message. */
  static const field32_t FDCANx_FDCAN_PSR_PXE      = {.msk = 0x00004000U, .pos = 14};   /** @brief Protocol exception event. */
  static const field32_t FDCANx_FDCAN_PSR_TDCV     = {.msk = 0x007F0000U, .pos = 16};   /** @brief Transmitter delay compensation value. */
  static const field32_t FDCANx_FDCAN_TDCR_TDCF    = {.msk = 0x0000007FU, .pos = 0};    /** @brief Transmitter delay compensation filter window length. */
  static const field32_t FDCANx_FDCAN_TDCR_TDCO    = {.msk = 0x00007F00U, .pos = 8};    /** @brief Transmitter delay compensation offset. */
  static const field32_t FDCANx_FDCAN_IR_HPM       = {.msk = 0x00000100U, .pos = 8};    /** @brief High priority message. */
  static const field32_t FDCANx_FDCAN_IR_TC        = {.msk = 0x00000200U, .pos = 9};    /** @brief Transmission completed. */
  static const field32_t FDCANx_FDCAN_IR_TCF       = {.msk = 0x00000400U, .pos = 10};   /** @brief Transmission cancellation finished. */
  static const field32_t FDCANx_FDCAN_IR_TEF       = {.msk = 0x00000800U, .pos = 11};   /** @brief Tx FIFO empty. */
  static const field32_t FDCANx_FDCAN_IR_TEFN      = {.msk = 0x00001000U, .pos = 12};   /** @brief Tx event FIFO new entry. */
  static const field32_t FDCANx_FDCAN_IR_TEFW      = {.msk = 0x00002000U, .pos = 13};   /** @brief Tx event FIFO watermark reached. */
  static const field32_t FDCANx_FDCAN_IR_TEFF      = {.msk = 0x00004000U, .pos = 14};   /** @brief Tx event FIFO full. */
  static const field32_t FDCANx_FDCAN_IR_TEFL      = {.msk = 0x00008000U, .pos = 15};   /** @brief Tx event FIFO element lost. */
  static const field32_t FDCANx_FDCAN_IR_TSW       = {.msk = 0x00010000U, .pos = 16};   /** @brief Timestamp wraparound. */
  static const field32_t FDCANx_FDCAN_IR_MRAF      = {.msk = 0x00020000U, .pos = 17};   /** @brief Message RAM access failure. */
  static const field32_t FDCANx_FDCAN_IR_TOO       = {.msk = 0x00040000U, .pos = 18};   /** @brief Timeout occurred. */
  static const field32_t FDCANx_FDCAN_IR_DRX       = {.msk = 0x00080000U, .pos = 19};   /** @brief Message stored to dedicated rx buffer. */
  static const field32_t FDCANx_FDCAN_IR_ELO       = {.msk = 0x00400000U, .pos = 22};   /** @brief Error logging overflow. */
  static const field32_t FDCANx_FDCAN_IR_EP        = {.msk = 0x00800000U, .pos = 23};   /** @brief Error passive. */
  static const field32_t FDCANx_FDCAN_IR_EW        = {.msk = 0x01000000U, .pos = 24};   /** @brief Warning status. */
  static const field32_t FDCANx_FDCAN_IR_BO        = {.msk = 0x02000000U, .pos = 25};   /** @brief Bus_Off status. */
  static const field32_t FDCANx_FDCAN_IR_WDI       = {.msk = 0x04000000U, .pos = 26};   /** @brief Watchdog interrupt. */
  static const field32_t FDCANx_FDCAN_IR_PEA       = {.msk = 0x08000000U, .pos = 27};   /** @brief Protocol error in arbitration phase (nominal bit time is used). */
  static const field32_t FDCANx_FDCAN_IR_PED       = {.msk = 0x10000000U, .pos = 28};   /** @brief Protocol error in data phase (data bit time is used). */
  static const field32_t FDCANx_FDCAN_IR_ARA       = {.msk = 0x20000000U, .pos = 29};   /** @brief Access to reserved address. */
  static const field32_t FDCANx_FDCAN_IE_HPME      = {.msk = 0x00000100U, .pos = 8};    /** @brief High priority message enable. */
  static const field32_t FDCANx_FDCAN_IE_TCE       = {.msk = 0x00000200U, .pos = 9};    /** @brief Transmission completed enable. */
  static const field32_t FDCANx_FDCAN_IE_TCFE      = {.msk = 0x00000400U, .pos = 10};   /** @brief Transmission cancellation finished enable. */
  static const field32_t FDCANx_FDCAN_IE_TEFE      = {.msk = 0x00000800U, .pos = 11};   /** @brief Tx FIFO empty enable. */
  static const field32_t FDCANx_FDCAN_IE_TEFNE     = {.msk = 0x00001000U, .pos = 12};   /** @brief Tx event FIFO new entry enable. */
  static const field32_t FDCANx_FDCAN_IE_TEFWE     = {.msk = 0x00002000U, .pos = 13};   /** @brief Tx event FIFO watermark reached enable. */
  static const field32_t FDCANx_FDCAN_IE_TEFFE     = {.msk = 0x00004000U, .pos = 14};   /** @brief Tx event FIFO full enable. */
  static const field32_t FDCANx_FDCAN_IE_TEFLE     = {.msk = 0x00008000U, .pos = 15};   /** @brief Tx event FIFO element lost enable. */
  static const field32_t FDCANx_FDCAN_IE_TSWE      = {.msk = 0x00010000U, .pos = 16};   /** @brief Timestamp wraparound enable. */
  static const field32_t FDCANx_FDCAN_IE_MRAFE     = {.msk = 0x00020000U, .pos = 17};   /** @brief Message RAM access failure enable. */
  static const field32_t FDCANx_FDCAN_IE_TOOE      = {.msk = 0x00040000U, .pos = 18};   /** @brief Timeout occurred enable. */
  static const field32_t FDCANx_FDCAN_IE_DRXE      = {.msk = 0x00080000U, .pos = 19};   /** @brief Message stored to dedicated rx buffer enable. */
  static const field32_t FDCANx_FDCAN_IE_BECE      = {.msk = 0x00100000U, .pos = 20};   /** @brief Bit error corrected interrupt enable. */
  static const field32_t FDCANx_FDCAN_IE_BEUE      = {.msk = 0x00200000U, .pos = 21};   /** @brief Bit error uncorrected interrupt enable. */
  static const field32_t FDCANx_FDCAN_IE_ELOE      = {.msk = 0x00400000U, .pos = 22};   /** @brief Error logging overflow enable. */
  static const field32_t FDCANx_FDCAN_IE_EPE       = {.msk = 0x00800000U, .pos = 23};   /** @brief Error passive enable. */
  static const field32_t FDCANx_FDCAN_IE_EWE       = {.msk = 0x01000000U, .pos = 24};   /** @brief Warning status enable. */
  static const field32_t FDCANx_FDCAN_IE_BOE       = {.msk = 0x02000000U, .pos = 25};   /** @brief Bus_Off status enable. */
  static const field32_t FDCANx_FDCAN_IE_WDIE      = {.msk = 0x04000000U, .pos = 26};   /** @brief Watchdog interrupt enable. */
  static const field32_t FDCANx_FDCAN_IE_PEAE      = {.msk = 0x08000000U, .pos = 27};   /** @brief Protocol error in arbitration phase enable. */
  static const field32_t FDCANx_FDCAN_IE_PEDE      = {.msk = 0x10000000U, .pos = 28};   /** @brief Protocol error in data phase enable. */
  static const field32_t FDCANx_FDCAN_IE_ARAE      = {.msk = 0x20000000U, .pos = 29};   /** @brief Access to reserved address enable. */
  static const field32_t FDCANx_FDCAN_ILS_HPML     = {.msk = 0x00000100U, .pos = 8};    /** @brief High priority message interrupt line. */
  static const field32_t FDCANx_FDCAN_ILS_TCL      = {.msk = 0x00000200U, .pos = 9};    /** @brief Transmission completed interrupt line. */
  static const field32_t FDCANx_FDCAN_ILS_TCFL     = {.msk = 0x00000400U, .pos = 10};   /** @brief Transmission cancellation finished interrupt line. */
  static const field32_t FDCANx_FDCAN_ILS_TEFL     = {.msk = 0x00000800U, .pos = 11};   /** @brief Tx FIFO empty interrupt line. */
  static const field32_t FDCANx_FDCAN_ILS_TEFNL    = {.msk = 0x00001000U, .pos = 12};   /** @brief Tx event FIFO new entry interrupt line. */
  static const field32_t FDCANx_FDCAN_ILS_TEFWL    = {.msk = 0x00002000U, .pos = 13};   /** @brief Tx event FIFO watermark reached interrupt line. */
  static const field32_t FDCANx_FDCAN_ILS_TEFFL    = {.msk = 0x00004000U, .pos = 14};   /** @brief Tx event FIFO full interrupt line. */
  static const field32_t FDCANx_FDCAN_ILS_TEFLL    = {.msk = 0x00008000U, .pos = 15};   /** @brief Tx event FIFO element lost interrupt line. */
  static const field32_t FDCANx_FDCAN_ILS_TSWL     = {.msk = 0x00010000U, .pos = 16};   /** @brief Timestamp wraparound interrupt line. */
  static const field32_t FDCANx_FDCAN_ILS_MRAFL    = {.msk = 0x00020000U, .pos = 17};   /** @brief Message RAM access failure interrupt line. */
  static const field32_t FDCANx_FDCAN_ILS_TOOL     = {.msk = 0x00040000U, .pos = 18};   /** @brief Timeout occurred interrupt line. */
  static const field32_t FDCANx_FDCAN_ILS_DRXL     = {.msk = 0x00080000U, .pos = 19};   /** @brief Message stored to dedicated rx buffer interrupt line. */
  static const field32_t FDCANx_FDCAN_ILS_BECL     = {.msk = 0x00100000U, .pos = 20};   /** @brief Bit error corrected interrupt line. */
  static const field32_t FDCANx_FDCAN_ILS_BEUL     = {.msk = 0x00200000U, .pos = 21};   /** @brief Bit error uncorrected interrupt line. */
  static const field32_t FDCANx_FDCAN_ILS_ELOL     = {.msk = 0x00400000U, .pos = 22};   /** @brief Error logging overflow interrupt line. */
  static const field32_t FDCANx_FDCAN_ILS_EPL      = {.msk = 0x00800000U, .pos = 23};   /** @brief Error passive interrupt line. */
  static const field32_t FDCANx_FDCAN_ILS_EWL      = {.msk = 0x01000000U, .pos = 24};   /** @brief Warning status interrupt line. */
  static const field32_t FDCANx_FDCAN_ILS_BOL      = {.msk = 0x02000000U, .pos = 25};   /** @brief Bus_Off status. */
  static const field32_t FDCANx_FDCAN_ILS_WDIL     = {.msk = 0x04000000U, .pos = 26};   /** @brief Watchdog interrupt line. */
  static const field32_t FDCANx_FDCAN_ILS_PEAL     = {.msk = 0x08000000U, .pos = 27};   /** @brief Protocol error in arbitration phase line. */
  static const field32_t FDCANx_FDCAN_ILS_PEDL     = {.msk = 0x10000000U, .pos = 28};   /** @brief Protocol error in data phase line. */
  static const field32_t FDCANx_FDCAN_ILS_ARAL     = {.msk = 0x20000000U, .pos = 29};   /** @brief Access to reserved address line. */
  static const field32_t FDCANx_FDCAN_GFC_RRFE     = {.msk = 0x00000001U, .pos = 0};    /** @brief Reject remote frames extended. */
  static const field32_t FDCANx_FDCAN_GFC_RRFS     = {.msk = 0x00000002U, .pos = 1};    /** @brief Reject remote frames standard. */
  static const field32_t FDCANx_FDCAN_GFC_ANFE     = {.msk = 0x0000000CU, .pos = 2};    /** @brief Accept non-matching frames extended. */
  static const field32_t FDCANx_FDCAN_GFC_ANFS     = {.msk = 0x00000030U, .pos = 4};    /** @brief Accept non-matching frames standard. */
  static const field32_t FDCANx_FDCAN_SIDFC_FLSSA  = {.msk = 0x0000FFFCU, .pos = 2};    /** @brief Filter list standard start address. */
  static const field32_t FDCANx_FDCAN_SIDFC_LSS    = {.msk = 0x00FF0000U, .pos = 16};   /** @brief List size standard. */
  static const field32_t FDCANx_FDCAN_XIDFC_FLESA  = {.msk = 0x0000FFFCU, .pos = 2};    /** @brief Filter list standard start address. */
  static const field32_t FDCANx_FDCAN_XIDFC_LSE    = {.msk = 0x00FF0000U, .pos = 16};   /** @brief List size extended. */
  static const field32_t FDCANx_FDCAN_XIDAM_EIDM   = {.msk = 0x1FFFFFFFU, .pos = 0};    /** @brief Extended ID mask. */
  static const field32_t FDCANx_FDCAN_HPMS_BIDX    = {.msk = 0x0000003FU, .pos = 0};    /** @brief Buffer index. */
  static const field32_t FDCANx_FDCAN_HPMS_MSI     = {.msk = 0x000000C0U, .pos = 6};    /** @brief Message storage indicator. */
  static const field32_t FDCANx_FDCAN_HPMS_FIDX    = {.msk = 0x00007F00U, .pos = 8};    /** @brief Filter index. */
  static const field32_t FDCANx_FDCAN_HPMS_FLST    = {.msk = 0x00008000U, .pos = 15};   /** @brief Filter list. */
  static const field32_t FDCANx_FDCAN_RXFxC_F0SA   = {.msk = 0x0000FFFCU, .pos = 2};    /** @brief Rx FIFO 0 start address. */
  static const field32_t FDCANx_FDCAN_RXFxC_F0S    = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Rx FIFO 0 size. */
  static const field32_t FDCANx_FDCAN_RXFxC_F0WM   = {.msk = 0xFF000000U, .pos = 24};   /** @brief FIFO 0 watermark. */
  static const field32_t FDCANx_FDCAN_RXFxS_F0FL   = {.msk = 0x0000007FU, .pos = 0};    /** @brief Rx FIFO 0 fill level. */
  static const field32_t FDCANx_FDCAN_RXFxS_F0G    = {.msk = 0x00003F00U, .pos = 8};    /** @brief Rx FIFO 0 get index. */
  static const field32_t FDCANx_FDCAN_RXFxS_F0P    = {.msk = 0x003F0000U, .pos = 16};   /** @brief Rx FIFO 0 put index. */
  static const field32_t FDCANx_FDCAN_RXFxS_F0F    = {.msk = 0x01000000U, .pos = 24};   /** @brief Rx FIFO 0 full. */
  static const field32_t FDCANx_FDCAN_RXFxS_RF0L   = {.msk = 0x02000000U, .pos = 25};   /** @brief Rx FIFO 0 message lost. */
  static const field32_t FDCANx_FDCAN_RXFxA_FA01   = {.msk = 0x0000003FU, .pos = 0};    /** @brief Rx FIFO 0 acknowledge index. */
  static const field32_t FDCANx_FDCAN_RXBC_RBSA    = {.msk = 0x0000FFFCU, .pos = 2};    /** @brief Rx buffer start address. */
  static const field32_t FDCANx_FDCAN_RXESC_RBDS   = {.msk = 0x00000700U, .pos = 8};    /** @brief Rx buffer data field size:. */
  static const field32_t FDCANx_FDCAN_TXBC_TBSA    = {.msk = 0x0000FFFCU, .pos = 2};    /** @brief Tx buffers start address. */
  static const field32_t FDCANx_FDCAN_TXBC_NDTB    = {.msk = 0x003F0000U, .pos = 16};   /** @brief Number of dedicated transmit buffers. */
  static const field32_t FDCANx_FDCAN_TXBC_TFQS    = {.msk = 0x3F000000U, .pos = 24};   /** @brief Transmit fifo/queue size. */
  static const field32_t FDCANx_FDCAN_TXBC_TFQM    = {.msk = 0x40000000U, .pos = 30};   /** @brief Tx fifo/queue mode. */
  static const field32_t FDCANx_FDCAN_TXFQS_TFFL   = {.msk = 0x0000003FU, .pos = 0};    /** @brief Tx FIFO free level. */
  static const field32_t FDCANx_FDCAN_TXFQS_TFGI   = {.msk = 0x00001F00U, .pos = 8};    /** @brief TFGI. */
  static const field32_t FDCANx_FDCAN_TXFQS_TFQPI  = {.msk = 0x001F0000U, .pos = 16};   /** @brief Tx fifo/queue put index. */
  static const field32_t FDCANx_FDCAN_TXFQS_TFQF   = {.msk = 0x00200000U, .pos = 21};   /** @brief Tx fifo/queue full. */
  static const field32_t FDCANx_FDCAN_TXESC_TBDS   = {.msk = 0x00000007U, .pos = 0};    /** @brief Tx buffer data field size:. */
  static const field32_t FDCANx_FDCAN_TXEFC_EFSA   = {.msk = 0x0000FFFCU, .pos = 2};    /** @brief Event FIFO start address. */
  static const field32_t FDCANx_FDCAN_TXEFC_EFS    = {.msk = 0x003F0000U, .pos = 16};   /** @brief Event FIFO size. */
  static const field32_t FDCANx_FDCAN_TXEFC_EFWM   = {.msk = 0x3F000000U, .pos = 24};   /** @brief Event FIFO watermark. */
  static const field32_t FDCANx_FDCAN_TXEFS_EFFL   = {.msk = 0x0000003FU, .pos = 0};    /** @brief Event FIFO fill level. */
  static const field32_t FDCANx_FDCAN_TXEFS_EFGI   = {.msk = 0x00001F00U, .pos = 8};    /** @brief Event FIFO get index. */
  static const field32_t FDCANx_FDCAN_TXEFS_EFF    = {.msk = 0x01000000U, .pos = 24};   /** @brief Event FIFO full. */
  static const field32_t FDCANx_FDCAN_TXEFS_TEFL   = {.msk = 0x02000000U, .pos = 25};   /** @brief Tx event FIFO element lost. */
  static const field32_t FDCANx_FDCAN_TXEFA_EFAI   = {.msk = 0x0000001FU, .pos = 0};    /** @brief Event FIFO acknowledge index. */
  static const field32_t FDCANx_FDCAN_TTTMC_TMSA   = {.msk = 0x0000FFFCU, .pos = 2};    /** @brief Trigger memory start address. */
  static const field32_t FDCANx_FDCAN_TTTMC_TME    = {.msk = 0x007F0000U, .pos = 16};   /** @brief Trigger memory elements. */
  static const field32_t FDCANx_FDCAN_TTRMC_RID    = {.msk = 0x1FFFFFFFU, .pos = 0};    /** @brief Reference identifier. */
  static const field32_t FDCANx_FDCAN_TTRMC_XTD    = {.msk = 0x40000000U, .pos = 30};   /** @brief Extended identifier. */
  static const field32_t FDCANx_FDCAN_TTRMC_RMPS   = {.msk = 0x80000000U, .pos = 31};   /** @brief Reference message payload select. */
  static const field32_t FDCANx_FDCAN_TTOCF_OM     = {.msk = 0x00000003U, .pos = 0};    /** @brief Operation mode. */
  static const field32_t FDCANx_FDCAN_TTOCF_GEN    = {.msk = 0x00000008U, .pos = 3};    /** @brief Gap enable. */
  static const field32_t FDCANx_FDCAN_TTOCF_TM     = {.msk = 0x00000010U, .pos = 4};    /** @brief Time master. */
  static const field32_t FDCANx_FDCAN_TTOCF_LDSDL  = {.msk = 0x000000E0U, .pos = 5};    /** @brief LD of synchronization deviation limit. */
  static const field32_t FDCANx_FDCAN_TTOCF_IRTO   = {.msk = 0x00007F00U, .pos = 8};    /** @brief Initial reference trigger offset. */
  static const field32_t FDCANx_FDCAN_TTOCF_EECS   = {.msk = 0x00008000U, .pos = 15};   /** @brief Enable external clock synchronization. */
  static const field32_t FDCANx_FDCAN_TTOCF_AWL    = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Application watchdog limit. */
  static const field32_t FDCANx_FDCAN_TTOCF_EGTF   = {.msk = 0x01000000U, .pos = 24};   /** @brief Enable global time filtering. */
  static const field32_t FDCANx_FDCAN_TTOCF_ECC    = {.msk = 0x02000000U, .pos = 25};   /** @brief Enable clock calibration. */
  static const field32_t FDCANx_FDCAN_TTOCF_EVTP   = {.msk = 0x04000000U, .pos = 26};   /** @brief Event trigger polarity. */
  static const field32_t FDCANx_FDCAN_TTMLM_CCM    = {.msk = 0x0000003FU, .pos = 0};    /** @brief Cycle count max. */
  static const field32_t FDCANx_FDCAN_TTMLM_CSS    = {.msk = 0x000000C0U, .pos = 6};    /** @brief Cycle start synchronization. */
  static const field32_t FDCANx_FDCAN_TTMLM_TXEW   = {.msk = 0x00000F00U, .pos = 8};    /** @brief Tx enable window. */
  static const field32_t FDCANx_FDCAN_TTMLM_ENTT   = {.msk = 0x0FFF0000U, .pos = 16};   /** @brief Expected number of tx triggers. */
  static const field32_t FDCANx_FDCAN_TURCF_NCL    = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Numerator configuration low. */
  static const field32_t FDCANx_FDCAN_TURCF_DC     = {.msk = 0x3FFF0000U, .pos = 16};   /** @brief Denominator configuration. */
  static const field32_t FDCANx_FDCAN_TURCF_ELT    = {.msk = 0x80000000U, .pos = 31};   /** @brief Enable local time. */
  static const field32_t FDCANx_FDCAN_TTOCN_SGT    = {.msk = 0x00000001U, .pos = 0};    /** @brief Set global time. */
  static const field32_t FDCANx_FDCAN_TTOCN_ECS    = {.msk = 0x00000002U, .pos = 1};    /** @brief External clock synchronization. */
  static const field32_t FDCANx_FDCAN_TTOCN_SWP    = {.msk = 0x00000004U, .pos = 2};    /** @brief Stop watch polarity. */
  static const field32_t FDCANx_FDCAN_TTOCN_SWS    = {.msk = 0x00000018U, .pos = 3};    /** @brief Stop watch source. */
  static const field32_t FDCANx_FDCAN_TTOCN_RTIE   = {.msk = 0x00000020U, .pos = 5};    /** @brief Register time mark interrupt pulse enable. */
  static const field32_t FDCANx_FDCAN_TTOCN_TMC    = {.msk = 0x000000C0U, .pos = 6};    /** @brief Register time mark compare. */
  static const field32_t FDCANx_FDCAN_TTOCN_TTIE   = {.msk = 0x00000100U, .pos = 8};    /** @brief Trigger time mark interrupt pulse enable. */
  static const field32_t FDCANx_FDCAN_TTOCN_GCS    = {.msk = 0x00000200U, .pos = 9};    /** @brief Gap control select. */
  static const field32_t FDCANx_FDCAN_TTOCN_FGP    = {.msk = 0x00000400U, .pos = 10};   /** @brief Finish gap. */
  static const field32_t FDCANx_FDCAN_TTOCN_TMG    = {.msk = 0x00000800U, .pos = 11};   /** @brief Time mark gap. */
  static const field32_t FDCANx_FDCAN_TTOCN_NIG    = {.msk = 0x00001000U, .pos = 12};   /** @brief Next is gap. */
  static const field32_t FDCANx_FDCAN_TTOCN_ESCN   = {.msk = 0x00002000U, .pos = 13};   /** @brief External synchronization control. */
  static const field32_t FDCANx_FDCAN_TTOCN_LCKC   = {.msk = 0x00008000U, .pos = 15};   /** @brief TT operation control register locked. */
  static const field32_t FDCANx_CAN_TTGTP_NCL      = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Time preset. */
  static const field32_t FDCANx_CAN_TTGTP_CTP      = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief Cycle time target phase. */
  static const field32_t FDCANx_FDCAN_TTTMK_TM     = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Time mark. */
  static const field32_t FDCANx_FDCAN_TTTMK_TICC   = {.msk = 0x007F0000U, .pos = 16};   /** @brief Time mark cycle code. */
  static const field32_t FDCANx_FDCAN_TTTMK_LCKM   = {.msk = 0x80000000U, .pos = 31};   /** @brief TT time mark register locked. */
  static const field32_t FDCANx_FDCAN_TTIR_SBC     = {.msk = 0x00000001U, .pos = 0};    /** @brief Start of basic cycle. */
  static const field32_t FDCANx_FDCAN_TTIR_SMC     = {.msk = 0x00000002U, .pos = 1};    /** @brief Start of matrix cycle. */
  static const field32_t FDCANx_FDCAN_TTIR_CSM     = {.msk = 0x00000004U, .pos = 2};    /** @brief Change of synchronization mode. */
  static const field32_t FDCANx_FDCAN_TTIR_SOG     = {.msk = 0x00000008U, .pos = 3};    /** @brief Start of gap. */
  static const field32_t FDCANx_FDCAN_TTIR_RTMI    = {.msk = 0x00000010U, .pos = 4};    /** @brief Register time mark interrupt. */
  static const field32_t FDCANx_FDCAN_TTIR_TTMI    = {.msk = 0x00000020U, .pos = 5};    /** @brief Trigger time mark event internal. */
  static const field32_t FDCANx_FDCAN_TTIR_SWE     = {.msk = 0x00000040U, .pos = 6};    /** @brief Stop watch event. */
  static const field32_t FDCANx_FDCAN_TTIR_GTW     = {.msk = 0x00000080U, .pos = 7};    /** @brief Global time wrap. */
  static const field32_t FDCANx_FDCAN_TTIR_GTD     = {.msk = 0x00000100U, .pos = 8};    /** @brief Global time discontinuity. */
  static const field32_t FDCANx_FDCAN_TTIR_GTE     = {.msk = 0x00000200U, .pos = 9};    /** @brief Global time error. */
  static const field32_t FDCANx_FDCAN_TTIR_TXU     = {.msk = 0x00000400U, .pos = 10};   /** @brief Tx count underflow. */
  static const field32_t FDCANx_FDCAN_TTIR_TXO     = {.msk = 0x00000800U, .pos = 11};   /** @brief Tx count overflow. */
  static const field32_t FDCANx_FDCAN_TTIR_ELC     = {.msk = 0x00004000U, .pos = 14};   /** @brief Error level changed. */
  static const field32_t FDCANx_FDCAN_TTIR_IWTG    = {.msk = 0x00008000U, .pos = 15};   /** @brief Initialization watch trigger. */
  static const field32_t FDCANx_FDCAN_TTIR_WT      = {.msk = 0x00010000U, .pos = 16};   /** @brief Watch trigger. */
  static const field32_t FDCANx_FDCAN_TTIR_AW      = {.msk = 0x00020000U, .pos = 17};   /** @brief Application watchdog. */
  static const field32_t FDCANx_FDCAN_TTIR_CER     = {.msk = 0x00040000U, .pos = 18};   /** @brief Configuration error. */
  static const field32_t FDCANx_FDCAN_TTIE_SBCE    = {.msk = 0x00000001U, .pos = 0};    /** @brief Start of basic cycle interrupt enable. */
  static const field32_t FDCANx_FDCAN_TTIE_SMCE    = {.msk = 0x00000002U, .pos = 1};    /** @brief Start of matrix cycle interrupt enable. */
  static const field32_t FDCANx_FDCAN_TTIE_CSME    = {.msk = 0x00000004U, .pos = 2};    /** @brief Change of synchronization mode interrupt enable. */
  static const field32_t FDCANx_FDCAN_TTIE_SOGE    = {.msk = 0x00000008U, .pos = 3};    /** @brief Start of gap interrupt enable. */
  static const field32_t FDCANx_FDCAN_TTIE_RTMIE   = {.msk = 0x00000010U, .pos = 4};    /** @brief Register time mark interrupt enable. */
  static const field32_t FDCANx_FDCAN_TTIE_TTMIE   = {.msk = 0x00000020U, .pos = 5};    /** @brief Trigger time mark event internal interrupt enable. */
  static const field32_t FDCANx_FDCAN_TTIE_SWEE    = {.msk = 0x00000040U, .pos = 6};    /** @brief Stop watch event interrupt enable. */
  static const field32_t FDCANx_FDCAN_TTIE_GTWE    = {.msk = 0x00000080U, .pos = 7};    /** @brief Global time wrap interrupt enable. */
  static const field32_t FDCANx_FDCAN_TTIE_GTDE    = {.msk = 0x00000100U, .pos = 8};    /** @brief Global time discontinuity interrupt enable. */
  static const field32_t FDCANx_FDCAN_TTIE_GTEE    = {.msk = 0x00000200U, .pos = 9};    /** @brief Global time error interrupt enable. */
  static const field32_t FDCANx_FDCAN_TTIE_TXUE    = {.msk = 0x00000400U, .pos = 10};   /** @brief Tx count underflow interrupt enable. */
  static const field32_t FDCANx_FDCAN_TTIE_TXOE    = {.msk = 0x00000800U, .pos = 11};   /** @brief Tx count overflow interrupt enable. */
  static const field32_t FDCANx_FDCAN_TTIE_ELCE    = {.msk = 0x00004000U, .pos = 14};   /** @brief Change error level interrupt enable. */
  static const field32_t FDCANx_FDCAN_TTIE_IWTGE   = {.msk = 0x00008000U, .pos = 15};   /** @brief Initialization watch trigger interrupt enable. */
  static const field32_t FDCANx_FDCAN_TTIE_WTE     = {.msk = 0x00010000U, .pos = 16};   /** @brief Watch trigger interrupt enable. */
  static const field32_t FDCANx_FDCAN_TTIE_AWE     = {.msk = 0x00020000U, .pos = 17};   /** @brief Application watchdog interrupt enable. */
  static const field32_t FDCANx_FDCAN_TTIE_CERE    = {.msk = 0x00040000U, .pos = 18};   /** @brief Configuration error interrupt enable. */
  static const field32_t FDCANx_FDCAN_TTILS_SBCL   = {.msk = 0x00000001U, .pos = 0};    /** @brief Start of basic cycle interrupt line. */
  static const field32_t FDCANx_FDCAN_TTILS_SMCL   = {.msk = 0x00000002U, .pos = 1};    /** @brief Start of matrix cycle interrupt line. */
  static const field32_t FDCANx_FDCAN_TTILS_CSML   = {.msk = 0x00000004U, .pos = 2};    /** @brief Change of synchronization mode interrupt line. */
  static const field32_t FDCANx_FDCAN_TTILS_SOGL   = {.msk = 0x00000008U, .pos = 3};    /** @brief Start of gap interrupt line. */
  static const field32_t FDCANx_FDCAN_TTILS_RTMIL  = {.msk = 0x00000010U, .pos = 4};    /** @brief Register time mark interrupt line. */
  static const field32_t FDCANx_FDCAN_TTILS_TTMIL  = {.msk = 0x00000020U, .pos = 5};    /** @brief Trigger time mark event internal interrupt line. */
  static const field32_t FDCANx_FDCAN_TTILS_SWEL   = {.msk = 0x00000040U, .pos = 6};    /** @brief Stop watch event interrupt line. */
  static const field32_t FDCANx_FDCAN_TTILS_GTWL   = {.msk = 0x00000080U, .pos = 7};    /** @brief Global time wrap interrupt line. */
  static const field32_t FDCANx_FDCAN_TTILS_GTDL   = {.msk = 0x00000100U, .pos = 8};    /** @brief Global time discontinuity interrupt line. */
  static const field32_t FDCANx_FDCAN_TTILS_GTEL   = {.msk = 0x00000200U, .pos = 9};    /** @brief Global time error interrupt line. */
  static const field32_t FDCANx_FDCAN_TTILS_TXUL   = {.msk = 0x00000400U, .pos = 10};   /** @brief Tx count underflow interrupt line. */
  static const field32_t FDCANx_FDCAN_TTILS_TXOL   = {.msk = 0x00000800U, .pos = 11};   /** @brief Tx count overflow interrupt line. */
  static const field32_t FDCANx_FDCAN_TTILS_ELCL   = {.msk = 0x00004000U, .pos = 14};   /** @brief Change error level interrupt line. */
  static const field32_t FDCANx_FDCAN_TTILS_IWTGL  = {.msk = 0x00008000U, .pos = 15};   /** @brief Initialization watch trigger interrupt line. */
  static const field32_t FDCANx_FDCAN_TTILS_WTL    = {.msk = 0x00010000U, .pos = 16};   /** @brief Watch trigger interrupt line. */
  static const field32_t FDCANx_FDCAN_TTILS_AWL    = {.msk = 0x00020000U, .pos = 17};   /** @brief Application watchdog interrupt line. */
  static const field32_t FDCANx_FDCAN_TTILS_CERL   = {.msk = 0x00040000U, .pos = 18};   /** @brief Configuration error interrupt line. */
  static const field32_t FDCANx_FDCAN_TTOST_EL     = {.msk = 0x00000003U, .pos = 0};    /** @brief Error level. */
  static const field32_t FDCANx_FDCAN_TTOST_MS     = {.msk = 0x0000000CU, .pos = 2};    /** @brief Master state. */
  static const field32_t FDCANx_FDCAN_TTOST_SYS    = {.msk = 0x00000030U, .pos = 4};    /** @brief Synchronization state. */
  static const field32_t FDCANx_FDCAN_TTOST_GTP    = {.msk = 0x00000040U, .pos = 6};    /** @brief Quality of global time phase. */
  static const field32_t FDCANx_FDCAN_TTOST_QCS    = {.msk = 0x00000080U, .pos = 7};    /** @brief Quality of clock speed. */
  static const field32_t FDCANx_FDCAN_TTOST_RTO    = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Reference trigger offset. */
  static const field32_t FDCANx_FDCAN_TTOST_WGTD   = {.msk = 0x00400000U, .pos = 22};   /** @brief Wait for global time discontinuity. */
  static const field32_t FDCANx_FDCAN_TTOST_GFI    = {.msk = 0x00800000U, .pos = 23};   /** @brief Gap finished indicator. */
  static const field32_t FDCANx_FDCAN_TTOST_TMP    = {.msk = 0x07000000U, .pos = 24};   /** @brief Time master priority. */
  static const field32_t FDCANx_FDCAN_TTOST_GSI    = {.msk = 0x08000000U, .pos = 27};   /** @brief Gap started indicator. */
  static const field32_t FDCANx_FDCAN_TTOST_WFE    = {.msk = 0x10000000U, .pos = 28};   /** @brief Wait for event. */
  static const field32_t FDCANx_FDCAN_TTOST_AWE    = {.msk = 0x20000000U, .pos = 29};   /** @brief Application watchdog event. */
  static const field32_t FDCANx_FDCAN_TTOST_WECS   = {.msk = 0x40000000U, .pos = 30};   /** @brief Wait for external clock synchronization. */
  static const field32_t FDCANx_FDCAN_TTOST_SPL    = {.msk = 0x80000000U, .pos = 31};   /** @brief Schedule phase lock. */
  static const field32_t FDCANx_FDCAN_TURNA_NAV    = {.msk = 0x0003FFFFU, .pos = 0};    /** @brief Numerator actual value. */
  static const field32_t FDCANx_FDCAN_TTLGT_LT     = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Local time. */
  static const field32_t FDCANx_FDCAN_TTLGT_GT     = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief Global time. */
  static const field32_t FDCANx_FDCAN_TTCTC_CT     = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Cycle time. */
  static const field32_t FDCANx_FDCAN_TTCTC_CC     = {.msk = 0x003F0000U, .pos = 16};   /** @brief Cycle count. */
  static const field32_t FDCANx_FDCAN_TTCPT_CT     = {.msk = 0x0000003FU, .pos = 0};    /** @brief Cycle count value. */
  static const field32_t FDCANx_FDCAN_TTCPT_SWV    = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief Stop watch value. */
  static const field32_t FDCANx_FDCAN_TTCSM_CSM    = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Cycle sync mark. */
  static const field32_t FDCANx_FDCAN_TTTS_SWTDEL  = {.msk = 0x00000003U, .pos = 0};    /** @brief Stop watch trigger input selection. */
  static const field32_t FDCANx_FDCAN_TTTS_EVTSEL  = {.msk = 0x00000030U, .pos = 4};    /** @brief Event trigger input selection. */

  /**** Enumerated FDCANx Register Field Definitions ****/

  static field32_t const FDCANx_FDCAN_DBTP_DTSEGx[3] = {
    [1] = {.msk = 0x00001F00U, .pos = 8},   /** @brief Data time segment after sample point. */
    [2] = {.msk = 0x000000F0U, .pos = 4},   /** @brief Data time segment after sample point. */
  };

  static field32_t const FDCANx_FDCAN_IR_RFxN[2] = {
    [0] = {.msk = 0x00000001U, .pos = 0},   /** @brief Rx FIFO 0 new message. */
    [1] = {.msk = 0x00000010U, .pos = 4},   /** @brief Rx FIFO 1 new message. */
  };

  static field32_t const FDCANx_FDCAN_IR_RFxW[2] = {
    [0] = {.msk = 0x00000002U, .pos = 1},   /** @brief Rx FIFO 0 full. */
    [1] = {.msk = 0x00000020U, .pos = 5},   /** @brief Rx FIFO 1 watermark reached. */
  };

  static field32_t const FDCANx_FDCAN_IR_RFxF[2] = {
    [0] = {.msk = 0x00000004U, .pos = 2},   /** @brief Rx FIFO 0 full. */
    [1] = {.msk = 0x00000040U, .pos = 6},   /** @brief Rx FIFO 1 watermark reached. */
  };

  static field32_t const FDCANx_FDCAN_IR_RFxL[2] = {
    [0] = {.msk = 0x00000008U, .pos = 3},   /** @brief Rx FIFO 0 message lost. */
    [1] = {.msk = 0x00000080U, .pos = 7},   /** @brief Rx FIFO 1 message lost. */
  };

  static field32_t const FDCANx_FDCAN_IE_RFxNE[2] = {
    [0] = {.msk = 0x00000001U, .pos = 0},   /** @brief Rx FIFO 0 new message enable. */
    [1] = {.msk = 0x00000010U, .pos = 4},   /** @brief Rx FIFO 1 new message enable. */
  };

  static field32_t const FDCANx_FDCAN_IE_RFxWE[2] = {
    [0] = {.msk = 0x00000002U, .pos = 1},   /** @brief Rx FIFO 0 full enable. */
    [1] = {.msk = 0x00000020U, .pos = 5},   /** @brief Rx FIFO 1 watermark reached enable. */
  };

  static field32_t const FDCANx_FDCAN_IE_RFxFE[2] = {
    [0] = {.msk = 0x00000004U, .pos = 2},   /** @brief Rx FIFO 0 full enable. */
    [1] = {.msk = 0x00000040U, .pos = 6},   /** @brief Rx FIFO 1 watermark reached enable. */
  };

  static field32_t const FDCANx_FDCAN_IE_RFxLE[2] = {
    [0] = {.msk = 0x00000008U, .pos = 3},   /** @brief Rx FIFO 0 message lost enable. */
    [1] = {.msk = 0x00000080U, .pos = 7},   /** @brief Rx FIFO 1 message lost enable. */
  };

  static field32_t const FDCANx_FDCAN_ILS_RFxNL[2] = {
    [0] = {.msk = 0x00000001U, .pos = 0},   /** @brief Rx FIFO 0 new message interrupt line. */
    [1] = {.msk = 0x00000010U, .pos = 4},   /** @brief Rx FIFO 1 new message interrupt line. */
  };

  static field32_t const FDCANx_FDCAN_ILS_RFxWL[2] = {
    [0] = {.msk = 0x00000002U, .pos = 1},   /** @brief Rx FIFO 0 watermark reached interrupt line. */
    [1] = {.msk = 0x00000020U, .pos = 5},   /** @brief Rx FIFO 1 watermark reached interrupt line. */
  };

  static field32_t const FDCANx_FDCAN_ILS_RFxFL[2] = {
    [0] = {.msk = 0x00000004U, .pos = 2},   /** @brief Rx FIFO 0 full interrupt line. */
    [1] = {.msk = 0x00000040U, .pos = 6},   /** @brief Rx FIFO 1 full interrupt line. */
  };

  static field32_t const FDCANx_FDCAN_ILS_RFxLL[2] = {
    [0] = {.msk = 0x00000008U, .pos = 3},   /** @brief Rx FIFO 0 message lost interrupt line. */
    [1] = {.msk = 0x00000080U, .pos = 7},   /** @brief Rx FIFO 1 message lost interrupt line. */
  };

  static field32_t const FDCANx_FDCAN_ILE_EINTx[2] = {
    [0] = {.msk = 0x00000001U, .pos = 0},   /** @brief Enable interrupt line 0. */
    [1] = {.msk = 0x00000002U, .pos = 1},   /** @brief Enable interrupt line 1. */
  };

  static field32_t const FDCANx_FDCAN_NDATx_NDx[32] = {
    [0]  = {.msk = 0x00000001U, .pos = 0},    /** @brief New data. */
    [1]  = {.msk = 0x00000002U, .pos = 1},    /** @brief New data. */
    [2]  = {.msk = 0x00000004U, .pos = 2},    /** @brief New data. */
    [3]  = {.msk = 0x00000008U, .pos = 3},    /** @brief New data. */
    [4]  = {.msk = 0x00000010U, .pos = 4},    /** @brief New data. */
    [5]  = {.msk = 0x00000020U, .pos = 5},    /** @brief New data. */
    [6]  = {.msk = 0x00000040U, .pos = 6},    /** @brief New data. */
    [7]  = {.msk = 0x00000080U, .pos = 7},    /** @brief New data. */
    [8]  = {.msk = 0x00000100U, .pos = 8},    /** @brief New data. */
    [9]  = {.msk = 0x00000200U, .pos = 9},    /** @brief New data. */
    [10] = {.msk = 0x00000400U, .pos = 10},   /** @brief New data. */
    [11] = {.msk = 0x00000800U, .pos = 11},   /** @brief New data. */
    [12] = {.msk = 0x00001000U, .pos = 12},   /** @brief New data. */
    [13] = {.msk = 0x00002000U, .pos = 13},   /** @brief New data. */
    [14] = {.msk = 0x00004000U, .pos = 14},   /** @brief New data. */
    [15] = {.msk = 0x00008000U, .pos = 15},   /** @brief New data. */
    [16] = {.msk = 0x00010000U, .pos = 16},   /** @brief New data. */
    [17] = {.msk = 0x00020000U, .pos = 17},   /** @brief New data. */
    [18] = {.msk = 0x00040000U, .pos = 18},   /** @brief New data. */
    [19] = {.msk = 0x00080000U, .pos = 19},   /** @brief New data. */
    [20] = {.msk = 0x00100000U, .pos = 20},   /** @brief New data. */
    [21] = {.msk = 0x00200000U, .pos = 21},   /** @brief New data. */
    [22] = {.msk = 0x00400000U, .pos = 22},   /** @brief New data. */
    [23] = {.msk = 0x00800000U, .pos = 23},   /** @brief New data. */
    [24] = {.msk = 0x01000000U, .pos = 24},   /** @brief New data. */
    [25] = {.msk = 0x02000000U, .pos = 25},   /** @brief New data. */
    [26] = {.msk = 0x04000000U, .pos = 26},   /** @brief New data. */
    [27] = {.msk = 0x08000000U, .pos = 27},   /** @brief New data. */
    [28] = {.msk = 0x10000000U, .pos = 28},   /** @brief New data. */
    [29] = {.msk = 0x20000000U, .pos = 29},   /** @brief New data. */
    [30] = {.msk = 0x40000000U, .pos = 30},   /** @brief New data. */
    [31] = {.msk = 0x80000000U, .pos = 31},   /** @brief New data. */
  };

  static field32_t const FDCANx_FDCAN_RXESC_FxDS[2] = {
    [0] = {.msk = 0x00000007U, .pos = 0},   /** @brief Rx FIFO 1 data field size:. */
    [1] = {.msk = 0x00000070U, .pos = 4},   /** @brief Rx FIFO 0 data field size:. */
  };

  static field32_t const FDCANx_FDCAN_TTIR_SEx[3] = {
    [1] = {.msk = 0x00001000U, .pos = 12},   /** @brief Scheduling error 1. */
    [2] = {.msk = 0x00002000U, .pos = 13},   /** @brief Scheduling error 2. */
  };

  static field32_t const FDCANx_FDCAN_TTIE_SExE[3] = {
    [1] = {.msk = 0x00001000U, .pos = 12},   /** @brief Scheduling error 1 interrupt enable. */
    [2] = {.msk = 0x00002000U, .pos = 13},   /** @brief Scheduling error 2 interrupt enable. */
  };

  static field32_t const FDCANx_FDCAN_TTILS_SExL[3] = {
    [1] = {.msk = 0x00001000U, .pos = 12},   /** @brief Scheduling error 1 interrupt line. */
    [2] = {.msk = 0x00002000U, .pos = 13},   /** @brief Scheduling error 2 interrupt line. */
  };

  /************************************************************************************************
   * CAN_CCU Definitions
   ************************************************************************************************/

  /**** CAN_CCU Register Definitions ****/

  static const rw_reg32_t CAN_CCU_CREL  = (rw_reg32_t)0x4000A800U;   /** @brief Clock calibration unit core release register. */
  static const rw_reg32_t CAN_CCU_CCFG  = (rw_reg32_t)0x4000A804U;   /** @brief Calibration configuration register. */
  static const rw_reg32_t CAN_CCU_CSTAT = (rw_reg32_t)0x4000A808U;   /** @brief Calibration status register. */
  static const rw_reg32_t CAN_CCU_CWD   = (rw_reg32_t)0x4000A80CU;   /** @brief Calibration watchdog register. */
  static const rw_reg32_t CAN_CCU_IR    = (rw_reg32_t)0x4000A810U;   /** @brief Clock calibration unit interrupt register. */
  static const rw_reg32_t CAN_CCU_IE    = (rw_reg32_t)0x4000A814U;   /** @brief Clock calibration unit interrupt enable register. */

  /**** CAN_CCU Register Field Definitions ****/

  static const field32_t CAN_CCU_CREL_DAY     = {.msk = 0x000000FFU, .pos = 0};    /** @brief Time stamp day. */
  static const field32_t CAN_CCU_CREL_MON     = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Time stamp month. */
  static const field32_t CAN_CCU_CREL_YEAR    = {.msk = 0x000F0000U, .pos = 16};   /** @brief Time stamp year. */
  static const field32_t CAN_CCU_CREL_SUBSTEP = {.msk = 0x00F00000U, .pos = 20};   /** @brief Sub-step of core release. */
  static const field32_t CAN_CCU_CREL_STEP    = {.msk = 0x0F000000U, .pos = 24};   /** @brief Step of core release. */
  static const field32_t CAN_CCU_CREL_REL     = {.msk = 0xF0000000U, .pos = 28};   /** @brief Core release. */
  static const field32_t CAN_CCU_CCFG_TQBT    = {.msk = 0x0000001FU, .pos = 0};    /** @brief Time quanta per bit time. */
  static const field32_t CAN_CCU_CCFG_BCC     = {.msk = 0x00000040U, .pos = 6};    /** @brief Bypass clock calibration. */
  static const field32_t CAN_CCU_CCFG_CFL     = {.msk = 0x00000080U, .pos = 7};    /** @brief Calibration field length. */
  static const field32_t CAN_CCU_CCFG_OCPM    = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Oscillator clock periods minimum. */
  static const field32_t CAN_CCU_CCFG_CDIV    = {.msk = 0x000F0000U, .pos = 16};   /** @brief Clock divider. */
  static const field32_t CAN_CCU_CCFG_SWR     = {.msk = 0x80000000U, .pos = 31};   /** @brief Software reset. */
  static const field32_t CAN_CCU_CSTAT_OCPC   = {.msk = 0x0003FFFFU, .pos = 0};    /** @brief Oscillator clock period counter. */
  static const field32_t CAN_CCU_CSTAT_TQC    = {.msk = 0x1FFC0000U, .pos = 18};   /** @brief Time quanta counter. */
  static const field32_t CAN_CCU_CSTAT_CALS   = {.msk = 0xC0000000U, .pos = 30};   /** @brief Calibration state. */
  static const field32_t CAN_CCU_CWD_WDC      = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief WDC. */
  static const field32_t CAN_CCU_CWD_WDV      = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief WDV. */
  static const field32_t CAN_CCU_IR_CWE       = {.msk = 0x00000001U, .pos = 0};    /** @brief Calibration watchdog event. */
  static const field32_t CAN_CCU_IR_CSC       = {.msk = 0x00000002U, .pos = 1};    /** @brief Calibration state changed. */
  static const field32_t CAN_CCU_IE_CWEE      = {.msk = 0x00000001U, .pos = 0};    /** @brief Calibration watchdog event enable. */
  static const field32_t CAN_CCU_IE_CSCE      = {.msk = 0x00000002U, .pos = 1};    /** @brief Calibration state changed enable. */

  /************************************************************************************************
   * MDIOS Definitions
   ************************************************************************************************/

  /**** MDIOS Register Definitions ****/

  static const rw_reg32_t MDIOS_MDIOS_CR    = (rw_reg32_t)0x40009400U;   /** @brief MDIOS configuration register. */
  static const ro_reg32_t MDIOS_MDIOS_WRFR  = (ro_reg32_t)0x40009404U;   /** @brief MDIOS write flag register. */
  static const rw_reg32_t MDIOS_MDIOS_CWRFR = (rw_reg32_t)0x40009408U;   /** @brief MDIOS clear write flag register. */
  static const ro_reg32_t MDIOS_MDIOS_RDFR  = (ro_reg32_t)0x4000940CU;   /** @brief MDIOS read flag register. */
  static const rw_reg32_t MDIOS_MDIOS_CRDFR = (rw_reg32_t)0x40009410U;   /** @brief MDIOS clear read flag register. */
  static const ro_reg32_t MDIOS_MDIOS_SR    = (ro_reg32_t)0x40009414U;   /** @brief MDIOS status register. */
  static const rw_reg32_t MDIOS_MDIOS_CLRFR = (rw_reg32_t)0x40009418U;   /** @brief MDIOS clear flag register. */

  /**** Enumerated MDIOS Register Definitions ****/

  static const ro_reg32_t MDIOS_MDIOS_DINRx[32] = {
    [0]  = (ro_reg32_t)0x4000941CU,   /** @brief MDIOS input data register 0. */
    [1]  = (ro_reg32_t)0x40009420U,   /** @brief MDIOS input data register 1. */
    [2]  = (ro_reg32_t)0x40009424U,   /** @brief MDIOS input data register 2. */
    [3]  = (ro_reg32_t)0x40009428U,   /** @brief MDIOS input data register 3. */
    [4]  = (ro_reg32_t)0x4000942CU,   /** @brief MDIOS input data register 4. */
    [5]  = (ro_reg32_t)0x40009430U,   /** @brief MDIOS input data register 5. */
    [6]  = (ro_reg32_t)0x40009434U,   /** @brief MDIOS input data register 6. */
    [7]  = (ro_reg32_t)0x40009438U,   /** @brief MDIOS input data register 7. */
    [8]  = (ro_reg32_t)0x4000943CU,   /** @brief MDIOS input data register 8. */
    [9]  = (ro_reg32_t)0x40009440U,   /** @brief MDIOS input data register 9. */
    [10] = (ro_reg32_t)0x40009444U,   /** @brief MDIOS input data register 10. */
    [11] = (ro_reg32_t)0x40009448U,   /** @brief MDIOS input data register 11. */
    [12] = (ro_reg32_t)0x4000944CU,   /** @brief MDIOS input data register 12. */
    [13] = (ro_reg32_t)0x40009450U,   /** @brief MDIOS input data register 13. */
    [14] = (ro_reg32_t)0x40009454U,   /** @brief MDIOS input data register 14. */
    [15] = (ro_reg32_t)0x40009458U,   /** @brief MDIOS input data register 15. */
    [16] = (ro_reg32_t)0x4000945CU,   /** @brief MDIOS input data register 16. */
    [17] = (ro_reg32_t)0x40009460U,   /** @brief MDIOS input data register 17. */
    [18] = (ro_reg32_t)0x40009464U,   /** @brief MDIOS input data register 18. */
    [19] = (ro_reg32_t)0x40009468U,   /** @brief MDIOS input data register 19. */
    [20] = (ro_reg32_t)0x4000946CU,   /** @brief MDIOS input data register 20. */
    [21] = (ro_reg32_t)0x40009470U,   /** @brief MDIOS input data register 21. */
    [22] = (ro_reg32_t)0x40009474U,   /** @brief MDIOS input data register 22. */
    [23] = (ro_reg32_t)0x40009478U,   /** @brief MDIOS input data register 23. */
    [24] = (ro_reg32_t)0x4000947CU,   /** @brief MDIOS input data register 24. */
    [25] = (ro_reg32_t)0x40009480U,   /** @brief MDIOS input data register 25. */
    [26] = (ro_reg32_t)0x40009484U,   /** @brief MDIOS input data register 26. */
    [27] = (ro_reg32_t)0x40009488U,   /** @brief MDIOS input data register 27. */
    [28] = (ro_reg32_t)0x4000948CU,   /** @brief MDIOS input data register 28. */
    [29] = (ro_reg32_t)0x40009490U,   /** @brief MDIOS input data register 29. */
    [30] = (ro_reg32_t)0x40009494U,   /** @brief MDIOS input data register 30. */
    [31] = (ro_reg32_t)0x40009498U,   /** @brief MDIOS input data register 31. */
  };

  static const rw_reg32_t MDIOS_MDIOS_DOUTRx[32] = {
    [0]  = (rw_reg32_t)0x4000949CU,   /** @brief MDIOS output data register 0. */
    [1]  = (rw_reg32_t)0x400094A0U,   /** @brief MDIOS output data register 1. */
    [2]  = (rw_reg32_t)0x400094A4U,   /** @brief MDIOS output data register 2. */
    [3]  = (rw_reg32_t)0x400094A8U,   /** @brief MDIOS output data register 3. */
    [4]  = (rw_reg32_t)0x400094ACU,   /** @brief MDIOS output data register 4. */
    [5]  = (rw_reg32_t)0x400094B0U,   /** @brief MDIOS output data register 5. */
    [6]  = (rw_reg32_t)0x400094B4U,   /** @brief MDIOS output data register 6. */
    [7]  = (rw_reg32_t)0x400094B8U,   /** @brief MDIOS output data register 7. */
    [8]  = (rw_reg32_t)0x400094BCU,   /** @brief MDIOS output data register 8. */
    [9]  = (rw_reg32_t)0x400094C0U,   /** @brief MDIOS output data register 9. */
    [10] = (rw_reg32_t)0x400094C4U,   /** @brief MDIOS output data register 10. */
    [11] = (rw_reg32_t)0x400094C8U,   /** @brief MDIOS output data register 11. */
    [12] = (rw_reg32_t)0x400094CCU,   /** @brief MDIOS output data register 12. */
    [13] = (rw_reg32_t)0x400094D0U,   /** @brief MDIOS output data register 13. */
    [14] = (rw_reg32_t)0x400094D4U,   /** @brief MDIOS output data register 14. */
    [15] = (rw_reg32_t)0x400094D8U,   /** @brief MDIOS output data register 15. */
    [16] = (rw_reg32_t)0x400094DCU,   /** @brief MDIOS output data register 16. */
    [17] = (rw_reg32_t)0x400094E0U,   /** @brief MDIOS output data register 17. */
    [18] = (rw_reg32_t)0x400094E4U,   /** @brief MDIOS output data register 18. */
    [19] = (rw_reg32_t)0x400094E8U,   /** @brief MDIOS output data register 19. */
    [20] = (rw_reg32_t)0x400094ECU,   /** @brief MDIOS output data register 20. */
    [21] = (rw_reg32_t)0x400094F0U,   /** @brief MDIOS output data register 21. */
    [22] = (rw_reg32_t)0x400094F4U,   /** @brief MDIOS output data register 22. */
    [23] = (rw_reg32_t)0x400094F8U,   /** @brief MDIOS output data register 23. */
    [24] = (rw_reg32_t)0x400094FCU,   /** @brief MDIOS output data register 24. */
    [25] = (rw_reg32_t)0x40009500U,   /** @brief MDIOS output data register 25. */
    [26] = (rw_reg32_t)0x40009504U,   /** @brief MDIOS output data register 26. */
    [27] = (rw_reg32_t)0x40009508U,   /** @brief MDIOS output data register 27. */
    [28] = (rw_reg32_t)0x4000950CU,   /** @brief MDIOS output data register 28. */
    [29] = (rw_reg32_t)0x40009510U,   /** @brief MDIOS output data register 29. */
    [30] = (rw_reg32_t)0x40009514U,   /** @brief MDIOS output data register 30. */
    [31] = (rw_reg32_t)0x40009518U,   /** @brief MDIOS output data register 31. */
  };

  /**** MDIOS Register Field Definitions ****/

  static const field32_t MDIOS_MDIOS_CR_EN           = {.msk = 0x00000001U, .pos = 0};   /** @brief Peripheral enable. */
  static const field32_t MDIOS_MDIOS_CR_WRIE         = {.msk = 0x00000002U, .pos = 1};   /** @brief Register write interrupt enable. */
  static const field32_t MDIOS_MDIOS_CR_RDIE         = {.msk = 0x00000004U, .pos = 2};   /** @brief Register read interrupt enable. */
  static const field32_t MDIOS_MDIOS_CR_EIE          = {.msk = 0x00000008U, .pos = 3};   /** @brief Error interrupt enable. */
  static const field32_t MDIOS_MDIOS_CR_DPC          = {.msk = 0x00000080U, .pos = 7};   /** @brief Disable preamble check. */
  static const field32_t MDIOS_MDIOS_CR_PORT_ADDRESS = {.msk = 0x00001F00U, .pos = 8};   /** @brief Slaves's address. */
  static const field32_t MDIOS_MDIOS_SR_PERF         = {.msk = 0x00000001U, .pos = 0};   /** @brief Preamble error flag. */
  static const field32_t MDIOS_MDIOS_SR_SERF         = {.msk = 0x00000002U, .pos = 1};   /** @brief Start error flag. */
  static const field32_t MDIOS_MDIOS_SR_TERF         = {.msk = 0x00000004U, .pos = 2};   /** @brief Turnaround error flag. */
  static const field32_t MDIOS_MDIOS_CLRFR_CPERF     = {.msk = 0x00000001U, .pos = 0};   /** @brief Clear the preamble error flag. */
  static const field32_t MDIOS_MDIOS_CLRFR_CSERF     = {.msk = 0x00000002U, .pos = 1};   /** @brief Clear the start error flag. */
  static const field32_t MDIOS_MDIOS_CLRFR_CTERF     = {.msk = 0x00000004U, .pos = 2};   /** @brief Clear the turnaround error flag. */
  static const field32_t MDIOS_MDIOS_DINRx_DIN0      = {.msk = 0x0000FFFFU, .pos = 0};   /** @brief Input data received from MDIO master during write frames. */
  static const field32_t MDIOS_MDIOS_DOUTRx_DOUT0    = {.msk = 0x0000FFFFU, .pos = 0};   /** @brief Output data sent to MDIO master during read frames. */

  /************************************************************************************************
   * OPAMP Definitions
   ************************************************************************************************/

  /**** Enumerated OPAMP Register Definitions ****/

  static const rw_reg32_t OPAMP_OPAMPx_CSR[3] = {
    [1] = (rw_reg32_t)0x40009000U,   /** @brief OPAMP1 control/status register. */
    [2] = (rw_reg32_t)0x40009010U,   /** @brief OPAMP2 control/status register. */
  };

  static const rw_reg32_t OPAMP_OPAMPx_OTR[3] = {
    [1] = (rw_reg32_t)0x40009004U,   /** @brief OPAMP1 offset trimming register in normal mode. */
    [2] = (rw_reg32_t)0x40009014U,   /** @brief OPAMP2 offset trimming register in normal mode. */
  };

  static const rw_reg32_t OPAMP_OPAMPx_HSOTR[3] = {
    [1] = (rw_reg32_t)0x40009008U,   /** @brief OPAMP1 offset trimming register in low-power mode. */
    [2] = (rw_reg32_t)0x40009018U,   /** @brief OPAMP2 offset trimming register in low-power mode. */
  };

  /**** OPAMP Register Field Definitions ****/

  static const field32_t OPAMP_OPAMPx_CSR_OPAEN           = {.msk = 0x00000001U, .pos = 0};    /** @brief Operational amplifier enable. */
  static const field32_t OPAMP_OPAMPx_CSR_FORCE_VP        = {.msk = 0x00000002U, .pos = 1};    /** @brief Force internal reference on VP (reserved for test. */
  static const field32_t OPAMP_OPAMPx_CSR_VP_SEL          = {.msk = 0x0000000CU, .pos = 2};    /** @brief Operational amplifier PGA mode. */
  static const field32_t OPAMP_OPAMPx_CSR_VM_SEL          = {.msk = 0x00000060U, .pos = 5};    /** @brief Inverting input selection. */
  static const field32_t OPAMP_OPAMPx_CSR_OPAHSM          = {.msk = 0x00000100U, .pos = 8};    /** @brief Operational amplifier high-speed mode. */
  static const field32_t OPAMP_OPAMPx_CSR_CALON           = {.msk = 0x00000800U, .pos = 11};   /** @brief Calibration mode enabled. */
  static const field32_t OPAMP_OPAMPx_CSR_CALSEL          = {.msk = 0x00003000U, .pos = 12};   /** @brief Calibration selection. */
  static const field32_t OPAMP_OPAMPx_CSR_PGA_GAIN        = {.msk = 0x0003C000U, .pos = 14};   /** @brief Allows to switch from AOP offset trimmed values to AOP offset. */
  static const field32_t OPAMP_OPAMPx_CSR_USERTRIM        = {.msk = 0x00040000U, .pos = 18};   /** @brief User trimming enable. */
  static const field32_t OPAMP_OPAMPx_CSR_TSTREF          = {.msk = 0x20000000U, .pos = 29};   /** @brief OPAMP calibration reference voltage output control (reserved for test). */
  static const field32_t OPAMP_OPAMPx_CSR_CALOUT          = {.msk = 0x40000000U, .pos = 30};   /** @brief Operational amplifier calibration output. */
  static const field32_t OPAMP_OPAMPx_OTR_TRIMOFFSETN     = {.msk = 0x0000001FU, .pos = 0};    /** @brief Trim for NMOS differential pairs. */
  static const field32_t OPAMP_OPAMPx_OTR_TRIMOFFSETP     = {.msk = 0x00001F00U, .pos = 8};    /** @brief Trim for PMOS differential pairs. */
  static const field32_t OPAMP_OPAMPx_HSOTR_TRIMLPOFFSETN = {.msk = 0x0000001FU, .pos = 0};    /** @brief Trim for NMOS differential pairs. */
  static const field32_t OPAMP_OPAMPx_HSOTR_TRIMLPOFFSETP = {.msk = 0x00001F00U, .pos = 8};    /** @brief Trim for PMOS differential pairs. */

  /************************************************************************************************
   * SWPMI Definitions
   ************************************************************************************************/

  /**** SWPMI Register Definitions ****/

  static const rw_reg32_t SWPMI_CR  = (rw_reg32_t)0x40008800U;   /** @brief SWPMI configuration/control register. */
  static const rw_reg32_t SWPMI_BRR = (rw_reg32_t)0x40008804U;   /** @brief SWPMI bitrate register. */
  static const ro_reg32_t SWPMI_ISR = (ro_reg32_t)0x4000880CU;   /** @brief SWPMI interrupt and status register. */
  static const rw_reg32_t SWPMI_ICR = (rw_reg32_t)0x40008810U;   /** @brief SWPMI interrupt flag clear register. */
  static const rw_reg32_t SWPMI_IER = (rw_reg32_t)0x40008814U;   /** @brief SWPMI interrupt enable register. */
  static const ro_reg32_t SWPMI_RFL = (ro_reg32_t)0x40008818U;   /** @brief SWPMI receive frame length register. */
  static const rw_reg32_t SWPMI_TDR = (rw_reg32_t)0x4000881CU;   /** @brief SWPMI transmit data register. */
  static const ro_reg32_t SWPMI_RDR = (ro_reg32_t)0x40008820U;   /** @brief SWPMI receive data register. */
  static const rw_reg32_t SWPMI_OR  = (rw_reg32_t)0x40008824U;   /** @brief SWPMI option register. */

  /**** SWPMI Register Field Definitions ****/

  static const field32_t SWPMI_CR_RXDMA     = {.msk = 0x00000001U, .pos = 0};    /** @brief Reception DMA enable. */
  static const field32_t SWPMI_CR_TXDMA     = {.msk = 0x00000002U, .pos = 1};    /** @brief Transmission DMA enable. */
  static const field32_t SWPMI_CR_RXMODE    = {.msk = 0x00000004U, .pos = 2};    /** @brief Reception buffering mode. */
  static const field32_t SWPMI_CR_TXMODE    = {.msk = 0x00000008U, .pos = 3};    /** @brief Transmission buffering mode. */
  static const field32_t SWPMI_CR_LPBK      = {.msk = 0x00000010U, .pos = 4};    /** @brief Loopback mode enable. */
  static const field32_t SWPMI_CR_SWPACT    = {.msk = 0x00000020U, .pos = 5};    /** @brief Single wire protocol master interface activate. */
  static const field32_t SWPMI_CR_DEACT     = {.msk = 0x00000400U, .pos = 10};   /** @brief Single wire protocol master interface deactivate. */
  static const field32_t SWPMI_CR_SWPTEN    = {.msk = 0x00000800U, .pos = 11};   /** @brief Single wire protocol master transceiver enable. */
  static const field32_t SWPMI_BRR_BR       = {.msk = 0x000000FFU, .pos = 0};    /** @brief Bitrate prescaler. */
  static const field32_t SWPMI_ISR_RXBFF    = {.msk = 0x00000001U, .pos = 0};    /** @brief Receive buffer full flag. */
  static const field32_t SWPMI_ISR_TXBEF    = {.msk = 0x00000002U, .pos = 1};    /** @brief Transmit buffer empty flag. */
  static const field32_t SWPMI_ISR_RXBERF   = {.msk = 0x00000004U, .pos = 2};    /** @brief Receive CRC error flag. */
  static const field32_t SWPMI_ISR_RXOVRF   = {.msk = 0x00000008U, .pos = 3};    /** @brief Receive overrun error flag. */
  static const field32_t SWPMI_ISR_TXUNRF   = {.msk = 0x00000010U, .pos = 4};    /** @brief Transmit underrun error flag. */
  static const field32_t SWPMI_ISR_RXNE     = {.msk = 0x00000020U, .pos = 5};    /** @brief Receive data register not empty. */
  static const field32_t SWPMI_ISR_TXE      = {.msk = 0x00000040U, .pos = 6};    /** @brief Transmit data register empty. */
  static const field32_t SWPMI_ISR_TCF      = {.msk = 0x00000080U, .pos = 7};    /** @brief Transfer complete flag. */
  static const field32_t SWPMI_ISR_SRF      = {.msk = 0x00000100U, .pos = 8};    /** @brief Slave resume flag. */
  static const field32_t SWPMI_ISR_SUSP     = {.msk = 0x00000200U, .pos = 9};    /** @brief SUSPEND flag. */
  static const field32_t SWPMI_ISR_DEACTF   = {.msk = 0x00000400U, .pos = 10};   /** @brief DEACTIVATED flag. */
  static const field32_t SWPMI_ISR_RDYF     = {.msk = 0x00000800U, .pos = 11};   /** @brief Transceiver ready flag. */
  static const field32_t SWPMI_ICR_CRXBFF   = {.msk = 0x00000001U, .pos = 0};    /** @brief Clear receive buffer full flag. */
  static const field32_t SWPMI_ICR_CTXBEF   = {.msk = 0x00000002U, .pos = 1};    /** @brief Clear transmit buffer empty flag. */
  static const field32_t SWPMI_ICR_CRXBERF  = {.msk = 0x00000004U, .pos = 2};    /** @brief Clear receive CRC error flag. */
  static const field32_t SWPMI_ICR_CRXOVRF  = {.msk = 0x00000008U, .pos = 3};    /** @brief Clear receive overrun error flag. */
  static const field32_t SWPMI_ICR_CTXUNRF  = {.msk = 0x00000010U, .pos = 4};    /** @brief Clear transmit underrun error flag. */
  static const field32_t SWPMI_ICR_CTCF     = {.msk = 0x00000080U, .pos = 7};    /** @brief Clear transfer complete flag. */
  static const field32_t SWPMI_ICR_CSRF     = {.msk = 0x00000100U, .pos = 8};    /** @brief Clear slave resume flag. */
  static const field32_t SWPMI_ICR_CRDYF    = {.msk = 0x00000800U, .pos = 11};   /** @brief Clear transceiver ready flag. */
  static const field32_t SWPMI_IER_RXBFIE   = {.msk = 0x00000001U, .pos = 0};    /** @brief Receive buffer full interrupt enable. */
  static const field32_t SWPMI_IER_TXBEIE   = {.msk = 0x00000002U, .pos = 1};    /** @brief Transmit buffer empty interrupt enable. */
  static const field32_t SWPMI_IER_RXBERIE  = {.msk = 0x00000004U, .pos = 2};    /** @brief Receive CRC error interrupt enable. */
  static const field32_t SWPMI_IER_RXOVRIE  = {.msk = 0x00000008U, .pos = 3};    /** @brief Receive overrun error interrupt enable. */
  static const field32_t SWPMI_IER_TXUNRIE  = {.msk = 0x00000010U, .pos = 4};    /** @brief Transmit underrun error interrupt enable. */
  static const field32_t SWPMI_IER_RIE      = {.msk = 0x00000020U, .pos = 5};    /** @brief Receive interrupt enable. */
  static const field32_t SWPMI_IER_TIE      = {.msk = 0x00000040U, .pos = 6};    /** @brief Transmit interrupt enable. */
  static const field32_t SWPMI_IER_TCIE     = {.msk = 0x00000080U, .pos = 7};    /** @brief Transmit complete interrupt enable. */
  static const field32_t SWPMI_IER_SRIE     = {.msk = 0x00000100U, .pos = 8};    /** @brief Slave resume interrupt enable. */
  static const field32_t SWPMI_IER_RDYIE    = {.msk = 0x00000800U, .pos = 11};   /** @brief Transceiver ready interrupt enable. */
  static const field32_t SWPMI_RFL_RFL      = {.msk = 0x0000001FU, .pos = 0};    /** @brief Receive frame length. */
  static const field32_t SWPMI_OR_SWP_TBYP  = {.msk = 0x00000001U, .pos = 0};    /** @brief SWP transceiver bypass. */
  static const field32_t SWPMI_OR_SWP_CLASS = {.msk = 0x00000002U, .pos = 1};    /** @brief SWP class selection. */

  /************************************************************************************************
   * G_TIMx Definitions
   ************************************************************************************************/

  /**** Enumerated G_TIMx Register Definitions ****/

  static const rw_reg32_t G_TIMx_CRx[15][3] = {
    [2]  = {
      [1] = (rw_reg32_t)0x40000000U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40000004U,   /** @brief Control register 2. */
    },
    [3]  = {
      [1] = (rw_reg32_t)0x40000400U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40000404U,   /** @brief Control register 2. */
    },
    [4]  = {
      [1] = (rw_reg32_t)0x40000800U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40000804U,   /** @brief Control register 2. */
    },
    [5]  = {
      [1] = (rw_reg32_t)0x40000C00U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40000C04U,   /** @brief Control register 2. */
    },
    [12] = {
      [1] = (rw_reg32_t)0x40001800U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40001804U,   /** @brief Control register 2. */
    },
    [13] = {
      [1] = (rw_reg32_t)0x40001C00U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40001C04U,   /** @brief Control register 2. */
    },
    [14] = {
      [1] = (rw_reg32_t)0x40002000U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40002004U,   /** @brief Control register 2. */
    },
  };

  static const rw_reg32_t G_TIMx_SMCR[15] = {
    [2]  = (rw_reg32_t)0x40000008U,   /** @brief Slave mode control register. */
    [3]  = (rw_reg32_t)0x40000408U,   /** @brief Slave mode control register. */
    [4]  = (rw_reg32_t)0x40000808U,   /** @brief Slave mode control register. */
    [5]  = (rw_reg32_t)0x40000C08U,   /** @brief Slave mode control register. */
    [12] = (rw_reg32_t)0x40001808U,   /** @brief Slave mode control register. */
    [13] = (rw_reg32_t)0x40001C08U,   /** @brief Slave mode control register. */
    [14] = (rw_reg32_t)0x40002008U,   /** @brief Slave mode control register. */
  };

  static const rw_reg32_t G_TIMx_DIER[15] = {
    [2]  = (rw_reg32_t)0x4000000CU,   /** @brief DMA/Interrupt enable register. */
    [3]  = (rw_reg32_t)0x4000040CU,   /** @brief DMA/Interrupt enable register. */
    [4]  = (rw_reg32_t)0x4000080CU,   /** @brief DMA/Interrupt enable register. */
    [5]  = (rw_reg32_t)0x40000C0CU,   /** @brief DMA/Interrupt enable register. */
    [12] = (rw_reg32_t)0x4000180CU,   /** @brief DMA/Interrupt enable register. */
    [13] = (rw_reg32_t)0x40001C0CU,   /** @brief DMA/Interrupt enable register. */
    [14] = (rw_reg32_t)0x4000200CU,   /** @brief DMA/Interrupt enable register. */
  };

  static const rw_reg32_t G_TIMx_SR[15] = {
    [2]  = (rw_reg32_t)0x40000010U,   /** @brief Status register. */
    [3]  = (rw_reg32_t)0x40000410U,   /** @brief Status register. */
    [4]  = (rw_reg32_t)0x40000810U,   /** @brief Status register. */
    [5]  = (rw_reg32_t)0x40000C10U,   /** @brief Status register. */
    [12] = (rw_reg32_t)0x40001810U,   /** @brief Status register. */
    [13] = (rw_reg32_t)0x40001C10U,   /** @brief Status register. */
    [14] = (rw_reg32_t)0x40002010U,   /** @brief Status register. */
  };

  static const rw_reg32_t G_TIMx_EGR[15] = {
    [2]  = (rw_reg32_t)0x40000014U,   /** @brief Event generation register. */
    [3]  = (rw_reg32_t)0x40000414U,   /** @brief Event generation register. */
    [4]  = (rw_reg32_t)0x40000814U,   /** @brief Event generation register. */
    [5]  = (rw_reg32_t)0x40000C14U,   /** @brief Event generation register. */
    [12] = (rw_reg32_t)0x40001814U,   /** @brief Event generation register. */
    [13] = (rw_reg32_t)0x40001C14U,   /** @brief Event generation register. */
    [14] = (rw_reg32_t)0x40002014U,   /** @brief Event generation register. */
  };

  static const rw_reg32_t G_TIMx_CCMRx_OUTPUT[15][3] = {
    [2]  = {
      [1] = (rw_reg32_t)0x40000018U,   /** @brief Capture/compare mode register 1 (output mode). */
      [2] = (rw_reg32_t)0x4000001CU,   /** @brief Capture/compare mode register 2 (output mode). */
    },
    [3]  = {
      [1] = (rw_reg32_t)0x40000418U,   /** @brief Capture/compare mode register 1 (output mode). */
      [2] = (rw_reg32_t)0x4000041CU,   /** @brief Capture/compare mode register 2 (output mode). */
    },
    [4]  = {
      [1] = (rw_reg32_t)0x40000818U,   /** @brief Capture/compare mode register 1 (output mode). */
      [2] = (rw_reg32_t)0x4000081CU,   /** @brief Capture/compare mode register 2 (output mode). */
    },
    [5]  = {
      [1] = (rw_reg32_t)0x40000C18U,   /** @brief Capture/compare mode register 1 (output mode). */
      [2] = (rw_reg32_t)0x40000C1CU,   /** @brief Capture/compare mode register 2 (output mode). */
    },
    [12] = {
      [1] = (rw_reg32_t)0x40001818U,   /** @brief Capture/compare mode register 1 (output mode). */
      [2] = (rw_reg32_t)0x4000181CU,   /** @brief Capture/compare mode register 2 (output mode). */
    },
    [13] = {
      [1] = (rw_reg32_t)0x40001C18U,   /** @brief Capture/compare mode register 1 (output mode). */
      [2] = (rw_reg32_t)0x40001C1CU,   /** @brief Capture/compare mode register 2 (output mode). */
    },
    [14] = {
      [1] = (rw_reg32_t)0x40002018U,   /** @brief Capture/compare mode register 1 (output mode). */
      [2] = (rw_reg32_t)0x4000201CU,   /** @brief Capture/compare mode register 2 (output mode). */
    },
  };

  static const rw_reg32_t G_TIMx_CCMRx_INPUT[15][3] = {
    [2]  = {
      [1] = (rw_reg32_t)0x40000018U,   /** @brief Capture/compare mode register 1 (input mode). */
      [2] = (rw_reg32_t)0x4000001CU,   /** @brief Capture/compare mode register 2 (input mode). */
    },
    [3]  = {
      [1] = (rw_reg32_t)0x40000418U,   /** @brief Capture/compare mode register 1 (input mode). */
      [2] = (rw_reg32_t)0x4000041CU,   /** @brief Capture/compare mode register 2 (input mode). */
    },
    [4]  = {
      [1] = (rw_reg32_t)0x40000818U,   /** @brief Capture/compare mode register 1 (input mode). */
      [2] = (rw_reg32_t)0x4000081CU,   /** @brief Capture/compare mode register 2 (input mode). */
    },
    [5]  = {
      [1] = (rw_reg32_t)0x40000C18U,   /** @brief Capture/compare mode register 1 (input mode). */
      [2] = (rw_reg32_t)0x40000C1CU,   /** @brief Capture/compare mode register 2 (input mode). */
    },
    [12] = {
      [1] = (rw_reg32_t)0x40001818U,   /** @brief Capture/compare mode register 1 (input mode). */
      [2] = (rw_reg32_t)0x4000181CU,   /** @brief Capture/compare mode register 2 (input mode). */
    },
    [13] = {
      [1] = (rw_reg32_t)0x40001C18U,   /** @brief Capture/compare mode register 1 (input mode). */
      [2] = (rw_reg32_t)0x40001C1CU,   /** @brief Capture/compare mode register 2 (input mode). */
    },
    [14] = {
      [1] = (rw_reg32_t)0x40002018U,   /** @brief Capture/compare mode register 1 (input mode). */
      [2] = (rw_reg32_t)0x4000201CU,   /** @brief Capture/compare mode register 2 (input mode). */
    },
  };

  static const rw_reg32_t G_TIMx_CCER[15] = {
    [2]  = (rw_reg32_t)0x40000020U,   /** @brief Capture/compare enable register. */
    [3]  = (rw_reg32_t)0x40000420U,   /** @brief Capture/compare enable register. */
    [4]  = (rw_reg32_t)0x40000820U,   /** @brief Capture/compare enable register. */
    [5]  = (rw_reg32_t)0x40000C20U,   /** @brief Capture/compare enable register. */
    [12] = (rw_reg32_t)0x40001820U,   /** @brief Capture/compare enable register. */
    [13] = (rw_reg32_t)0x40001C20U,   /** @brief Capture/compare enable register. */
    [14] = (rw_reg32_t)0x40002020U,   /** @brief Capture/compare enable register. */
  };

  static const rw_reg32_t G_TIMx_CNT[15] = {
    [2]  = (rw_reg32_t)0x40000024U,   /** @brief Counter. */
    [3]  = (rw_reg32_t)0x40000424U,   /** @brief Counter. */
    [4]  = (rw_reg32_t)0x40000824U,   /** @brief Counter. */
    [5]  = (rw_reg32_t)0x40000C24U,   /** @brief Counter. */
    [12] = (rw_reg32_t)0x40001824U,   /** @brief Counter. */
    [13] = (rw_reg32_t)0x40001C24U,   /** @brief Counter. */
    [14] = (rw_reg32_t)0x40002024U,   /** @brief Counter. */
  };

  static const rw_reg32_t G_TIMx_PSC[15] = {
    [2]  = (rw_reg32_t)0x40000028U,   /** @brief Prescaler. */
    [3]  = (rw_reg32_t)0x40000428U,   /** @brief Prescaler. */
    [4]  = (rw_reg32_t)0x40000828U,   /** @brief Prescaler. */
    [5]  = (rw_reg32_t)0x40000C28U,   /** @brief Prescaler. */
    [12] = (rw_reg32_t)0x40001828U,   /** @brief Prescaler. */
    [13] = (rw_reg32_t)0x40001C28U,   /** @brief Prescaler. */
    [14] = (rw_reg32_t)0x40002028U,   /** @brief Prescaler. */
  };

  static const rw_reg32_t G_TIMx_ARR[15] = {
    [2]  = (rw_reg32_t)0x4000002CU,   /** @brief Auto-reload register. */
    [3]  = (rw_reg32_t)0x4000042CU,   /** @brief Auto-reload register. */
    [4]  = (rw_reg32_t)0x4000082CU,   /** @brief Auto-reload register. */
    [5]  = (rw_reg32_t)0x40000C2CU,   /** @brief Auto-reload register. */
    [12] = (rw_reg32_t)0x4000182CU,   /** @brief Auto-reload register. */
    [13] = (rw_reg32_t)0x40001C2CU,   /** @brief Auto-reload register. */
    [14] = (rw_reg32_t)0x4000202CU,   /** @brief Auto-reload register. */
  };

  static const rw_reg32_t G_TIMx_CCRx[15][5] = {
    [2]  = {
      [1] = (rw_reg32_t)0x40000034U,   /** @brief Capture/compare register 1. */
      [2] = (rw_reg32_t)0x40000038U,   /** @brief Capture/compare register 2. */
      [3] = (rw_reg32_t)0x4000003CU,   /** @brief Capture/compare register 3. */
      [4] = (rw_reg32_t)0x40000040U,   /** @brief Capture/compare register 4. */
    },
    [3]  = {
      [1] = (rw_reg32_t)0x40000434U,   /** @brief Capture/compare register 1. */
      [2] = (rw_reg32_t)0x40000438U,   /** @brief Capture/compare register 2. */
      [3] = (rw_reg32_t)0x4000043CU,   /** @brief Capture/compare register 3. */
      [4] = (rw_reg32_t)0x40000440U,   /** @brief Capture/compare register 4. */
    },
    [4]  = {
      [1] = (rw_reg32_t)0x40000834U,   /** @brief Capture/compare register 1. */
      [2] = (rw_reg32_t)0x40000838U,   /** @brief Capture/compare register 2. */
      [3] = (rw_reg32_t)0x4000083CU,   /** @brief Capture/compare register 3. */
      [4] = (rw_reg32_t)0x40000840U,   /** @brief Capture/compare register 4. */
    },
    [5]  = {
      [1] = (rw_reg32_t)0x40000C34U,   /** @brief Capture/compare register 1. */
      [2] = (rw_reg32_t)0x40000C38U,   /** @brief Capture/compare register 2. */
      [3] = (rw_reg32_t)0x40000C3CU,   /** @brief Capture/compare register 3. */
      [4] = (rw_reg32_t)0x40000C40U,   /** @brief Capture/compare register 4. */
    },
    [12] = {
      [1] = (rw_reg32_t)0x40001834U,   /** @brief Capture/compare register 1. */
      [2] = (rw_reg32_t)0x40001838U,   /** @brief Capture/compare register 2. */
      [3] = (rw_reg32_t)0x4000183CU,   /** @brief Capture/compare register 3. */
      [4] = (rw_reg32_t)0x40001840U,   /** @brief Capture/compare register 4. */
    },
    [13] = {
      [1] = (rw_reg32_t)0x40001C34U,   /** @brief Capture/compare register 1. */
      [2] = (rw_reg32_t)0x40001C38U,   /** @brief Capture/compare register 2. */
      [3] = (rw_reg32_t)0x40001C3CU,   /** @brief Capture/compare register 3. */
      [4] = (rw_reg32_t)0x40001C40U,   /** @brief Capture/compare register 4. */
    },
    [14] = {
      [1] = (rw_reg32_t)0x40002034U,   /** @brief Capture/compare register 1. */
      [2] = (rw_reg32_t)0x40002038U,   /** @brief Capture/compare register 2. */
      [3] = (rw_reg32_t)0x4000203CU,   /** @brief Capture/compare register 3. */
      [4] = (rw_reg32_t)0x40002040U,   /** @brief Capture/compare register 4. */
    },
  };

  static const rw_reg32_t G_TIMx_DCR[15] = {
    [2]  = (rw_reg32_t)0x40000048U,   /** @brief DMA control register. */
    [3]  = (rw_reg32_t)0x40000448U,   /** @brief DMA control register. */
    [4]  = (rw_reg32_t)0x40000848U,   /** @brief DMA control register. */
    [5]  = (rw_reg32_t)0x40000C48U,   /** @brief DMA control register. */
    [12] = (rw_reg32_t)0x40001848U,   /** @brief DMA control register. */
    [13] = (rw_reg32_t)0x40001C48U,   /** @brief DMA control register. */
    [14] = (rw_reg32_t)0x40002048U,   /** @brief DMA control register. */
  };

  static const rw_reg32_t G_TIMx_DMAR[15] = {
    [2]  = (rw_reg32_t)0x4000004CU,   /** @brief DMA address for full transfer. */
    [3]  = (rw_reg32_t)0x4000044CU,   /** @brief DMA address for full transfer. */
    [4]  = (rw_reg32_t)0x4000084CU,   /** @brief DMA address for full transfer. */
    [5]  = (rw_reg32_t)0x40000C4CU,   /** @brief DMA address for full transfer. */
    [12] = (rw_reg32_t)0x4000184CU,   /** @brief DMA address for full transfer. */
    [13] = (rw_reg32_t)0x40001C4CU,   /** @brief DMA address for full transfer. */
    [14] = (rw_reg32_t)0x4000204CU,   /** @brief DMA address for full transfer. */
  };

  static const rw_reg32_t G_TIMx_AF1[15] = {
    [2]  = (rw_reg32_t)0x40000060U,   /** @brief TIM alternate function option register 1. */
    [3]  = (rw_reg32_t)0x40000460U,   /** @brief TIM alternate function option register 1. */
    [4]  = (rw_reg32_t)0x40000860U,   /** @brief TIM alternate function option register 1. */
    [5]  = (rw_reg32_t)0x40000C60U,   /** @brief TIM alternate function option register 1. */
    [12] = (rw_reg32_t)0x40001860U,   /** @brief TIM alternate function option register 1. */
    [13] = (rw_reg32_t)0x40001C60U,   /** @brief TIM alternate function option register 1. */
    [14] = (rw_reg32_t)0x40002060U,   /** @brief TIM alternate function option register 1. */
  };

  static const rw_reg32_t G_TIMx_TISEL[15] = {
    [2]  = (rw_reg32_t)0x40000068U,   /** @brief TIM timer input selection register. */
    [3]  = (rw_reg32_t)0x40000468U,   /** @brief TIM timer input selection register. */
    [4]  = (rw_reg32_t)0x40000868U,   /** @brief TIM timer input selection register. */
    [5]  = (rw_reg32_t)0x40000C68U,   /** @brief TIM timer input selection register. */
    [12] = (rw_reg32_t)0x40001868U,   /** @brief TIM timer input selection register. */
    [13] = (rw_reg32_t)0x40001C68U,   /** @brief TIM timer input selection register. */
    [14] = (rw_reg32_t)0x40002068U,   /** @brief TIM timer input selection register. */
  };

  /**** G_TIMx Register Field Definitions ****/

  static const field32_t G_TIMx_CRx_UIFREMAP       = {.msk = 0x00000800U, .pos = 11};   /** @brief UIF status bit remapping. */
  static const field32_t G_TIMx_CRx_CKD            = {.msk = 0x00000300U, .pos = 8};    /** @brief Clock division. */
  static const field32_t G_TIMx_CRx_ARPE           = {.msk = 0x00000080U, .pos = 7};    /** @brief Auto-reload preload enable. */
  static const field32_t G_TIMx_CRx_CMS            = {.msk = 0x00000060U, .pos = 5};    /** @brief Center-aligned mode selection. */
  static const field32_t G_TIMx_CRx_DIR            = {.msk = 0x00000010U, .pos = 4};    /** @brief Direction. */
  static const field32_t G_TIMx_CRx_OPM            = {.msk = 0x00000008U, .pos = 3};    /** @brief One-pulse mode. */
  static const field32_t G_TIMx_CRx_URS            = {.msk = 0x00000004U, .pos = 2};    /** @brief Update request source. */
  static const field32_t G_TIMx_CRx_UDIS           = {.msk = 0x00000002U, .pos = 1};    /** @brief Update disable. */
  static const field32_t G_TIMx_CRx_CEN            = {.msk = 0x00000001U, .pos = 0};    /** @brief Counter enable. */
  static const field32_t G_TIMx_SMCR_TS_4_3        = {.msk = 0x00300000U, .pos = 20};   /** @brief Trigger selection. */
  static const field32_t G_TIMx_SMCR_SMS_3         = {.msk = 0x00010000U, .pos = 16};   /** @brief Slave mode selection - bit 3. */
  static const field32_t G_TIMx_SMCR_ETP           = {.msk = 0x00008000U, .pos = 15};   /** @brief External trigger polarity. */
  static const field32_t G_TIMx_SMCR_ECE           = {.msk = 0x00004000U, .pos = 14};   /** @brief External clock enable. */
  static const field32_t G_TIMx_SMCR_ETPS          = {.msk = 0x00003000U, .pos = 12};   /** @brief External trigger prescaler. */
  static const field32_t G_TIMx_SMCR_ETF           = {.msk = 0x00000F00U, .pos = 8};    /** @brief External trigger filter. */
  static const field32_t G_TIMx_SMCR_MSM           = {.msk = 0x00000080U, .pos = 7};    /** @brief Master/Slave mode. */
  static const field32_t G_TIMx_SMCR_TS            = {.msk = 0x00000070U, .pos = 4};    /** @brief Trigger selection. */
  static const field32_t G_TIMx_SMCR_SMS           = {.msk = 0x00000007U, .pos = 0};    /** @brief Slave mode selection. */
  static const field32_t G_TIMx_DIER_TDE           = {.msk = 0x00004000U, .pos = 14};   /** @brief Trigger DMA request enable. */
  static const field32_t G_TIMx_DIER_UDE           = {.msk = 0x00000100U, .pos = 8};    /** @brief Update DMA request enable. */
  static const field32_t G_TIMx_DIER_TIE           = {.msk = 0x00000040U, .pos = 6};    /** @brief Trigger interrupt enable. */
  static const field32_t G_TIMx_DIER_UIE           = {.msk = 0x00000001U, .pos = 0};    /** @brief Update interrupt enable. */
  static const field32_t G_TIMx_SR_TIF             = {.msk = 0x00000040U, .pos = 6};    /** @brief Trigger interrupt flag. */
  static const field32_t G_TIMx_SR_UIF             = {.msk = 0x00000001U, .pos = 0};    /** @brief Update interrupt flag. */
  static const field32_t G_TIMx_EGR_TG             = {.msk = 0x00000040U, .pos = 6};    /** @brief Trigger generation. */
  static const field32_t G_TIMx_EGR_UG             = {.msk = 0x00000001U, .pos = 0};    /** @brief Update generation. */
  static const field32_t G_TIMx_CCMRx_INPUT_IC2PCS = {.msk = 0x00000C00U, .pos = 10};   /** @brief Input capture 2 prescaler. */
  static const field32_t G_TIMx_CCMRx_INPUT_ICPCS  = {.msk = 0x0000000CU, .pos = 2};    /** @brief Input capture 1 prescaler. */
  static const field32_t G_TIMx_CNT_CNT_L          = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Low counter value. */
  static const field32_t G_TIMx_CNT_CNT_H          = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief High counter value. */
  static const field32_t G_TIMx_PSC_PSC            = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Prescaler value. */
  static const field32_t G_TIMx_ARR_ARR_H          = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief High auto-reload value. */
  static const field32_t G_TIMx_ARR_ARR_L          = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Low auto-reload value. */
  static const field32_t G_TIMx_CCRx_CCR1_H        = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief High capture/compare 1 value. */
  static const field32_t G_TIMx_CCRx_CCR1_L        = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Low capture/compare 1 value. */
  static const field32_t G_TIMx_DCR_DBL            = {.msk = 0x00001F00U, .pos = 8};    /** @brief DMA burst length. */
  static const field32_t G_TIMx_DCR_DBA            = {.msk = 0x0000001FU, .pos = 0};    /** @brief DMA base address. */
  static const field32_t G_TIMx_DMAR_DMAB          = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief DMA register for burst accesses. */
  static const field32_t G_TIMx_AF1_ETRSEL         = {.msk = 0x0003C000U, .pos = 14};   /** @brief ETR source selection. */

  /**** Enumerated G_TIMx Register Field Definitions ****/

  static field32_t const G_TIMx_DIER_CCxDE[5] = {
    [1] = {.msk = 0x00000200U, .pos = 9},    /** @brief Capture/Compare 1 DMA request enable. */
    [2] = {.msk = 0x00000400U, .pos = 10},   /** @brief Capture/Compare 2 DMA request enable. */
    [3] = {.msk = 0x00000800U, .pos = 11},   /** @brief Capture/Compare 3 DMA request enable. */
    [4] = {.msk = 0x00001000U, .pos = 12},   /** @brief Capture/Compare 4 DMA request enable. */
  };

  static field32_t const G_TIMx_DIER_CCxIE[5] = {
    [1] = {.msk = 0x00000002U, .pos = 1},   /** @brief Capture/Compare 1 interrupt enable. */
    [2] = {.msk = 0x00000004U, .pos = 2},   /** @brief Capture/Compare 2 interrupt enable. */
    [3] = {.msk = 0x00000008U, .pos = 3},   /** @brief Capture/Compare 3 interrupt enable. */
    [4] = {.msk = 0x00000010U, .pos = 4},   /** @brief Capture/Compare 4 interrupt enable. */
  };

  static field32_t const G_TIMx_SR_CCxOF[5] = {
    [1] = {.msk = 0x00000200U, .pos = 9},    /** @brief Capture/Compare 1 overcapture flag. */
    [2] = {.msk = 0x00000400U, .pos = 10},   /** @brief Capture/compare 2 overcapture flag. */
    [3] = {.msk = 0x00000800U, .pos = 11},   /** @brief Capture/Compare 3 overcapture flag. */
    [4] = {.msk = 0x00001000U, .pos = 12},   /** @brief Capture/Compare 4 overcapture flag. */
  };

  static field32_t const G_TIMx_SR_CCxIF[5] = {
    [1] = {.msk = 0x00000002U, .pos = 1},   /** @brief Capture/compare 1 interrupt flag. */
    [2] = {.msk = 0x00000004U, .pos = 2},   /** @brief Capture/Compare 2 interrupt flag. */
    [3] = {.msk = 0x00000008U, .pos = 3},   /** @brief Capture/Compare 3 interrupt flag. */
    [4] = {.msk = 0x00000010U, .pos = 4},   /** @brief Capture/Compare 4 interrupt flag. */
  };

  static field32_t const G_TIMx_EGR_CCxG[5] = {
    [1] = {.msk = 0x00000002U, .pos = 1},   /** @brief Capture/compare 1 generation. */
    [2] = {.msk = 0x00000004U, .pos = 2},   /** @brief Capture/compare 2 generation. */
    [3] = {.msk = 0x00000008U, .pos = 3},   /** @brief Capture/compare 3 generation. */
    [4] = {.msk = 0x00000010U, .pos = 4},   /** @brief Capture/compare 4 generation. */
  };

  static field32_t const G_TIMx_CCMRx_OUTPUT_CCxS[3] = {
    [1] = {.msk = 0x00000003U, .pos = 0},   /** @brief CC1S. */
    [2] = {.msk = 0x00000300U, .pos = 8},   /** @brief CC2S. */
  };

  static field32_t const G_TIMx_CCMRx_OUTPUT_OCxFE[3] = {
    [1] = {.msk = 0x00000004U, .pos = 2},    /** @brief OC1FE. */
    [2] = {.msk = 0x00000400U, .pos = 10},   /** @brief OC2FE. */
  };

  static field32_t const G_TIMx_CCMRx_OUTPUT_OCxPE[3] = {
    [1] = {.msk = 0x00000008U, .pos = 3},    /** @brief OC1PE. */
    [2] = {.msk = 0x00000800U, .pos = 11},   /** @brief OC2PE. */
  };

  static field32_t const G_TIMx_CCMRx_OUTPUT_OCxM[3] = {
    [1] = {.msk = 0x00000070U, .pos = 4},    /** @brief OC1M. */
    [2] = {.msk = 0x00007000U, .pos = 12},   /** @brief OC2M. */
  };

  static field32_t const G_TIMx_CCMRx_OUTPUT_OCxCE[3] = {
    [1] = {.msk = 0x00000080U, .pos = 7},    /** @brief OC1CE. */
    [2] = {.msk = 0x00008000U, .pos = 15},   /** @brief OC2CE. */
  };

  static field32_t const G_TIMx_CCMRx_OUTPUT_OCxM_3[3] = {
    [1] = {.msk = 0x00010000U, .pos = 16},   /** @brief Output compare 1 mode - bit 3. */
    [2] = {.msk = 0x01000000U, .pos = 24},   /** @brief Output compare 2 mode - bit 3. */
  };

  static field32_t const G_TIMx_CCMRx_INPUT_ICxF[3] = {
    [1] = {.msk = 0x000000F0U, .pos = 4},    /** @brief Input capture 1 filter. */
    [2] = {.msk = 0x0000F000U, .pos = 12},   /** @brief Input capture 2 filter. */
  };

  static field32_t const G_TIMx_CCER_CCxNP[5] = {
    [1] = {.msk = 0x00000008U, .pos = 3},    /** @brief Capture/Compare 1 output polarity. */
    [2] = {.msk = 0x00000080U, .pos = 7},    /** @brief Capture/Compare 2 output polarity. */
    [3] = {.msk = 0x00000800U, .pos = 11},   /** @brief Capture/Compare 3 output polarity. */
    [4] = {.msk = 0x00008000U, .pos = 15},   /** @brief Capture/Compare 4 output polarity. */
  };

  static field32_t const G_TIMx_CCER_CCxP[5] = {
    [1] = {.msk = 0x00000002U, .pos = 1},    /** @brief Capture/Compare 1 output polarity. */
    [2] = {.msk = 0x00000020U, .pos = 5},    /** @brief Capture/Compare 2 output polarity. */
    [3] = {.msk = 0x00000200U, .pos = 9},    /** @brief Capture/Compare 3 output polarity. */
    [4] = {.msk = 0x00002000U, .pos = 13},   /** @brief Capture/Compare 3 output polarity. */
  };

  static field32_t const G_TIMx_CCER_CCxE[5] = {
    [1] = {.msk = 0x00000001U, .pos = 0},    /** @brief Capture/Compare 1 output enable. */
    [2] = {.msk = 0x00000010U, .pos = 4},    /** @brief Capture/Compare 2 output enable. */
    [3] = {.msk = 0x00000100U, .pos = 8},    /** @brief Capture/Compare 3 output enable. */
    [4] = {.msk = 0x00001000U, .pos = 12},   /** @brief Capture/Compare 4 output enable. */
  };

  static field32_t const G_TIMx_TISEL_TIxSEL[5] = {
    [1] = {.msk = 0x0000000FU, .pos = 0},    /** @brief TI1[0] to TI1[15] input selection. */
    [2] = {.msk = 0x00000F00U, .pos = 8},    /** @brief TI2[0] to TI2[15] input selection. */
    [3] = {.msk = 0x000F0000U, .pos = 16},   /** @brief TI3[0] to TI3[15] input selection. */
    [4] = {.msk = 0x0F000000U, .pos = 24},   /** @brief TI4[0] to TI4[15] input selection. */
  };

  /************************************************************************************************
   * B_TIMx Definitions
   ************************************************************************************************/

  /**** Enumerated B_TIMx Register Definitions ****/

  static const rw_reg32_t B_TIMx_CRx[8][3] = {
    [6] = {
      [1] = (rw_reg32_t)0x40001000U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40001004U,   /** @brief Control register 2. */
    },
    [7] = {
      [1] = (rw_reg32_t)0x40001400U,   /** @brief Control register 1. */
      [2] = (rw_reg32_t)0x40001404U,   /** @brief Control register 2. */
    },
  };

  static const rw_reg32_t B_TIMx_DIER[8] = {
    [6] = (rw_reg32_t)0x4000100CU,   /** @brief DMA/Interrupt enable register. */
    [7] = (rw_reg32_t)0x4000140CU,   /** @brief DMA/Interrupt enable register. */
  };

  static const rw_reg32_t B_TIMx_SR[8] = {
    [6] = (rw_reg32_t)0x40001010U,   /** @brief Status register. */
    [7] = (rw_reg32_t)0x40001410U,   /** @brief Status register. */
  };

  static const rw_reg32_t B_TIMx_EGR[8] = {
    [6] = (rw_reg32_t)0x40001014U,   /** @brief Event generation register. */
    [7] = (rw_reg32_t)0x40001414U,   /** @brief Event generation register. */
  };

  static const rw_reg32_t B_TIMx_CNT[8] = {
    [6] = (rw_reg32_t)0x40001024U,   /** @brief Counter. */
    [7] = (rw_reg32_t)0x40001424U,   /** @brief Counter. */
  };

  static const rw_reg32_t B_TIMx_PSC[8] = {
    [6] = (rw_reg32_t)0x40001028U,   /** @brief Prescaler. */
    [7] = (rw_reg32_t)0x40001428U,   /** @brief Prescaler. */
  };

  static const rw_reg32_t B_TIMx_ARR[8] = {
    [6] = (rw_reg32_t)0x4000102CU,   /** @brief Auto-reload register. */
    [7] = (rw_reg32_t)0x4000142CU,   /** @brief Auto-reload register. */
  };

  /**** B_TIMx Register Field Definitions ****/

  static const field32_t B_TIMx_CRx_UIFREMAP = {.msk = 0x00000800U, .pos = 11};   /** @brief UIF status bit remapping. */
  static const field32_t B_TIMx_CRx_ARPE     = {.msk = 0x00000080U, .pos = 7};    /** @brief Auto-reload preload enable. */
  static const field32_t B_TIMx_CRx_OPM      = {.msk = 0x00000008U, .pos = 3};    /** @brief One-pulse mode. */
  static const field32_t B_TIMx_CRx_URS      = {.msk = 0x00000004U, .pos = 2};    /** @brief Update request source. */
  static const field32_t B_TIMx_CRx_UDIS     = {.msk = 0x00000002U, .pos = 1};    /** @brief Update disable. */
  static const field32_t B_TIMx_CRx_CEN      = {.msk = 0x00000001U, .pos = 0};    /** @brief Counter enable. */
  static const field32_t B_TIMx_DIER_UDE     = {.msk = 0x00000100U, .pos = 8};    /** @brief Update DMA request enable. */
  static const field32_t B_TIMx_DIER_UIE     = {.msk = 0x00000001U, .pos = 0};    /** @brief Update interrupt enable. */
  static const field32_t B_TIMx_SR_UIF       = {.msk = 0x00000001U, .pos = 0};    /** @brief Update interrupt flag. */
  static const field32_t B_TIMx_EGR_UG       = {.msk = 0x00000001U, .pos = 0};    /** @brief Update generation. */
  static const field32_t B_TIMx_CNT_CNT      = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Low counter value. */
  static const field32_t B_TIMx_CNT_UIFCPY   = {.msk = 0x80000000U, .pos = 31};   /** @brief UIF copy. */
  static const field32_t B_TIMx_PSC_PSC      = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Prescaler value. */
  static const field32_t B_TIMx_ARR_ARR      = {.msk = 0x0000FFFFU, .pos = 0};    /** @brief Low auto-reload value. */

  /************************************************************************************************
   * PF Definitions
   ************************************************************************************************/

  /**** PF Register Definitions ****/

  static const ro_reg32_t PF_CLIDR  = (ro_reg32_t)0xE000ED78U;   /** @brief Cache level ID register. */
  static const ro_reg32_t PF_CTR    = (ro_reg32_t)0xE000ED7CU;   /** @brief Cache type register. */
  static const ro_reg32_t PF_CCSIDR = (ro_reg32_t)0xE000ED80U;   /** @brief Cache size ID register. */

  /**** PF Register Field Definitions ****/

  static const field32_t PF_CLIDR_LOUIS          = {.msk = 0x00E00000U, .pos = 21};   /** @brief LoUIS. */
  static const field32_t PF_CLIDR_LOC            = {.msk = 0x07000000U, .pos = 24};   /** @brief LoC. */
  static const field32_t PF_CLIDR_LOU            = {.msk = 0x38000000U, .pos = 27};   /** @brief LoU. */
  static const field32_t PF_CTR__IMINLINE        = {.msk = 0x0000000FU, .pos = 0};    /** @brief IminLine. */
  static const field32_t PF_CTR_DMINLINE         = {.msk = 0x000F0000U, .pos = 16};   /** @brief DMinLine. */
  static const field32_t PF_CTR_ERG              = {.msk = 0x00F00000U, .pos = 20};   /** @brief ERG. */
  static const field32_t PF_CTR_CWG              = {.msk = 0x0F000000U, .pos = 24};   /** @brief CWG. */
  static const field32_t PF_CTR_FORMAT           = {.msk = 0xE0000000U, .pos = 29};   /** @brief Format. */
  static const field32_t PF_CCSIDR_LINESIZE      = {.msk = 0x00000007U, .pos = 0};    /** @brief LineSize. */
  static const field32_t PF_CCSIDR_ASSOCIATIVITY = {.msk = 0x00001FF8U, .pos = 3};    /** @brief Associativity. */
  static const field32_t PF_CCSIDR_NUMSETS       = {.msk = 0x0FFFE000U, .pos = 13};   /** @brief NumSets. */
  static const field32_t PF_CCSIDR_WA            = {.msk = 0x10000000U, .pos = 28};   /** @brief WA. */
  static const field32_t PF_CCSIDR_RA            = {.msk = 0x20000000U, .pos = 29};   /** @brief RA. */
  static const field32_t PF_CCSIDR_WB            = {.msk = 0x40000000U, .pos = 30};   /** @brief WB. */
  static const field32_t PF_CCSIDR_WT            = {.msk = 0x80000000U, .pos = 31};   /** @brief WT. */

  /**** Enumerated PF Register Field Definitions ****/

  static field32_t const PF_CLIDR_CLx[8] = {
    [1] = {.msk = 0x00000007U, .pos = 0},    /** @brief CL1. */
    [2] = {.msk = 0x00000038U, .pos = 3},    /** @brief CL2. */
    [3] = {.msk = 0x000001C0U, .pos = 6},    /** @brief CL3. */
    [4] = {.msk = 0x00000E00U, .pos = 9},    /** @brief CL4. */
    [5] = {.msk = 0x00007000U, .pos = 12},   /** @brief CL5. */
    [6] = {.msk = 0x00038000U, .pos = 15},   /** @brief CL6. */
    [7] = {.msk = 0x001C0000U, .pos = 18},   /** @brief CL7. */
  };

  /************************************************************************************************
   * AC Definitions
   ************************************************************************************************/

  /**** AC Register Definitions ****/

  static const rw_reg32_t AC_ITCMCR = (rw_reg32_t)0xE000EF90U;   /** @brief Instruction and data tightly-coupled memory control registers. */
  static const rw_reg32_t AC_DTCMCR = (rw_reg32_t)0xE000EF94U;   /** @brief Instruction and data tightly-coupled memory control registers. */
  static const rw_reg32_t AC_AHBPCR = (rw_reg32_t)0xE000EF98U;   /** @brief AHBP control register. */
  static const rw_reg32_t AC_CACR   = (rw_reg32_t)0xE000EF9CU;   /** @brief Auxiliary cache control register. */
  static const rw_reg32_t AC_AHBSCR = (rw_reg32_t)0xE000EFA0U;   /** @brief AHB slave control register. */
  static const rw_reg32_t AC_ABFSR  = (rw_reg32_t)0xE000EFA8U;   /** @brief Auxiliary bus fault status register. */

  /**** AC Register Field Definitions ****/

  static const field32_t AC_ITCMCR_EN        = {.msk = 0x00000001U, .pos = 0};    /** @brief EN. */
  static const field32_t AC_ITCMCR_RMW       = {.msk = 0x00000002U, .pos = 1};    /** @brief RMW. */
  static const field32_t AC_ITCMCR_RETEN     = {.msk = 0x00000004U, .pos = 2};    /** @brief RETEN. */
  static const field32_t AC_ITCMCR_SZ        = {.msk = 0x00000078U, .pos = 3};    /** @brief SZ. */
  static const field32_t AC_DTCMCR_EN        = {.msk = 0x00000001U, .pos = 0};    /** @brief EN. */
  static const field32_t AC_DTCMCR_RMW       = {.msk = 0x00000002U, .pos = 1};    /** @brief RMW. */
  static const field32_t AC_DTCMCR_RETEN     = {.msk = 0x00000004U, .pos = 2};    /** @brief RETEN. */
  static const field32_t AC_DTCMCR_SZ        = {.msk = 0x00000078U, .pos = 3};    /** @brief SZ. */
  static const field32_t AC_AHBPCR_EN        = {.msk = 0x00000001U, .pos = 0};    /** @brief EN. */
  static const field32_t AC_AHBPCR_SZ        = {.msk = 0x0000000EU, .pos = 1};    /** @brief SZ. */
  static const field32_t AC_CACR_SIWT        = {.msk = 0x00000001U, .pos = 0};    /** @brief SIWT. */
  static const field32_t AC_CACR_ECCEN       = {.msk = 0x00000002U, .pos = 1};    /** @brief ECCEN. */
  static const field32_t AC_CACR_FORCEWT     = {.msk = 0x00000004U, .pos = 2};    /** @brief FORCEWT. */
  static const field32_t AC_AHBSCR_CTL       = {.msk = 0x00000003U, .pos = 0};    /** @brief CTL. */
  static const field32_t AC_AHBSCR_TPRI      = {.msk = 0x000007FCU, .pos = 2};    /** @brief TPRI. */
  static const field32_t AC_AHBSCR_INITCOUNT = {.msk = 0x0000F800U, .pos = 11};   /** @brief INITCOUNT. */
  static const field32_t AC_ABFSR_ITCM       = {.msk = 0x00000001U, .pos = 0};    /** @brief ITCM. */
  static const field32_t AC_ABFSR_DTCM       = {.msk = 0x00000002U, .pos = 1};    /** @brief DTCM. */
  static const field32_t AC_ABFSR_AHBP       = {.msk = 0x00000004U, .pos = 2};    /** @brief AHBP. */
  static const field32_t AC_ABFSR_AXIM       = {.msk = 0x00000008U, .pos = 3};    /** @brief AXIM. */
  static const field32_t AC_ABFSR_EPPB       = {.msk = 0x00000010U, .pos = 4};    /** @brief EPPB. */
  static const field32_t AC_ABFSR_AXIMTYPE   = {.msk = 0x00000300U, .pos = 8};    /** @brief AXIMTYPE. */

  /************************************************************************************************
   * RAMECCx Definitions
   ************************************************************************************************/

  /**** Enumerated RAMECCx Register Definitions ****/

  static const rw_reg32_t RAMECCx_IER[4] = {
    [1] = (rw_reg32_t)0x52009000U,   /** @brief RAMECC interrupt enable register. */
    [2] = (rw_reg32_t)0x48023000U,   /** @brief RAMECC interrupt enable register. */
    [3] = (rw_reg32_t)0x58027000U,   /** @brief RAMECC interrupt enable register. */
  };

  static const rw_reg32_t RAMECCx_MxCR[4][6] = {
    [1] = {
      [1] = (rw_reg32_t)0x52009020U,   /** @brief RAMECC monitor x configuration register. */
      [2] = (rw_reg32_t)0x52009040U,   /** @brief RAMECC monitor x configuration register. */
      [3] = (rw_reg32_t)0x52009060U,   /** @brief RAMECC monitor x configuration register. */
      [4] = (rw_reg32_t)0x52009080U,   /** @brief RAMECC monitor x configuration register. */
      [5] = (rw_reg32_t)0x520090A0U,   /** @brief RAMECC monitor x configuration register. */
    },
    [2] = {
      [1] = (rw_reg32_t)0x48023020U,   /** @brief RAMECC monitor x configuration register. */
      [2] = (rw_reg32_t)0x48023040U,   /** @brief RAMECC monitor x configuration register. */
      [3] = (rw_reg32_t)0x48023060U,   /** @brief RAMECC monitor x configuration register. */
      [4] = (rw_reg32_t)0x48023080U,   /** @brief RAMECC monitor x configuration register. */
      [5] = (rw_reg32_t)0x480230A0U,   /** @brief RAMECC monitor x configuration register. */
    },
    [3] = {
      [1] = (rw_reg32_t)0x58027020U,   /** @brief RAMECC monitor x configuration register. */
      [2] = (rw_reg32_t)0x58027040U,   /** @brief RAMECC monitor x configuration register. */
    },
  };

  static const rw_reg32_t RAMECCx_MxSR[4][6] = {
    [1] = {
      [1] = (rw_reg32_t)0x52009024U,   /** @brief RAMECC monitor x status register. */
      [2] = (rw_reg32_t)0x52009044U,   /** @brief RAMECC monitor x status register. */
      [3] = (rw_reg32_t)0x52009064U,   /** @brief RAMECC monitor x status register. */
      [4] = (rw_reg32_t)0x52009084U,   /** @brief RAMECC monitor x status register. */
      [5] = (rw_reg32_t)0x520090A4U,   /** @brief RAMECC monitor x status register. */
    },
    [2] = {
      [1] = (rw_reg32_t)0x48023024U,   /** @brief RAMECC monitor x status register. */
      [2] = (rw_reg32_t)0x48023044U,   /** @brief RAMECC monitor x status register. */
      [3] = (rw_reg32_t)0x48023064U,   /** @brief RAMECC monitor x status register. */
      [4] = (rw_reg32_t)0x48023084U,   /** @brief RAMECC monitor x status register. */
      [5] = (rw_reg32_t)0x480230A4U,   /** @brief RAMECC monitor x status register. */
    },
    [3] = {
      [1] = (rw_reg32_t)0x58027024U,   /** @brief RAMECC monitor x status register. */
      [2] = (rw_reg32_t)0x58027044U,   /** @brief RAMECC monitor x status register. */
    },
  };

  static const rw_reg32_t RAMECCx_MxFAR[4][6] = {
    [1] = {
      [1] = (rw_reg32_t)0x52009028U,   /** @brief RAMECC monitor x failing address register. */
      [2] = (rw_reg32_t)0x52009048U,   /** @brief RAMECC monitor x failing address register. */
      [3] = (rw_reg32_t)0x52009068U,   /** @brief RAMECC monitor x failing address register. */
      [4] = (rw_reg32_t)0x52009088U,   /** @brief RAMECC monitor x failing address register. */
      [5] = (rw_reg32_t)0x520090A8U,   /** @brief RAMECC monitor x failing address register. */
    },
    [2] = {
      [1] = (rw_reg32_t)0x48023028U,   /** @brief RAMECC monitor x failing address register. */
      [2] = (rw_reg32_t)0x48023048U,   /** @brief RAMECC monitor x failing address register. */
      [3] = (rw_reg32_t)0x48023068U,   /** @brief RAMECC monitor x failing address register. */
      [4] = (rw_reg32_t)0x48023088U,   /** @brief RAMECC monitor x failing address register. */
      [5] = (rw_reg32_t)0x480230A8U,   /** @brief RAMECC monitor x failing address register. */
    },
    [3] = {
      [1] = (rw_reg32_t)0x58027028U,   /** @brief RAMECC monitor x failing address register. */
      [2] = (rw_reg32_t)0x58027048U,   /** @brief RAMECC monitor x failing address register. */
    },
  };

  static const rw_reg32_t RAMECCx_MxFDRL[4][6] = {
    [1] = {
      [1] = (rw_reg32_t)0x5200902CU,   /** @brief RAMECC monitor x failing data low register. */
      [2] = (rw_reg32_t)0x5200904CU,   /** @brief RAMECC monitor x failing data low register. */
      [3] = (rw_reg32_t)0x5200906CU,   /** @brief RAMECC monitor x failing data low register. */
      [4] = (rw_reg32_t)0x5200908CU,   /** @brief RAMECC monitor x failing data low register. */
      [5] = (rw_reg32_t)0x520090ACU,   /** @brief RAMECC monitor x failing data low register. */
    },
    [2] = {
      [1] = (rw_reg32_t)0x4802302CU,   /** @brief RAMECC monitor x failing data low register. */
      [2] = (rw_reg32_t)0x4802304CU,   /** @brief RAMECC monitor x failing data low register. */
      [3] = (rw_reg32_t)0x4802306CU,   /** @brief RAMECC monitor x failing data low register. */
      [4] = (rw_reg32_t)0x4802308CU,   /** @brief RAMECC monitor x failing data low register. */
      [5] = (rw_reg32_t)0x480230ACU,   /** @brief RAMECC monitor x failing data low register. */
    },
    [3] = {
      [1] = (rw_reg32_t)0x5802702CU,   /** @brief RAMECC monitor x failing data low register. */
      [2] = (rw_reg32_t)0x5802704CU,   /** @brief RAMECC monitor x failing data low register. */
    },
  };

  static const rw_reg32_t RAMECCx_MxFDRH[4][6] = {
    [1] = {
      [1] = (rw_reg32_t)0x52009030U,   /** @brief RAMECC monitor x failing data high register. */
      [2] = (rw_reg32_t)0x52009050U,   /** @brief RAMECC monitor x failing data high register. */
      [3] = (rw_reg32_t)0x52009070U,   /** @brief RAMECC monitor x failing data high register. */
      [4] = (rw_reg32_t)0x52009090U,   /** @brief RAMECC monitor x failing data high register. */
      [5] = (rw_reg32_t)0x520090B0U,   /** @brief RAMECC monitor x failing data high register. */
    },
    [2] = {
      [1] = (rw_reg32_t)0x48023030U,   /** @brief RAMECC monitor x failing data high register. */
      [2] = (rw_reg32_t)0x48023050U,   /** @brief RAMECC monitor x failing data high register. */
      [3] = (rw_reg32_t)0x48023070U,   /** @brief RAMECC monitor x failing data high register. */
      [4] = (rw_reg32_t)0x48023090U,   /** @brief RAMECC monitor x failing data high register. */
      [5] = (rw_reg32_t)0x480230B0U,   /** @brief RAMECC monitor x failing data high register. */
    },
    [3] = {
      [1] = (rw_reg32_t)0x58027030U,   /** @brief RAMECC monitor x failing data high register. */
      [2] = (rw_reg32_t)0x58027050U,   /** @brief RAMECC monitor x failing data high register. */
    },
  };

  static const rw_reg32_t RAMECCx_MxFECR[4][6] = {
    [1] = {
      [1] = (rw_reg32_t)0x52009034U,   /** @brief RAMECC monitor x failing ECC error code register. */
      [2] = (rw_reg32_t)0x52009058U,   /** @brief RAMECC monitor x failing ECC error code register. */
      [3] = (rw_reg32_t)0x5200907CU,   /** @brief RAMECC monitor x failing ECC error code register. */
      [4] = (rw_reg32_t)0x52009090U,   /** @brief RAMECC monitor x failing ECC error code register. */
      [5] = (rw_reg32_t)0x520090B4U,   /** @brief RAMECC monitor x failing ECC error code register. */
    },
    [2] = {
      [1] = (rw_reg32_t)0x48023034U,   /** @brief RAMECC monitor x failing ECC error code register. */
      [2] = (rw_reg32_t)0x48023058U,   /** @brief RAMECC monitor x failing ECC error code register. */
      [3] = (rw_reg32_t)0x4802307CU,   /** @brief RAMECC monitor x failing ECC error code register. */
      [4] = (rw_reg32_t)0x48023090U,   /** @brief RAMECC monitor x failing ECC error code register. */
      [5] = (rw_reg32_t)0x480230B4U,   /** @brief RAMECC monitor x failing ECC error code register. */
    },
    [3] = {
      [1] = (rw_reg32_t)0x58027034U,   /** @brief RAMECC monitor x failing ECC error code register. */
      [2] = (rw_reg32_t)0x58027058U,   /** @brief RAMECC monitor x failing ECC error code register. */
    },
  };

  /**** RAMECCx Register Field Definitions ****/

  static const field32_t RAMECCx_IER_GIE          = {.msk = 0x00000001U, .pos = 0};   /** @brief Global interrupt enable. */
  static const field32_t RAMECCx_IER_GECCSEIE_    = {.msk = 0x00000002U, .pos = 1};   /** @brief Global ECC single error interrupt enable. */
  static const field32_t RAMECCx_IER_GECCDEIE     = {.msk = 0x00000004U, .pos = 2};   /** @brief Global ECC double error interrupt enable. */
  static const field32_t RAMECCx_IER_GECCDEBWIE   = {.msk = 0x00000008U, .pos = 3};   /** @brief Global ECC double error on byte write (BW) interrupt enable. */
  static const field32_t RAMECCx_MxCR_ECCSEIE     = {.msk = 0x00000004U, .pos = 2};   /** @brief ECC single error interrupt enable. */
  static const field32_t RAMECCx_MxCR_ECCDEIE     = {.msk = 0x00000008U, .pos = 3};   /** @brief ECC double error interrupt enable. */
  static const field32_t RAMECCx_MxCR_ECCDEBWIE   = {.msk = 0x00000010U, .pos = 4};   /** @brief ECC double error on byte write (BW) interrupt enable. */
  static const field32_t RAMECCx_MxCR_ECCELEN     = {.msk = 0x00000020U, .pos = 5};   /** @brief ECC error latching enable. */
  static const field32_t RAMECCx_MxSR_ECCSEIE     = {.msk = 0x00000004U, .pos = 2};   /** @brief ECC single error interrupt enable. */
  static const field32_t RAMECCx_MxSR_ECCDEIE     = {.msk = 0x00000008U, .pos = 3};   /** @brief ECC double error interrupt enable. */
  static const field32_t RAMECCx_MxSR_ECCDEBWIE   = {.msk = 0x00000010U, .pos = 4};   /** @brief ECC double error on byte write (BW) interrupt enable. */
  static const field32_t RAMECCx_MxSR_ECCELEN     = {.msk = 0x00000020U, .pos = 5};   /** @brief ECC error latching enable. */
  static const field32_t RAMECCx_MxFAR_ECCSEIE    = {.msk = 0x00000004U, .pos = 2};   /** @brief ECC single error interrupt enable. */
  static const field32_t RAMECCx_MxFAR_ECCDEIE    = {.msk = 0x00000008U, .pos = 3};   /** @brief ECC double error interrupt enable. */
  static const field32_t RAMECCx_MxFAR_ECCDEBWIE  = {.msk = 0x00000010U, .pos = 4};   /** @brief ECC double error on byte write (BW) interrupt enable. */
  static const field32_t RAMECCx_MxFAR_ECCELEN    = {.msk = 0x00000020U, .pos = 5};   /** @brief ECC error latching enable. */
  static const field32_t RAMECCx_MxFDRL_ECCSEIE   = {.msk = 0x00000004U, .pos = 2};   /** @brief ECC single error interrupt enable. */
  static const field32_t RAMECCx_MxFDRL_ECCDEIE   = {.msk = 0x00000008U, .pos = 3};   /** @brief ECC double error interrupt enable. */
  static const field32_t RAMECCx_MxFDRL_ECCDEBWIE = {.msk = 0x00000010U, .pos = 4};   /** @brief ECC double error on byte write (BW) interrupt enable. */
  static const field32_t RAMECCx_MxFDRL_ECCELEN   = {.msk = 0x00000020U, .pos = 5};   /** @brief ECC error latching enable. */
  static const field32_t RAMECCx_MxFDRH_ECCSEIE   = {.msk = 0x00000004U, .pos = 2};   /** @brief ECC single error interrupt enable. */
  static const field32_t RAMECCx_MxFDRH_ECCDEIE   = {.msk = 0x00000008U, .pos = 3};   /** @brief ECC double error interrupt enable. */
  static const field32_t RAMECCx_MxFDRH_ECCDEBWIE = {.msk = 0x00000010U, .pos = 4};   /** @brief ECC double error on byte write (BW) interrupt enable. */
  static const field32_t RAMECCx_MxFDRH_ECCELEN   = {.msk = 0x00000020U, .pos = 5};   /** @brief ECC error latching enable. */
  static const field32_t RAMECCx_MxFECR_SEDCF     = {.msk = 0x00000001U, .pos = 0};   /** @brief ECC single error detected and corrected flag. */
  static const field32_t RAMECCx_MxFECR_DEDF      = {.msk = 0x00000002U, .pos = 1};   /** @brief ECC double error detected flag. */
  static const field32_t RAMECCx_MxFECR_DEBWDF    = {.msk = 0x00000004U, .pos = 2};   /** @brief ECC double error on byte write (BW) detected flag. */

  /************************************************************************************************
   * ART Definitions
   ************************************************************************************************/

  /**** ART Register Definitions ****/

  static const rw_reg32_t ART_CTR = (rw_reg32_t)0x40024400U;   /** @brief Control register. */

  /**** ART Register Field Definitions ****/

  static const field32_t ART_CTR_EN         = {.msk = 0x00000001U, .pos = 0};   /** @brief Cache enable. */
  static const field32_t ART_CTR_PCACHEADDR = {.msk = 0x000FFF00U, .pos = 8};   /** @brief Cacheable page index. */

  /************************************************************************************************
   * @section SCB Definitions
   ************************************************************************************************/

  /**** @subsection SCB Register Definitions ****/

  static const ro_reg32_t SCB_CPUID                = (ro_reg32_t)0xE000ED00U;   /** @brief CPUID base register. */
  static const rw_reg32_t SCB_ICSR                 = (rw_reg32_t)0xE000ED04U;   /** @brief Interrupt control and state register. */
  static const rw_reg32_t SCB_VTOR                 = (rw_reg32_t)0xE000ED08U;   /** @brief Vector table offset register. */
  static const rw_reg32_t SCB_AIRCR                = (rw_reg32_t)0xE000ED0CU;   /** @brief Application interrupt and reset control register. */
  static const rw_reg32_t SCB_SCR                  = (rw_reg32_t)0xE000ED10U;   /** @brief System control register. */
  static const rw_reg32_t SCB_CCR                  = (rw_reg32_t)0xE000ED14U;   /** @brief Configuration and control register. */
  static const rw_reg32_t SCB_SHCRS                = (rw_reg32_t)0xE000ED24U;   /** @brief System handler control and state register. */
  static const rw_reg32_t SCB_CFSR_UFSR_BFSR_MMFSR = (rw_reg32_t)0xE000ED28U;   /** @brief Configurable fault status register. */
  static const rw_reg32_t SCB_HFSR                 = (rw_reg32_t)0xE000ED2CU;   /** @brief Hard fault status register. */
  static const rw_reg32_t SCB_MMFAR                = (rw_reg32_t)0xE000ED34U;   /** @brief Memory management fault address register. */
  static const rw_reg32_t SCB_BFAR                 = (rw_reg32_t)0xE000ED38U;   /** @brief Bus fault address register. */
  static const rw_reg32_t SCS_CPACR                = (rw_reg32_t)0xE000ED88U;   /** @brief Coprocessor access control register. */

  /**** @subsection Enumerated SCB Register Definitions ****/

  static const rw_reg32_t SCB_SHPRx[4] = {
    [1] = (rw_reg32_t)0xE000ED18U,   /** @brief System handler priority registers. */
    [2] = (rw_reg32_t)0xE000ED1CU,   /** @brief System handler priority registers. */
    [3] = (rw_reg32_t)0xE000ED20U,   /** @brief System handler priority registers. */
  };

  /**** @subsection SCB Register Field Definitions ****/

  static const field32_t SCB_CPUID_REVISION                   = {.msk = 0x0000000FU, .pos = 0};    /** @brief Revision number. */
  static const field32_t SCB_CPUID_PARTNO                     = {.msk = 0x0000FFF0U, .pos = 4};    /** @brief Part number of the processor. */
  static const field32_t SCB_CPUID_CONSTANT                   = {.msk = 0x000F0000U, .pos = 16};   /** @brief Reads as 0xf. */
  static const field32_t SCB_CPUID_VARIANT                    = {.msk = 0x00F00000U, .pos = 20};   /** @brief Variant number. */
  static const field32_t SCB_CPUID_IMPLEMENTER                = {.msk = 0xFF000000U, .pos = 24};   /** @brief Implementer code. */
  static const field32_t SCB_ICSR_VECTACTIVE                  = {.msk = 0x000001FFU, .pos = 0};    /** @brief Active vector. */
  static const field32_t SCB_ICSR_RETTOBASE                   = {.msk = 0x00000800U, .pos = 11};   /** @brief Return to base level. */
  static const field32_t SCB_ICSR_VECTPENDING                 = {.msk = 0x0007F000U, .pos = 12};   /** @brief Pending vector. */
  static const field32_t SCB_ICSR_ISRPENDING                  = {.msk = 0x00400000U, .pos = 22};   /** @brief Interrupt pending flag. */
  static const field32_t SCB_ICSR_PENDSTCLR                   = {.msk = 0x02000000U, .pos = 25};   /** @brief SysTick exception clear-pending bit. */
  static const field32_t SCB_ICSR_PENDSTSET                   = {.msk = 0x04000000U, .pos = 26};   /** @brief SysTick exception set-pending bit. */
  static const field32_t SCB_ICSR_PENDSVCLR                   = {.msk = 0x08000000U, .pos = 27};   /** @brief PendSV clear-pending bit. */
  static const field32_t SCB_ICSR_PENDSVSET                   = {.msk = 0x10000000U, .pos = 28};   /** @brief PendSV set-pending bit. */
  static const field32_t SCB_ICSR_NMIPENDSET                  = {.msk = 0x80000000U, .pos = 31};   /** @brief NMI set-pending bit. */
  static const field32_t SCB_VTOR_TBLOFF                      = {.msk = 0x3FFFFE00U, .pos = 9};    /** @brief Vector table base offset field. */
  static const field32_t SCB_AIRCR_VECTRESET                  = {.msk = 0x00000001U, .pos = 0};    /** @brief VECTRESET. */
  static const field32_t SCB_AIRCR_VECTCLRACTIVE              = {.msk = 0x00000002U, .pos = 1};    /** @brief VECTCLRACTIVE. */
  static const field32_t SCB_AIRCR_SYSRESETREQ                = {.msk = 0x00000004U, .pos = 2};    /** @brief SYSRESETREQ. */
  static const field32_t SCB_AIRCR_PRIGROUP                   = {.msk = 0x00000700U, .pos = 8};    /** @brief PRIGROUP. */
  static const field32_t SCB_AIRCR_ENDIANESS                  = {.msk = 0x00008000U, .pos = 15};   /** @brief ENDIANESS. */
  static const field32_t SCB_AIRCR_VECTKEYSTAT                = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief Register key. */
  static const field32_t SCB_SCR_SLEEPONEXIT                  = {.msk = 0x00000002U, .pos = 1};    /** @brief SLEEPONEXIT. */
  static const field32_t SCB_SCR_SLEEPDEEP                    = {.msk = 0x00000004U, .pos = 2};    /** @brief SLEEPDEEP. */
  static const field32_t SCB_SCR_SEVEONPEND                   = {.msk = 0x00000010U, .pos = 4};    /** @brief Send event on pending bit. */
  static const field32_t SCB_CCR_NONBASETHRDENA               = {.msk = 0x00000001U, .pos = 0};    /** @brief Configures how the processor enters thread mode. */
  static const field32_t SCB_CCR_USERSETMPEND                 = {.msk = 0x00000002U, .pos = 1};    /** @brief USERSETMPEND. */
  static const field32_t SCB_CCR_UNALIGN__TRP                 = {.msk = 0x00000008U, .pos = 3};    /** @brief UNALIGN_ TRP. */
  static const field32_t SCB_CCR_DIV_0_TRP                    = {.msk = 0x00000010U, .pos = 4};    /** @brief DIV_0_TRP. */
  static const field32_t SCB_CCR_BFHFNMIGN                    = {.msk = 0x00000100U, .pos = 8};    /** @brief BFHFNMIGN. */
  static const field32_t SCB_CCR_STKALIGN                     = {.msk = 0x00000200U, .pos = 9};    /** @brief STKALIGN. */
  static const field32_t SCB_CCR_DC                           = {.msk = 0x00010000U, .pos = 16};   /** @brief DC. */
  static const field32_t SCB_CCR_IC                           = {.msk = 0x00020000U, .pos = 17};   /** @brief IC. */
  static const field32_t SCB_CCR_BP                           = {.msk = 0x00040000U, .pos = 18};   /** @brief BP. */
  static const field32_t SCB_SHCRS_MEMFAULTACT                = {.msk = 0x00000001U, .pos = 0};    /** @brief Memory management fault exception active bit. */
  static const field32_t SCB_SHCRS_BUSFAULTACT                = {.msk = 0x00000002U, .pos = 1};    /** @brief Bus fault exception active bit. */
  static const field32_t SCB_SHCRS_USGFAULTACT                = {.msk = 0x00000008U, .pos = 3};    /** @brief Usage fault exception active bit. */
  static const field32_t SCB_SHCRS_SVCALLACT                  = {.msk = 0x00000080U, .pos = 7};    /** @brief SVC call active bit. */
  static const field32_t SCB_SHCRS_MONITORACT                 = {.msk = 0x00000100U, .pos = 8};    /** @brief Debug monitor active bit. */
  static const field32_t SCB_SHCRS_PENDSVACT                  = {.msk = 0x00000400U, .pos = 10};   /** @brief PendSV exception active bit. */
  static const field32_t SCB_SHCRS_SYSTICKACT                 = {.msk = 0x00000800U, .pos = 11};   /** @brief SysTick exception active bit. */
  static const field32_t SCB_SHCRS_USGFAULTPENDED             = {.msk = 0x00001000U, .pos = 12};   /** @brief Usage fault exception pending bit. */
  static const field32_t SCB_SHCRS_MEMFAULTPENDED             = {.msk = 0x00002000U, .pos = 13};   /** @brief Memory management fault exception pending bit. */
  static const field32_t SCB_SHCRS_BUSFAULTPENDED             = {.msk = 0x00004000U, .pos = 14};   /** @brief Bus fault exception pending bit. */
  static const field32_t SCB_SHCRS_SVCALLPENDED               = {.msk = 0x00008000U, .pos = 15};   /** @brief SVC call pending bit. */
  static const field32_t SCB_SHCRS_MEMFAULTENA                = {.msk = 0x00010000U, .pos = 16};   /** @brief Memory management fault enable bit. */
  static const field32_t SCB_SHCRS_BUSFAULTENA                = {.msk = 0x00020000U, .pos = 17};   /** @brief Bus fault enable bit. */
  static const field32_t SCB_SHCRS_USGFAULTENA                = {.msk = 0x00040000U, .pos = 18};   /** @brief Usage fault enable bit. */
  static const field32_t SCB_CFSR_UFSR_BFSR_MMFSR_IACCVIOL    = {.msk = 0x00000001U, .pos = 0};    /** @brief IACCVIOL. */
  static const field32_t SCB_CFSR_UFSR_BFSR_MMFSR_DACCVIOL    = {.msk = 0x00000002U, .pos = 1};    /** @brief DACCVIOL. */
  static const field32_t SCB_CFSR_UFSR_BFSR_MMFSR_MUNSTKERR   = {.msk = 0x00000008U, .pos = 3};    /** @brief MUNSTKERR. */
  static const field32_t SCB_CFSR_UFSR_BFSR_MMFSR_MSTKERR     = {.msk = 0x00000010U, .pos = 4};    /** @brief MSTKERR. */
  static const field32_t SCB_CFSR_UFSR_BFSR_MMFSR_MLSPERR     = {.msk = 0x00000020U, .pos = 5};    /** @brief MLSPERR. */
  static const field32_t SCB_CFSR_UFSR_BFSR_MMFSR_MMARVALID   = {.msk = 0x00000080U, .pos = 7};    /** @brief MMARVALID. */
  static const field32_t SCB_CFSR_UFSR_BFSR_MMFSR_IBUSERR     = {.msk = 0x00000100U, .pos = 8};    /** @brief Instruction bus error. */
  static const field32_t SCB_CFSR_UFSR_BFSR_MMFSR_PRECISERR   = {.msk = 0x00000200U, .pos = 9};    /** @brief Precise data bus error. */
  static const field32_t SCB_CFSR_UFSR_BFSR_MMFSR_IMPRECISERR = {.msk = 0x00000400U, .pos = 10};   /** @brief Imprecise data bus error. */
  static const field32_t SCB_CFSR_UFSR_BFSR_MMFSR_UNSTKERR    = {.msk = 0x00000800U, .pos = 11};   /** @brief Bus fault on unstacking for a return from exception. */
  static const field32_t SCB_CFSR_UFSR_BFSR_MMFSR_STKERR      = {.msk = 0x00001000U, .pos = 12};   /** @brief Bus fault on stacking for exception entry. */
  static const field32_t SCB_CFSR_UFSR_BFSR_MMFSR_LSPERR      = {.msk = 0x00002000U, .pos = 13};   /** @brief Bus fault on floating-point lazy state preservation. */
  static const field32_t SCB_CFSR_UFSR_BFSR_MMFSR_BFARVALID   = {.msk = 0x00008000U, .pos = 15};   /** @brief Bus fault address register (BFAR) valid flag. */
  static const field32_t SCB_CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR  = {.msk = 0x00010000U, .pos = 16};   /** @brief Undefined instruction usage fault. */
  static const field32_t SCB_CFSR_UFSR_BFSR_MMFSR_INVSTATE    = {.msk = 0x00020000U, .pos = 17};   /** @brief Invalid state usage fault. */
  static const field32_t SCB_CFSR_UFSR_BFSR_MMFSR_INVPC       = {.msk = 0x00040000U, .pos = 18};   /** @brief Invalid PC load usage fault. */
  static const field32_t SCB_CFSR_UFSR_BFSR_MMFSR_NOCP        = {.msk = 0x00080000U, .pos = 19};   /** @brief No coprocessor usage fault. */
  static const field32_t SCB_CFSR_UFSR_BFSR_MMFSR_UNALIGNED   = {.msk = 0x01000000U, .pos = 24};   /** @brief Unaligned access usage fault. */
  static const field32_t SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO   = {.msk = 0x02000000U, .pos = 25};   /** @brief Divide by zero usage fault. */
  static const field32_t SCB_HFSR_VECTTBL                     = {.msk = 0x00000002U, .pos = 1};    /** @brief Vector table hard fault. */
  static const field32_t SCB_HFSR_FORCED                      = {.msk = 0x40000000U, .pos = 30};   /** @brief Forced hard fault. */
  static const field32_t SCB_HFSR_DEBUG_VT                    = {.msk = 0x80000000U, .pos = 31};   /** @brief Reserved for debug use. */
  static const field32_t SCS_CPACR_CP                         = {.msk = 0x00F00000U, .pos = 20};   /** @brief Co-processor access control. */

  /**** @subsection Enumerated SCB Register Field Definitions ****/

  static field32_t const SCB_SHPRx_PRI_x[7] = {
    [4] = {.msk = 0x000000FFU, .pos = 0},    /** @brief Priority of system handler 4. */
    [5] = {.msk = 0x0000FF00U, .pos = 8},    /** @brief Priority of system handler 5. */
    [6] = {.msk = 0x00FF0000U, .pos = 16},   /** @brief Priority of system handler 6. */
  };

  /************************************************************************************************
   * @section SYST Definitions
   ************************************************************************************************/

  /**** @subsection SYST Register Definitions ****/

  static const rw_reg32_t SYST_CSR   = (rw_reg32_t)0xE000E010U;   /** @brief SysTick control and status register. */
  static const rw_reg32_t SYST_RVR   = (rw_reg32_t)0xE000E014U;   /** @brief SysTick reload value register. */
  static const rw_reg32_t SYST_CVR   = (rw_reg32_t)0xE000E018U;   /** @brief SysTick current value register. */
  static const rw_reg32_t SYST_CALIB = (rw_reg32_t)0xE000E01CU;   /** @brief SysTick calibration value register. */

  /**** @subsection SYST Register Field Definitions ****/

  static const field32_t SYST_CSR_ENABLE    = {.msk = 0x00000001U, .pos = 0};    /** @brief Counter enable. */
  static const field32_t SYST_CSR_TICKINT   = {.msk = 0x00000002U, .pos = 1};    /** @brief SysTick exception request enable. */
  static const field32_t SYST_CSR_CLKSOURCE = {.msk = 0x00000004U, .pos = 2};    /** @brief Clock source selection. */
  static const field32_t SYST_CSR_COUNTFLAG = {.msk = 0x00010000U, .pos = 16};   /** @brief COUNTFLAG. */
  static const field32_t SYST_RVR_RELOAD    = {.msk = 0x00FFFFFFU, .pos = 0};    /** @brief RELOAD value. */
  static const field32_t SYST_CVR_CURRENT   = {.msk = 0x00FFFFFFU, .pos = 0};    /** @brief Current counter value. */
  static const field32_t SYST_CALIB_TENMS   = {.msk = 0x00FFFFFFU, .pos = 0};    /** @brief Calibration value. */
  static const field32_t SYST_CALIB_SKEW    = {.msk = 0x40000000U, .pos = 30};   /** @brief SKEW flag: indicates whether the TENMS value is exact. */
  static const field32_t SYST_CALIB_NOREF   = {.msk = 0x80000000U, .pos = 31};   /** @brief NOREF flag. Reads as zero. */

  /************************************************************************************************
   * @section NVIC Definitions
   ************************************************************************************************/

  /**** @subsection NVIC Register Definitions ****/

  static const rw_reg32_t NVIC_STIR  = (rw_reg32_t)0xE000EF00U;   /** @brief Software trigger interrupt register. */

  /**** @subsection Enumerated NVIC Register Definitions ****/

  static const rw_reg32_t NVIC_ISERx[4] = {
    [0] = (rw_reg32_t)0xE000E100U,   /** @brief Interrupt set-enable register. */
    [1] = (rw_reg32_t)0xE000E104U,   /** @brief Interrupt set-enable register. */
    [2] = (rw_reg32_t)0xE000E108U,   /** @brief Interrupt set-enable register. */
    [3] = (rw_reg32_t)0xE000E10CU,   /** @brief Interrupt set-enable register. */
  };

  static const rw_reg32_t NVIC_ICERx[4] = {
    [0] = (rw_reg32_t)0xE000E180U,   /** @brief Interrupt clear-enable register. */
    [1] = (rw_reg32_t)0xE000E184U,   /** @brief Interrupt clear-enable register. */
    [2] = (rw_reg32_t)0xE000E188U,   /** @brief Interrupt clear-enable register. */
    [3] = (rw_reg32_t)0xE000E18CU,   /** @brief Interrupt clear-enable register. */
  };

  static const rw_reg32_t NVIC_ISPRx[4] = {
    [0] = (rw_reg32_t)0xE000E200U,   /** @brief Interrupt set-pending register. */
    [1] = (rw_reg32_t)0xE000E204U,   /** @brief Interrupt set-pending register. */
    [2] = (rw_reg32_t)0xE000E208U,   /** @brief Interrupt set-pending register. */
    [3] = (rw_reg32_t)0xE000E20CU,   /** @brief Interrupt set-pending register. */
  };

  static const rw_reg32_t NVIC_ICPRx[4] = {
    [0] = (rw_reg32_t)0xE000E280U,   /** @brief Interrupt clear-pending register. */
    [1] = (rw_reg32_t)0xE000E284U,   /** @brief Interrupt clear-pending register. */
    [2] = (rw_reg32_t)0xE000E288U,   /** @brief Interrupt clear-pending register. */
    [3] = (rw_reg32_t)0xE000E2C0U,   /** @brief Interrupt clear-pending register. */
  };

  static const ro_reg32_t NVIC_IABRx[4] = {
    [0] = (ro_reg32_t)0xE000E300U,   /** @brief Interrupt active bit register. */
    [1] = (ro_reg32_t)0xE000E304U,   /** @brief Interrupt active bit register. */
    [2] = (ro_reg32_t)0xE000E308U,   /** @brief Interrupt active bit register. */
    [3] = (ro_reg32_t)0xE000E30CU,   /** @brief Interrupt active bit register. */
  };

  static const rw_reg32_t NVIC_IPRx[39] = {
    [0]  = (rw_reg32_t)0xE000E400U,   /** @brief Interrupt priority register. */
    [1]  = (rw_reg32_t)0xE000E404U,   /** @brief Interrupt priority register. */
    [2]  = (rw_reg32_t)0xE000E408U,   /** @brief Interrupt priority register. */
    [3]  = (rw_reg32_t)0xE000E40CU,   /** @brief Interrupt priority register. */
    [4]  = (rw_reg32_t)0xE000E410U,   /** @brief Interrupt priority register. */
    [5]  = (rw_reg32_t)0xE000E414U,   /** @brief Interrupt priority register. */
    [6]  = (rw_reg32_t)0xE000E418U,   /** @brief Interrupt priority register. */
    [7]  = (rw_reg32_t)0xE000E41CU,   /** @brief Interrupt priority register. */
    [8]  = (rw_reg32_t)0xE000E420U,   /** @brief Interrupt priority register. */
    [9]  = (rw_reg32_t)0xE000E424U,   /** @brief Interrupt priority register. */
    [10] = (rw_reg32_t)0xE000E428U,   /** @brief Interrupt priority register. */
    [11] = (rw_reg32_t)0xE000E42CU,   /** @brief Interrupt priority register. */
    [12] = (rw_reg32_t)0xE000E430U,   /** @brief Interrupt priority register. */
    [13] = (rw_reg32_t)0xE000E434U,   /** @brief Interrupt priority register. */
    [14] = (rw_reg32_t)0xE000E438U,   /** @brief Interrupt priority register. */
    [15] = (rw_reg32_t)0xE000E43CU,   /** @brief Interrupt priority register. */
    [16] = (rw_reg32_t)0xE000E440U,   /** @brief Interrupt priority register. */
    [17] = (rw_reg32_t)0xE000E444U,   /** @brief Interrupt priority register. */
    [18] = (rw_reg32_t)0xE000E448U,   /** @brief Interrupt priority register. */
    [19] = (rw_reg32_t)0xE000E44CU,   /** @brief Interrupt priority register. */
    [20] = (rw_reg32_t)0xE000E450U,   /** @brief Interrupt priority register. */
    [21] = (rw_reg32_t)0xE000E454U,   /** @brief Interrupt priority register. */
    [22] = (rw_reg32_t)0xE000E458U,   /** @brief Interrupt priority register. */
    [23] = (rw_reg32_t)0xE000E45CU,   /** @brief Interrupt priority register. */
    [24] = (rw_reg32_t)0xE000E460U,   /** @brief Interrupt priority register. */
    [25] = (rw_reg32_t)0xE000E464U,   /** @brief Interrupt priority register. */
    [26] = (rw_reg32_t)0xE000E468U,   /** @brief Interrupt priority register. */
    [27] = (rw_reg32_t)0xE000E46CU,   /** @brief Interrupt priority register. */
    [28] = (rw_reg32_t)0xE000E470U,   /** @brief Interrupt priority register. */
    [29] = (rw_reg32_t)0xE000E474U,   /** @brief Interrupt priority register. */
    [30] = (rw_reg32_t)0xE000E478U,   /** @brief Interrupt priority register. */
    [31] = (rw_reg32_t)0xE000E47CU,   /** @brief Interrupt priority register. */
    [32] = (rw_reg32_t)0xE000E480U,   /** @brief Interrupt priority register. */
    [33] = (rw_reg32_t)0xE000E484U,   /** @brief Interrupt priority register. */
    [34] = (rw_reg32_t)0xE000E488U,   /** @brief Interrupt priority register. */
    [35] = (rw_reg32_t)0xE000E48CU,   /** @brief Interrupt priority register. */
    [36] = (rw_reg32_t)0xE000E490U,   /** @brief Interrupt priority register. */
    [37] = (rw_reg32_t)0xE000E494U,   /** @brief Interrupt priority register. */
    [38] = (rw_reg32_t)0xE000E498U,   /** @brief Interrupt priority register. */
  };

  /**** @subsection NVIC Register Field Definitions ****/

  static const field32_t NVIC_STIR_INTID = {.msk = 0x000001FFU, .pos = 0};   /** @brief Software generated interrupt ID. */

  /**** @subsection Enumerated NVIC Register Field Definitions ****/

  static field32_t const NVIC_IPRx_IPR_Nx[4] = {
    [0] = {.msk = 0x000000FFU, .pos = 0},    /** @brief IPR_N0. */
    [1] = {.msk = 0x0000FF00U, .pos = 8},    /** @brief IPR_N1. */
    [2] = {.msk = 0x00FF0000U, .pos = 16},   /** @brief IPR_N2. */
    [3] = {.msk = 0xFF000000U, .pos = 24},   /** @brief IPR_N3. */
  };

  /************************************************************************************************
   * @section MPU Definitions
   ************************************************************************************************/

  /**** @subsection MPU Register Definitions ****/

  static const ro_reg32_t MPU_MPU_TYPER = (ro_reg32_t)0xE000ED90U;   /** @brief MPU type register. */
  static const ro_reg32_t MPU_MPU_CTRL  = (ro_reg32_t)0xE000ED94U;   /** @brief MPU control register. */
  static const rw_reg32_t MPU_MPU_RNR   = (rw_reg32_t)0xE000ED98U;   /** @brief MPU region number register. */
  static const rw_reg32_t MPU_MPU_RBAR  = (rw_reg32_t)0xE000ED9CU;   /** @brief MPU region base address register. */
  static const rw_reg32_t MPU_MPU_RASR  = (rw_reg32_t)0xE000EDA0U;   /** @brief MPU region attribute and size register. */

  /**** @subsection MPU Register Field Definitions ****/

  static const field32_t MPU_MPU_TYPER_SEPARATE  = {.msk = 0x00000001U, .pos = 0};    /** @brief Separate flag. */
  static const field32_t MPU_MPU_TYPER_DREGION   = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Number of MPU data regions. */
  static const field32_t MPU_MPU_TYPER_IREGION   = {.msk = 0x00FF0000U, .pos = 16};   /** @brief Number of MPU instruction regions. */
  static const field32_t MPU_MPU_CTRL_ENABLE     = {.msk = 0x00000001U, .pos = 0};    /** @brief Enables the MPU. */
  static const field32_t MPU_MPU_CTRL_HFNMIENA   = {.msk = 0x00000002U, .pos = 1};    /** @brief Enables the operation of MPU during hard fault. */
  static const field32_t MPU_MPU_CTRL_PRIVDEFENA = {.msk = 0x00000004U, .pos = 2};    /** @brief Enable priviliged software access to default memory map. */
  static const field32_t MPU_MPU_RNR_REGION      = {.msk = 0x000000FFU, .pos = 0};    /** @brief MPU region. */
  static const field32_t MPU_MPU_RBAR_REGION     = {.msk = 0x0000000FU, .pos = 0};    /** @brief MPU region field. */
  static const field32_t MPU_MPU_RBAR_VALID      = {.msk = 0x00000010U, .pos = 4};    /** @brief MPU region number valid. */
  static const field32_t MPU_MPU_RBAR_ADDR       = {.msk = 0xFFFFFFE0U, .pos = 5};    /** @brief Region base address field. */
  static const field32_t MPU_MPU_RASR_ENABLE     = {.msk = 0x00000001U, .pos = 0};    /** @brief Region enable bit. */
  static const field32_t MPU_MPU_RASR_SIZE       = {.msk = 0x0000003EU, .pos = 1};    /** @brief Size of the MPU protection region. */
  static const field32_t MPU_MPU_RASR_SRD        = {.msk = 0x0000FF00U, .pos = 8};    /** @brief Subregion disable bits. */
  static const field32_t MPU_MPU_RASR_B          = {.msk = 0x00010000U, .pos = 16};   /** @brief Memory attribute. */
  static const field32_t MPU_MPU_RASR_C          = {.msk = 0x00020000U, .pos = 17};   /** @brief Memory attribute. */
  static const field32_t MPU_MPU_RASR_S          = {.msk = 0x00040000U, .pos = 18};   /** @brief Shareable memory attribute. */
  static const field32_t MPU_MPU_RASR_TEX        = {.msk = 0x00380000U, .pos = 19};   /** @brief Memory attribute. */
  static const field32_t MPU_MPU_RASR_AP         = {.msk = 0x07000000U, .pos = 24};   /** @brief Access permission. */
  static const field32_t MPU_MPU_RASR_XN         = {.msk = 0x10000000U, .pos = 28};   /** @brief Instruction access disable bit. */

  /************************************************************************************************
   * @section FPU Definitions
   ************************************************************************************************/

  /**** @subsection FPU Register Definitions ****/

  static const rw_reg32_t FPU_FPCCR = (rw_reg32_t)0xE000EF34U;   /** @brief Floating-point context control register. */
  static const rw_reg32_t FPU_FPCAR = (rw_reg32_t)0xE000EF38U;   /** @brief Floating-point context address register. */
  static const rw_reg32_t FPU_FPSCR = (rw_reg32_t)0xE000EF3CU;   /** @brief Floating-point status control register. */

  /**** @subsection FPU Register Field Definitions ****/

  static const field32_t FPU_FPCCR_LSPACT  = {.msk = 0x00000001U, .pos = 0};    /** @brief LSPACT. */
  static const field32_t FPU_FPCCR_USER    = {.msk = 0x00000002U, .pos = 1};    /** @brief USER. */
  static const field32_t FPU_FPCCR_THREAD  = {.msk = 0x00000008U, .pos = 3};    /** @brief THREAD. */
  static const field32_t FPU_FPCCR_HFRDY   = {.msk = 0x00000010U, .pos = 4};    /** @brief HFRDY. */
  static const field32_t FPU_FPCCR_MMRDY   = {.msk = 0x00000020U, .pos = 5};    /** @brief MMRDY. */
  static const field32_t FPU_FPCCR_BFRDY   = {.msk = 0x00000040U, .pos = 6};    /** @brief BFRDY. */
  static const field32_t FPU_FPCCR_MONRDY  = {.msk = 0x00000100U, .pos = 8};    /** @brief MONRDY. */
  static const field32_t FPU_FPCCR_LSPEN   = {.msk = 0x40000000U, .pos = 30};   /** @brief LSPEN. */
  static const field32_t FPU_FPCCR_ASPEN   = {.msk = 0x80000000U, .pos = 31};   /** @brief ASPEN. */
  static const field32_t FPU_FPCAR_ADDRESS = {.msk = 0xFFFFFFF8U, .pos = 3};    /** @brief Location of unpopulated floating-point. */
  static const field32_t FPU_FPSCR_IOC     = {.msk = 0x00000001U, .pos = 0};    /** @brief Invalid operation cumulative exception bit. */
  static const field32_t FPU_FPSCR_DZC     = {.msk = 0x00000002U, .pos = 1};    /** @brief Division by zero cumulative exception bit. */
  static const field32_t FPU_FPSCR_OFC     = {.msk = 0x00000004U, .pos = 2};    /** @brief Overflow cumulative exception bit. */
  static const field32_t FPU_FPSCR_UFC     = {.msk = 0x00000008U, .pos = 3};    /** @brief Underflow cumulative exception bit. */
  static const field32_t FPU_FPSCR_IXC     = {.msk = 0x00000010U, .pos = 4};    /** @brief Inexact cumulative exception bit. */
  static const field32_t FPU_FPSCR_IDC     = {.msk = 0x00000080U, .pos = 7};    /** @brief Input denormal cumulative exception bit. */
  static const field32_t FPU_FPSCR_RMODE   = {.msk = 0x00C00000U, .pos = 22};   /** @brief Rounding mode control field. */
  static const field32_t FPU_FPSCR_FZ      = {.msk = 0x01000000U, .pos = 24};   /** @brief Flush-to-zero mode control bit:. */
  static const field32_t FPU_FPSCR_DN      = {.msk = 0x02000000U, .pos = 25};   /** @brief Default nan mode control bit. */
  static const field32_t FPU_FPSCR_AHP     = {.msk = 0x04000000U, .pos = 26};   /** @brief Alternative half-precision control bit. */
  static const field32_t FPU_FPSCR_V       = {.msk = 0x10000000U, .pos = 28};   /** @brief Overflow condition code flag. */
  static const field32_t FPU_FPSCR_C       = {.msk = 0x20000000U, .pos = 29};   /** @brief Carry condition code flag. */
  static const field32_t FPU_FPSCR_Z       = {.msk = 0x40000000U, .pos = 30};   /** @brief Zero condition code flag. */
  static const field32_t FPU_FPSCR_N       = {.msk = 0x80000000U, .pos = 31};   /** @brief Negative condition code flag. */

  /************************************************************************************************
   * @section DBG Definitions
   ************************************************************************************************/

  /**** @subsection DBG Register Definitions ****/

  static const rw_reg32_t DBG_DHCSR  = (rw_reg32_t)0xE000EDF0U;   /** @brief Debug Halting Control and Status Register. */
  static const rw_reg32_t DBG_DCRSR  = (rw_reg32_t)0xE000EDF4U;   /** @brief Debug Core Register Selector Register. */
  static const rw_reg32_t DBG_DCRDR  = (rw_reg32_t)0xE000EDF8U;   /** @brief Debug Core Register Data Register. */
  static const rw_reg32_t DBG_DEMCR  = (rw_reg32_t)0xE000EDFCU;   /** @brief Debug Exception and Monitor Control Register. */

  /**** @subsection DBG Field Definitions ****/

  static const field32_t DBG_DHCSR_DBGKEY      = {.msk = 0xFFFF0000U, .pos = 16};   /** @brief Debug key. */
  static const field32_t DBG_DHCSR_C_DEBUGEN   = {.msk = 0x00000001U, .pos = 0};    /** @brief Debug enable. */
  static const field32_t DBG_DHCSR_C_HALT      = {.msk = 0x00000002U, .pos = 1};    /** @brief Halt. */
  static const field32_t DBG_DHCSR_C_STEP      = {.msk = 0x00000004U, .pos = 2};    /** @brief Step. */
  static const field32_t DBG_DHCSR_C_MASKINTS  = {.msk = 0x00000008U, .pos = 3};    /** @brief Mask interrupts. */
  static const field32_t DBG_DHCSR_C_SNAPSTALL = {.msk = 0x00000020U, .pos = 5};    /** @brief Snap stall. */
  static const field32_t DBG_DHCSR_S_REGRDY    = {.msk = 0x00010000U, .pos = 16};   /** @brief Regulator ready. */
  static const field32_t DBG_DHCSR_S_HALT      = {.msk = 0x00020000U, .pos = 17};   /** @brief Halt status. */
  static const field32_t DBG_DHCSR_S_SLEEP     = {.msk = 0x00040000U, .pos = 18};   /** @brief Sleep status. */
  static const field32_t DBG_DHCSR_S_LOCKUP    = {.msk = 0x00080000U, .pos = 19};   /** @brief Lockup. */
  static const field32_t DBG_DHCSR_S_RETIRE_ST = {.msk = 0x02000000U, .pos = 25};   /** @brief Retire sticky. */
  static const field32_t DBG_DHCSR_S_RESET_ST  = {.msk = 0x04000000U, .pos = 26};   /** @brief Reset sticky. */
  static const field32_t DBG_DHCSR_S_RETIRE    = {.msk = 0x20000000U, .pos = 29};   /** @brief Retire. */
  static const field32_t DBG_DHCSR_S_RESET     = {.msk = 0x40000000U, .pos = 30};   /** @brief Reset. */
  static const field32_t DBG_DHCSR_S_SDE       = {.msk = 0x80000000U, .pos = 31};   /** @brief Secure debug enable. */
  static const field32_t DBG_DCRSR_REGWnR      = {.msk = 0x00010000U, .pos = 16};   /** @brief Register write not read. */
  static const field32_t DBG_DEMCR_TRCENA      = {.msk = 0x01000000U, .pos = 24};   /** @brief Trace enable. */
  static const field32_t DBG_DEMCR_MON_REQ     = {.msk = 0x80000000U, .pos = 31};   /** @brief Monitor request. */

#ifdef __cplusplus
  } // extern "C"
#endif

/** @endinternal */